% !TeX root = easycrypt.tex

\chapter{Getting Started}
\section{Installation}

\section{Basic Example (Tutorial)\label{sec:tutorial}}
In this section we present a formalization of the proof of security
against chosen plaintext attacks of a public-key encryption scheme
introduced by \citet{br93}.

This scheme is based on one-way trapdoor permutations and uses a
random oracle. The proof of security follows by reduction: given an
adversary against the chosen plaintext attack experiment that has
access to the random oracle, there exists an inverter (making use of
the adversary) that succeds in inverting the underlying trapdoor
permutation with at least as much probability.

While the proof of this scheme is not involved, it allows us to
introduce several features of \EC both on the modelling and on
the proving side.

On the modelling side, we will describe how to define abstract operators
and axioms; how to clone theories; how to define module types, modules
and how to model adversaries as abstract procedures.

On the proving side, we will explain how to perform reasoning up to
failure; optimistic sampling and simple reasoning about probabilites
of events in games.

\subsection{Setting}
We begin by introducing some basic concepts of cryptography and how we
model them in \EC.

\paragraph{Bitstrings}
As part of its standard library, \EC provides a theory of fixed-length
bitstrings coined \ec{Word}. For the purpose of this example, we will
need bitstrings of three different lengths, \ec{k} for messages, \ec{l}
for randomness and \ec{n} for ciphers; such that \ec{k + l = n}. The
following piece of code declares three integer constants and states
the desired property as an axiom, clones the theories with appropriate
lengths and defines synonyms for the types.

\ecimport{ }{../examples/br93_tutorial.ec}{bitstrings}


The \ec{import} keyword allows us to ommit the qualified names when
they can be inferred from the context. 

We will be interested in sampling from uniform distributions of types
\ec{randomness} and \ec{plaintext}. These distributions are defined in
the standard library, but we define shortcuts to them as follows

\ecimport{ }{../examples/br93_tutorial.ec}{distributions}

The inner workings of cloning are provided in 

\paragraph{Random oracles}
A hash function in the random oracle model is a consistent random
function: new queries trigger samplings that are stored in a map; old
queries trigger a map lookup. 

Adversaries are normally given restricted access to the oracle, in the
sense that the amount of calls allowed is bounded. Moreover, we keep
track of the queries triggered by the adversary. 

The following piece of code defines two signatures for random oracles:
the one that will be used in the encryption of messages and the one
that will be provided to adversaries. Moreover, we define an
implementation between types \ec{randomness} and \ec{plaintext} as
defined above.

\ecimport{ }{../examples/br93_tutorial.ec}{random_oracles}


The module \ec{RO} is assigned two module types: \ec{Oracle} and
\ec{ARO} and implements both the normal oracle and the adversary
interface. It consists of a global variable \ec{m} that models the map
of the random oracle; a global variable \ec{s} that models the queries
performed by the adversary, a function \ec{init} that initializes the
map to \ec{empty} and the set to \ec{empty}, a function \ec{o} that
models the actual oracle and a function that models the adversary
version. The former takes an argument \ec{x} of type \ec{randomness},
samples a value \ec{y} of type \ec{plaintext}, updates the value of
the map in case it's necesary and finally returns the lookup of \ec{x}
in the map \ec{m}. The latter checks that the adversary has not
exceeded the amount of calls as prescribed by \ec{qO}; and if this is
the case, records the query in \ec{s}, calls \ec{o} and retunrs its
result; otherwise, it returns a bitstring consisting of zeros.


\paragraph{One-way trapdoor permutations}
Trapdoor permutations are functions that are ``easy'' to compute, but
hard to invert without knowing a secret key. Formally, a family
of trapdoor permutations on a type \ec{T} is a triple of algorithms
$(\KG,f,f^{-1})$ such that for any pair of keys $(pk,sk)$ output by
$\KG$, $f_{pk}$ and $f^{-1}_{sk}$ are permutations on
\ec{T} and inverse of each other. 

In these case, we are interested in trapdoor permutations on type
\ec{randomness}. In \EC we model them as follows

\ecimport{ }{../examples/br93_tutorial.ec}{one_way}

First, we declare two types \ec{pkey} and \ec{skey} that represent
public and secret keys respectively. We then declare a distribution
\ec{keypairs} that will be used by the $\KG$ algorithm to produce fresh
keys. We then declare an abstract predicate that will model when two
keys are matching and specify that all the pairs of keys that can be
sampled from \ec{keypairs} are matching. Afterwards, we declare \ec{f}
and \ec{finv} with the appropriate type and we state the axioms saying
that one is inverse of eachother for valid key pairs.
 
The module \ec{OW} is defined by declaring an interface corresponding
to the inverter, which comprises a function that given a challenge
value and a public key returns a guess for the pre-image of the
challenge. The OW experiment is then defined by sampling a value
\ec{x} and a pair of keys \ec{pk} and \ec{sk} and providing the
inverter with \ec{f pk x}. The inverter returns a value \ec{x'} and
the experiment succeds if \ec{x = x'}.

\paragraph{Public-key encryption}
A public-key encryption scheme consists of a triple of algorithms
$(\KG,\Enc,\Dec)$:

\begin{description}
\item[Key Generation] 
  The key generation algorithm $\KG$ produces a pair of keys $(pk,sk)$;
  $pk$ is a \emph{public-key} used for encryption, $sk$ is
  a \emph{secret-key} used for decryption;

\item[Encryption] 
  Given a public-key $pk$ and a message $m$, $\Enc_{pk}(m)$ outputs a
  ciphertext $c$;

\item[Decryption] 
  Given a secret-key $sk$ and a ciphertext $c$, $\Dec_{sk}(c)$ outputs
  either message $m$ or a distinguished value $\bot$ denoting failure.
\end{description}
%
We require that for pairs of keys $(pk,sk)$ generated by $\KG$,
$\Dec_{sk}(\Enc_{pk}(m))= m$ holds for any message $m$. 

In \EC, we model public-key encryption schemes in the following way

\ecimport{ }{../examples/br93_tutorial.ec}{scheme}

We declare the interface of an encryption scheme, that consists of a
key generation algorithm \ec{kg}, an encryption function \ec{enc} and
a decryption function \ec{dec}. Note that we are actually modelling
the particular class of encryption schemes that use at most one random
oracle.

\paragraph{The BR93 scheme}
The scheme we consider defines encryption as 
$\Enc_{pk}(m) = f_{pk}(r) \concat m \xor H(r)$, where $r$ is a
randomly sampled value and $H(r)$ denotes the result of a hash oracle
call with value $r$.

 In easycrypt we model the encryption scheme as an instance of our
 \ec{Scheme} signature as follows

\ecimport{ }{../examples/br93_tutorial.ec}{br93}

First, we define a concatenation operation with the appropriate
type. In doing so, we make use of the array library, in particular,
the concat operation \ec{||}. Note that we have to insert the
appropriate cast functions that allows us to move from boolean arrays
to bitstrings of fixed size. We then define some useful lemmas (we
ommit the proofs for conciseness).

Afterwards, we define the module \ec{BR}, that makes use of a random
oracle \ec{R} and has type \ec{Scheme(R)}. This module defines the
required operations in the \ec{Scheme} signature. \ec{kg} samples a
pair of keys and returns them. \ec{enc} takes a public key \ec{pk} and
a plaintext \ec{m} and encrypts by samplying a random value \ec{r},
querying the oracle with this value and applying \ec{f} to \ec{pk} and
\ec{r} and appending it to the xor of result of the hash call and the
message. Decryption is defined by projecting the first part of \ec{c}
and applying \ec{finv} with \ec{sk} to it to recover the
randomness. Afterwards, we query the oracle with the randomness and
xor the result with the second part of \ec{c}.

\paragraph{The \textsf{IND-CPA} experiment}
The CPA experiment can be described in \EC as follows:

\ecimport{ }{../examples/br93_tutorial.ec}{cpa}

We start by declaring a module type for the adversary. This interface
establishes that an adversary has to provide two functions. The
function \ec{a1} corresponds to the first round of the CPA game in
which the adverasay is given a public key \ec{pk} and produces two
plaintext of its choice. The function \ec{a2} corresponds to the
second phase, in which the adversary is presented with a challenge
ciphertext \ec{c} and he has to determine (by producing a boolean)
which plaintext was encrypted.

The module \ec{CPA} is parametrized by an adversary \ec{A_} and a
scheme \ec{S}. Note however, that in order to use these modules we
have to instantiate them with a random oracle. However, we will not
use the same oracle for both: for the encryption we use the bare
random oracle \ec{RO}, but for the adversary we first define \ec{AO},
a wrapped version of the oracle that provides the increased
functionality mentioned previously, and then we instantiate \ec{A_}
with it.

The function \ec{main} defines the CPA experiment. We initialize the
adversary oracle, and we call the key generation algorithm and obtain
\ec{pk} and \ec{sk}. Then we provide \ec{a1} with the public key and get
two plaintext \ec{m0} and \ec{m1}. We proceed by sampling a random bit
and we encrypt either \ec{m0} or \ec{m1} according to its value and we
call \ec{a2} with this ciphertext as argument and obtain a boolean
\ec{b'}. The experiment returns true if the adversary manages to
establish the value of \ec{b}, {\em i.e.} it returns \ec{b=b'}.

\paragraph{Security property}
We are interested in proving that for any adversary \ec{A} against CPA,
that manages to win with probability $P$, there exists a inverter
I that manages to win the one-way experiment with probability $Q$ such
that $| P - \frac{1}{2} |\leq Q$. The intuition is that an adversary
that constantly returns \ec{true} wins with probability
$\frac{1}{2}$. What we are measuring is essentially how much better
can an adversary do, and we are bounding it in terms of the
probability of suceeding in the one-way experiment.

This property is formalized in \EC as follows:
\begin{easycrypt}[label={lst:cpa}]{}
lemma Conclusion :
forall (A <: Adv {Rnd, RO}) &m :
(forall (O <: ARO),  islossless O.o => islossless A(O).a1) =>
(forall (O <: ARO),  islossless O.o => islossless A(O).a2) =>
 exists (I<:Inverter), 
Pr[CPA(BR,A).main() @ &m : res] - 1%r / 2%r <= 
Pr[OW(I).main() @ &m : res].
\end{easycrypt}

The lemma \ec{Conclusion} is parametrized by an adversary \ec{A}. The
annotations \ec{\{CPA,CPA2, BR, BR2, BR3, OW, RO, ARO, BR_OW\}} are
memory access restrctions: essentially, the adversary cannot access
the memories of these modules directly---only through oracle
calls. The next parameter of the lemma is a memory \ec{m}. Next, we
have one hypothesis that states that if the wrapped version of the
random oracle terminates with probability $1$, so does the
adversary. The \ec{\%r} next to constants establishes that they should
be interpreted as real values. The existential quantification binds a
module \ec{I} of type \ec{Inverter}. The expression
\ec{Pr[CPA(BR,A).main() @ &m : res]} denotes the probability of the
event \ec{res} in the distribution obtained after executing the
\ec{main} function of module \ec{CPA}, instantiated with the module
\ec{BR} and the parametrized adversary $A$ in initial memory
\ec{m}. Similarly, the expression \ec{Pr[OW(BR_OW(A)).main() @ &m :
  res]} denotes the probability of the event \ec{res} in the
distribution obtained after executing the \ec{main} function of module
\ec{OW}, instantiated with the existentially quantified module \ec{I},
in initial memory \ec{m}. These two expressions are of type real and
the \ec{<=} real less or equal operator.

The rest of the tutorial is devoted to introducing and explaining the
reasoning principles of \EC required to establih this property.
%TODO: put forward pointers to françois' and guillaume's section

\subsection{Overview of the proof}

\subsection{Easycrypt proof}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "easycrypt"
%%% End: 
