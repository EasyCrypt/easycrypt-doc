% !TeX root = easycrypt.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DEFS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\ambientKeywords}{}

\newcommand{\tacname}{Error tacname}
\newcommand{\vtacname}{Error tacname}

\newcommand{\makeAmbient}[3]{
  \expandafter\def\expandafter\ambientKeywords\expandafter{\ambientKeywords,#1}
  \renewcommand{\tacname}{\rawec{#1}}
  \renewcommand{\vtacname}{#1}
  \index{ambient}{#1@\rawec{#1}}
  \subsubsection{#1}
  \Syntax \rawec{#1} #2
  \Description #3
  \renewcommand{\tacname}{Error tacname}
  \renewcommand{\vtacname}{Error tacname}
}

\newcommand{\ambientLambda}{}
\newcommand{\addLambda}[3]{
  \expandafter\def\expandafter\ambientLambda\expandafter{\ambientLambda\makeAmbient{#1}{#2}{#3}}
}
\newcommand{\ambientLogic}{}
\newcommand{\addLogic}[3]{
  \expandafter\def\expandafter\ambientLogic\expandafter{\ambientLogic\makeAmbient{#1}{#2}{#3}}
}
\newcommand{\ambientAuto}{}
\newcommand{\addAuto}[3]{
  \expandafter\def\expandafter\ambientAuto\expandafter{\ambientAuto\makeAmbient{#1}{#2}{#3}}
}
\newcommand{\ambientOther}{}
\newcommand{\addOther}[3]{
  \expandafter\def\expandafter\ambientOther\expandafter{\ambientOther\makeAmbient{#1}{#2}{#3}}
}


\newcommand{\example}[6]%proof,context,goal
{
\vspace*{3ex}
\begin{tabular}{ccc}
\parbox{100pt}{#1} & {\expandafter\rawec\expandafter{#3 #4.}} & \parbox{100pt}{#5} \\
\cline{0-0} \cline{3-3} {\ec{#2}} & ~ & {\ec{#6}} \\
\end{tabular}\\
}

\newcommand{\env}[2]{\ec{#1 : #2}\\}

\newcommand{\vararg}[1]{\ec{#1}}
\newcommand{\cstarg}[1]{\ec{#1}}
\newcommand{\typarg}[1]{\textit{#1}}

\newcommand{\tacarg}[2]{(\vararg{#1}:\typarg{#2})}

\newcommand{\refdef}[1]{\emph{#1}(\ref{#1})}

\newcommand{\ambientDesc}{
\subsection{Generalities}

The ambient logic is based on a higher-order logic. TODO

\subsubsection{convertible}\label{convertible}

\subsection{Lambda calculus}
    The tactics of this section correspond to lambda calculus reduction. It will find a redex, reduce it
    and do it again until there is no more redex. You can chain tactics by separating them with space and it
    will act as a new tactic that search for the redex of the two tactics and reduce them and do it again.
    \ambientLambda

\subsection{Logic}
    \ambientLogic

\subsection{Automatic}
    \ambientAuto

\subsection{Others}
    \ambientOther
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LAMBDA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%change
\addLambda{change}{\tacarg{f}{formula}}{This tactics permits to change the current goal to f.
\begin{displaymath}
  \infrule{G \equiv F ~ ~ ~ F}{G}
\end{displaymath}}

%beta
\addLambda{beta}{}{Apply all possible beta-reduction}

%iota
\addLambda{iota}{}{Reduce let tuple and if}

%zeta
\addLambda{zeta}{}{Reduce let}

%logic
\addLambda{logic}{}{Do logical simplification}

%delta
\addLambda{delta}{\tacarg{name}{ident*}}{Replace all occurence of all ident present in \vararg{names} by their values if no \vararg{name} is specify it replaces everithing possible.}

%simplify
\addLambda{simplify}{\tacarg{names}{ident*} | \var{delta}?}{Compute the normal form by applying the previous tactics in the given order and it applys delta if delta is specify and just delta names if names is specify}

%congr
\addLambda
{congr}{}
{This tactic applies to a goal of the form \ec{f t1 ... tn = f u1 ... un}
 replacing it by  the subgoals \ec{ti = ui} for all \ec{i}. Note that subgoals
 solvable by \ec{reflexivity} are automatically closed.}

%pose
\addLambda{pose}{\tacarg{x}{ident} \cstarg{:=} \tacarg{expr}{pattern}}{
This tactic permits to introduce a new variable in your context with a
specific value. You don't have to specify the complete expression, \vararg{expr} is a pattern matching.}

%split
\addLogic{split}{}
{\tacname{} tactic permits to do several things :
\begin{itemize}
  \item end a proof when you just have a term \refdef{convertible} to true.
  \item end a proof when you just have an equality between two terms that are \refdef{convertible}.
  \item replace a iff by the direct and indirect implication.
  \item replace an and statement by two goals : the left side and the right side.
  \item replace a n-tuple equality by n equality of the component.
\end{itemize}
\begin{displaymath}
  \infrule{a \equiv true}{a}
  ~~~~~~
  \infrule{a \equiv b}{a = b}
  ~~~~~~
  \infrule{\Gamma \vdash A \Rightarrow B ~ ~ ~ \Gamma \vdash B \Rightarrow A}{\Gamma \vdash A \Leftrightarrow B}
  ~~~~~~
  \infrule{\Gamma \vdash A ~ ~ ~ \Gamma \vdash B}{\Gamma \vdash A \land B}
  ~~~~~~
  \infrule{\Gamma \vdash a_1 = b_1  ~ ~ ~ ...  ~ ~ ~ \Gamma \vdash a_n = b_n}{\Gamma \vdash (a_1, ..., a_n) = (b_1, ..., b_n)}
  ~~~~~~
\end{displaymath}
}

%left
\addLogic{left}{}{This tactic permits to prove a $\lor$ statement by proving only the left side. You must be aware that this tactics will transform your goal in a stronger one.
\begin{displaymath}
  \infrule{\Gamma \vdash A}{\Gamma \vdash A \lor B}
\end{displaymath}}

%right
\addLogic{right}{}{This tactic permits to prove a $\lor$ statement by proving only the right side. You must be aware that this tactics will transform your goal in a stronger one.
\begin{displaymath}
  \infrule{\Gamma \vdash B}{\Gamma \vdash A \lor B}
\end{displaymath}}

%generalize
\addLogic{generalize}{\tacarg{C}{formula}}{
You must be aware that this tactics will transform your goal in a stronger one.
\begin{displaymath}
  \infrule{\Gamma \vdash C ~ ~ ~ \Gamma \vdash \forall x, G[C <- x]}{\Gamma \vdash G}
\end{displaymath}}

%case
\addLogic{case}{\tacarg{F}{formula}}{This tactic creates two subgoals, one where \vararg{F} is true and an other where \vararg{F} is false.
\begin{displaymath}
  \infrule{\Gamma \vdash f => G ~ ~ ~ \Gamma \vdash \neg f => G}{\Gamma \vdash G}
\end{displaymath}}

%assumption
\addLogic{assumption}{\tacarg{h}{ident}?}{It close the current goal by checking you have it in your context up to \refdef{conversion}.
If you don't specify \vararg{h} it test all the \refdef{judgement} present in the context, else it just tests \vararg{h}
\begin{displaymath}
  \infrule{H \equiv G}{\Gamma,h:H \vdash G}
\end{displaymath}}

%intros
\addLogic
{intros}
{\tacarg{x}{\_|ident}}
{This tactics permits to remove of your goal : a forall, the left side af an application or a let assignement by pushing it into your \refdef{context}.
Easycrypt checks that \vararg{x} is not already present in the \refdef{environment}.
\begin{displaymath}
  \infrule{\Gamma,x = a \vdash G(x)}{\Gamma \vdash let x = a in G(x)}
  ~~~~~~
  \infrule{\Gamma,x \vdash G(x)}{\Gamma \vdash \forall x, G(x)}
  ~~~~~~
  \infrule{\Gamma,H \vdash G}{\Gamma \vdash H => G}
  ~~~~~~
\end{displaymath}

\example
{}{forall (x y:int), x = 3 => x = 3}
{\vtacname}{a b hyp1}
{
\env{a}{int}
\env{b}{int}
\env{h1}{a=3}
}
{b = 3}
}

%cut
\addLogic{cut}{\tacarg{h}{ident} : \tacarg{C}{formula}}{It will ask you to first prove the lemma and then push it into your \refdef{context}.
\begin{displaymath}
  \infrule{\Gamma \vdash C ~ \Gamma,C \vdash G}{\Gamma \vdash G}
\end{displaymath}}

%elim
\addLogic{elim}{\tacarg{h}{ident}}{This tactics take as argument the name of a \refdef{judgment} from the \refdef{context} or the \refdef{scope}.
\begin{displaymath}
  \infrule{\Gamma, h:A \land B \vdash A \Rightarrow B \Rightarrow G}{\Gamma, h:A \land B \vdash G}
  ~~~~~~
  \infrule{\Gamma, h:\exists x, A(x) \vdash \forall x, A(x) \rightarrow G}{\Gamma, h:\exists x, A \vdash G}
\end{displaymath}\\
\begin{displaymath}
  \infrule{\Gamma, h:(a_1, ..., a_n) = (b_1, ..., b_n) \vdash a_1 = b_1 \Rightarrow ... \Rightarrow a_n = b_n \Rightarrow G}{\Gamma, h:(a_1, ..., a_n) = (b_1, ..., b_n) \vdash G}
\end{displaymath}}

%smt
\addAuto
{smt}
{[\ec{nolocal}]}
{Try to solve the goal using SMT solvers. The goal is sent along with all the
 lemmas proved so far plus the local hypotheses, unless the \ec{nolocal} is
 given.
 
 \noindent
 \warningbox{Not all lemmas can be sent translated in such a way that they can
  be sent to the SMT provers. For instance, any formulas involving pRHL
  constructions are ignored.}}

%apply
\addAuto{apply}{TODO}{Apply a lemma in order to prove the current goal TODO}

%rewrite
\addAuto
{rewrite}
{rw1 ... rw${}_n$ where the rw${}_i$ are of the form \ec{//},
\ec{/=}, \ec{//=}, a proof-term or a pattern prefixed by \ec{/}
(slash). The two last forms can be prefixed by a direction indicator (the sign
\ec{-}), followed by an occurence selector (\ec{\{i1 ... in\}}),
followed by repetition marker (\ec{!}, \ec{?}, \ec{i!} or \ec{i?}). All
these prefixes are optional.}
{Depending on the form of \ec{rw}, \tacname{} \ec{rw} does the following:
  \begin{itemize}
   \item Call \rawec{trivial} if \ec{rw} is \ec{//},
   \item Call \rawec{simplify} if \ec{rw} is \ec{/=},
   \item Call \rawec{simplify; trivial} as \ec{rw} is \ec{//=},
   \item If \ec{rw} is a proof-term for the pattern (formula)
     \begin{center}
      \ec{forall (x1 : t1) ... (xn : tn), A1 -> ... -> An -> f1 = f2}
     \end{center}
     \noindent then \tacname{} searches for the first subterm of the goal
     matching \ec{f1} and resulting in the full instanciation of the pattern.
     It then replaces, after instanciation of the pattern, all the occurences
     of \ec{f1} by \ec{f2} in the goal, and creates $n$ new subgoals for the
     \ec{Ai}'s. If no subterms of the goal match \ec{f1} or if the pattern
     cannot be fully instanciated by matching, the tactic fails.
     The tactic works the same if the pattern ends by \ec{f1 <-> f2}. If the
     direction indicator \ec{-} is given, \tacname{} works in the reverse
     direction, searching for a match of \ec{f2} and then replacing all
     occurences of \ec{f2} by \ec{f1}.
   \item If \ec{rw} is a \ec{/}-prefixed pattern of the form \ec{(o p1 ... pn)},
     with \ec{o} a defined symbol, then \tacname{} searches for the first subterm
     of the goal matching \ec{(o p1 ... pn)} and resulting in the full instanciation
     of the pattern. It then replaces, after instanciation of the pattern, all
     the occurences of \ec{(o p1 ... pn)} by the $\beta\delta_{\rm o}$ head-normal form
     of \ec{(o p1 ... pn)}. If no subterms of the goal match \ec{(o p1 ... pn)} or
     if the pattern cannot be fully instanciated by matching, the tactic fails. If the
     direction indicator \ec{-} is given, \tacname{} works in the reverse
     direction, searching for a match of the $\beta\delta_{\rm o}$ head-normal
     of \ec{(o p1 ... pn)} and then replacing all occurences of this head-normal
     form with \ec{(o p1 ... pn)}.
  \end{itemize}
  
  \smallskip
  
  The occurence selector \ec{\{i1 ... in\}} allows to restrict which occurences
  of the matching pattern are replaced in the goal. If given, only the
  \ec{i1}-th, ..., \ec{in}-th ones are replaced (considering that the goal is
  traversed in DFS mode). Note that this selection applies after the matching has
  been done.
  
  \medskip
  
  Repetition markers allow the repetition of the same rewriting. For instance,
  \tacname{} \ec{!rw} leads to \ec{do!} \tacname{} \ec{rw}. See \ec{do} for
  more information.
  
  \medskip

  Last, \tacname{} \ec{rw1 ... rwn} is equivalent to
  \tacname{} \ec{rw1}; ...; \tacname{} \ec{rwn}}

%elimT
\addAuto
{elim}
{$\!\!$/\tacarg{h}{ident} \tacarg{f}{pattern}}
{Apply the induction principle \vararg{h} on \vararg{x}}

%subst
\addAuto
{subst}
{\tacarg{x}{ident}?}
{Search for the first equation of the form \ec{x = f} or \ec{f = x} in the context
 and replace all the occurences of \ec{x} by \ec{f} everywhere in the context and the
 goal before clearing it. If no idents are given, repeatedly apply the tactic to
 all identifiers for which such an equation exists.}

%progress
\addAuto{progress}{}{Split all you hypothesis, make all subsitution possible and then split your goal and do it again on all subgoals. It
permits to easly break a big judgements in smaller one.}

%trivial
\addAuto{trivial}{}{If what remains in yout goal is very simple and not need an smt you can try using this tactic. TODO}

%idtac
\addOther
{idtac}
{\tacarg{x}{string}?}
{The identity tactic, leaving the goal unchanged and printing the string argument, if any.}
