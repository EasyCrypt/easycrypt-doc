% !TeX root = easycrypt.tex

\newcommand{\addAmbTacticNoIdx}[1]{\addTacticNoIdx{#1}}
\newcommand{\addAmbTacticIdx}[1]{\addTacticIdx{ambient}{#1}}
\newcommand{\addAmbTactic}[2]{\addTactic{ambient}{#1}{#2}}

\EasyCrypt's ambient logic is based on non-dependent higher-order logic.

\subsection{Convertibility}\label{convertible}

\EasyCrypt's ambient logic enjoys a mechanism that identifies all formulas
that are \define{convertible}, that is, formulas that are equal up to a given
amount of computations. The computational power of \EasyCrypt if defined
as the closure by equivalence of the following rewriting system augmented with
a set of logical simplification rules denoted by $\rightarrow_\Lambda$.

\begin{center}
\begin{tabular}{l@{$\quad$}l@{$\quad$}ll}
{\rawec{(lambda (x : t), phi1)\ phi2}} & $\rightarrow_\beta$ &
  \multicolumn{2}{@{}l}{{\rawec{phi2} \{\rawec{x} $\leftarrow$ \rawec{phi1}\}}}\\
{\rawec{if (true) \{ phi1 \} else \{ phi2 \}}} & $\rightarrow_\iota$ &
  {\rawec{phi1}}\\
{\rawec{if (false) \{ phi1 \} else \{ phi2 \}}} & $\rightarrow_\iota$ &
  \multicolumn{2}{@{}l}{{\rawec{phi2}}}\\
{\rawec{let (x1, ..., xn) = (phi1, ..., phin) in phi}} & $\rightarrow_\iota$ &
  \multicolumn{2}{@{}l}{{\rawec{phi} \{ \rawec{x1, ..., xn} $\leftarrow$ \rawec{phi1, ..., phin} \}}}\\
{\rawec{let x = phi1 in phi2}} & $\rightarrow_\zeta$ &
  \multicolumn{2}{@{}l}{{\rawec{phi2} \{ \rawec{x} $\leftarrow$ \rawec{phi1} \}}}\\
{\rawec{o}} & $\rightarrow_\delta^{\Env,\Gamma}$ &
  {\rawec{e}} & if {\rawec{op o := e}} $\in \Env$\\
{\rawec{x}} & $\rightarrow_\delta^{\Env,\Gamma}$ &
  {\rawec{phi}} & if {\rawec{x := phi}} $\in \Gamma$\\
\end{tabular}
\end{center}

We write $\rightarrow_\delta$ for $\rightarrow_\delta^{\Env;\Gamma}$ if
$\Env; \Gamma$ is clear from context. We write $\rightarrow_{\Env;\Gamma}$ for
the union of all the $\beta\iota\delta\zeta\Lambda$-rewrite rules. As usual,
$\leftrightarrow^*_{\Env;\Gamma}$ denotes the closure by equivalence of
$\rightarrow_{\Env;\Gamma}$.

%change
\addAmbTactic{change}{\tacarg{f}{formula}}
Change the current goal to the $\leftrightarrow^*$-equivalent one \ec{f}
\begin{displaymath}
  \infrule{\phi_1 \leftrightarrow^*_{\Env;\Gamma} \phi_2 \quad
           \Env; \Gamma \vdash \phi_1}
          {\Env; \Gamma \vdash \phi_2}
\end{displaymath}

%simplify
\addAmbTactic{simplify}{\tacarg{names}{ident*} | \ec{delta}?}
 \addAmbTacticIdx{beta}
 \addAmbTacticIdx{iota}
 \addAmbTacticIdx{zeta}
 \addAmbTacticIdx{logic}
 Change the goal with its $\beta\iota\zeta\Lambda$-head normal-form, followed
 by one step of parallel, strong $\delta$-reduction if \ec{delta} is given.
 The $\delta$-reduction can be restricted to a set of defined symbols by
 replacing \ec{delta} by a non-empty sequence of targeted symbols. You can
 selectively change the goal with its $\beta$-head normal form
 (resp. $\iota$, $\zeta$, $\Lambda$-head normal form) by using the tactic
 \ec{beta} (resp. \ec{iota}, \ec{zeta}, \ec{logic}).

%delta
\addAmbTactic{delta}{\tacarg{names}{ident*}}
Perform one step of parallel, strong $\delta$-reduction, restricted to
the symbols listed in \ec{names}. If \ec{names} is empty, all symbols are
$\delta$-reduced.

\subsection{Bookkeeping tactics}

The following bookkeeping tactics are used to move terms between context and
goal, and to introduce new variables from known expressions.

%generalize
\addAmbTactic{generalize}{\tacarg{p}{pattern}}
Search for the first subterm of the goal matching \ec{p} and leading
to the full instantiation of the pattern. Then, do a logical
generalization of all the instantiated occurrences of \ec{p}
in the goal.
\begin{displaymath}
  \infrule{\Env; \Gamma \vdash p \quad
           \Env; \Gamma \vdash \forall x, \phi(x)}
          {\Env; \Gamma \vdash \phi(p)}
\end{displaymath}

%pose
\addAmbTactic{pose}{\tacarg{x}{ident} \rawec{:=} \tacarg{p}{pattern}}
Search for the first subterm of the goal matching \ec{p} and leading
to the full instantiation of the pattern. Then introduce, after
instantiation, the local definition \rawec{x := p} and abstract
all instantiated occurrences of \ec{p} in the goal by \ec{x}.
\begin{displaymath}
  \infrule{\Env; \Gamma \vdash p \quad
           \Env; \Gamma, x := p \vdash \phi(x)}
          {\Env; \Gamma \vdash \phi(p)}
\end{displaymath}

%intros
\addAmbTactic{intros}{}
This is the identity tactic and should be used in combination with intro-patterns.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LOGIC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Logic}

%assumption
\addAmbTactic{assumption}{}
Search in the context an hypothesis convertible to the goal and close it.
 If no such hypothesis exists, the tactic fails
\begin{displaymath}
  \infrule{(h : \phi) \in \Gamma}{\Env; \Gamma \vdash \phi}
\end{displaymath}

%reflexivity
\addAmbTactic{reflexivity}{}
Solve goals of the form \ec{b = b} for any term \ec{b}.
\begin{displaymath}
  \infrule{ }{\Env; \Gamma \vdash b = b}
\end{displaymath}

%split
\addAmbTactic{split}{}
\tacname{} breaks a goal that is intrinsically conjunctive into multiple subgoals.
 For instance, it
 \begin{itemize}
  \item closes any goal that is convertible to \ec{true} or provable
        by \ec{reflexivity},

  \begin{displaymath}
  \infrule{\Env; \Gamma \vdash a \equiv true}{a}
  ~~~~~~
  \infrule{\Env; \Gamma \vdash a \equiv b}{a = b}
  \end{displaymath}
       
  \item replaces a logical equivalence by the direct and indirect implication,

  \begin{displaymath}
  \infrule{\Env; \Gamma \vdash \phi_1 \Rightarrow \phi_2 \quad
           \Env; \Gamma \vdash \phi_2 \Rightarrow \phi_1}
          {\Gamma \vdash \phi_1 \Leftrightarrow \phi_2}
  \end{displaymath}
  
  \item replaces a goal of the form \rawec{f1 /\\ f2} or \rawec{f1 \&\& f2} by the two
        subgoals for \ec{f1} and \ec{f2},

  \begin{displaymath}
  \infrule{\Env; \Gamma \vdash \phi_1 \quad
           \Env; \Gamma \vdash \phi_2}
          {\Env; \Gamma \vdash \phi_1 \land \phi_2}
  ~~~~~~
  \infrule{\Env; \Gamma \vdash \phi_1 \quad
           \Env; \Gamma \vdash \phi_2}
          {\Env; \Gamma \vdash \phi_1 \&\& \phi_2}
  \end{displaymath}
        
  \item replaces an equality between two $n$-tuples by the $n$ equalities of
        of the paired components.

  \begin{displaymath}
  \infrule{\Env; \Gamma \vdash a_1 = b_1  \quad \cdots \quad
           \Env; \Gamma \vdash a_n = b_n}
          {\Gamma \vdash (a_1, ..., a_n) = (b_1, ..., b_n)}
  \end{displaymath}
\end{itemize}

%left / right
\addAmbTacticNoIdx{left / right}{}
\addAmbTacticIdx{left}
\addAmbTacticIdx{right}
Reduce a disjunctive goal to its left (resp. right) part
\begin{displaymath}
  \infrule{\Env; \Gamma \vdash \phi_1}{\Env; \Gamma \vdash \phi_1 \lor \phi_2}
  ~~~~~~
  \infrule{\Env; \Gamma \vdash \phi_2}{\Env; \Gamma \vdash \phi_1 \lor \phi_2}
\end{displaymath}

%case
\addAmbTactic{case}{\tacarg{f}{formula}}
Do an excluded-middle case analysis on \ec{f}
\begin{displaymath}
  \infrule{\Env; \Gamma \vdash b \Rightarrow \phi(true) \quad
           \Env; \Gamma \vdash \neg b \Rightarrow \phi(false)}
          {\Env; \Gamma \vdash \phi(b)}
\end{displaymath}

%cut
\addAmbTactic{cut}{\tacarg{ip}{intro-pattern} : \tacarg{C}{formula}}
Logical cut. Generates two subgoals: on for $C$ (the cut formula),
 and one for $C \Rightarrow G$ where $G$ is the initial goal. Moreover,
 the intro-pattern \ec{ip} is applied to the second subgoal.
\begin{displaymath}
  \infrule{\Env; \Gamma \vdash \phi_1 \quad
           \Env; \Gamma, \vdash \phi_2 \Rightarrow \phi_1}
          {\Env; \Gamma \vdash \phi_1}
\end{displaymath}

%elim
\addAmbTactic{elim}{\tacarg{h}{ident}}
This tactics take as argument the name of a judgment from the environment or context.
\begin{displaymath}
  \infrule{\Gamma, h:A \land B \vdash A \Rightarrow B \Rightarrow G}{\Gamma, h:A \land B \vdash G}
  ~~~~~~
  \infrule{\Gamma, h:\exists x, A(x) \vdash \forall x, A(x) \rightarrow G}{\Gamma, h:\exists x, A \vdash G}
\end{displaymath}\\
\begin{displaymath}
  \infrule{\Gamma, h:(a_1, ..., a_n) = (b_1, ..., b_n) \vdash a_1 = b_1 \Rightarrow ... \Rightarrow a_n = b_n \Rightarrow G}{\Gamma, h:(a_1, ..., a_n) = (b_1, ..., b_n) \vdash G}
\end{displaymath}

%elimT
\addAmbTacticNoIdx{elim}{$\!\!$/\tacarg{h}{ident} \tacarg{f}{pattern}}
\addAmbTacticIdx{elimT}
Apply the induction principle \vararg{h} on \vararg{x}

%apply
\addAmbTactic{apply}{\tacarg{p}{proof-term}}
Modus Ponens. If \ec{p} is a proof-term for the pattern (formula) for
  \begin{center}
    \ec{forall (x1 : t1) ... (xn : tn), A1 -> ... -> An -> B}
  \end{center}
  \noindent then \tacname{} tries to match B with the current G. If the
  match succeeds and leads to the full instantiation of the pattern,
  then the goal is replaced, after instantiation, with the $n$ subgoals
  \ec{A1, ..., An}

%rewrite
\addAmbTactic{rewrite}{rw1 ... rw${}_n$ where the rw${}_i$ are of the form \ec{//},
\ec{/=}, \ec{//=}, a proof-term or a pattern prefixed by \ec{/}
(slash). The two last forms can be prefixed by a direction indicator (the sign
\ec{-}), followed by an occurrence selector (\ec{\{i1 ... in\}}),
followed by repetition marker (\ec{!}, \ec{?}, \ec{i!} or \ec{i?}). All
these prefixes are optional.}
Depending on the form of \ec{rw}, \tacname{} \ec{rw} does the following:
  \begin{itemize}
   \item For \ec{//}, \ec{/=}, and \ec{//=}, see \ec{intros}.
   \item If \ec{rw} is a proof-term for the pattern (formula)
     \begin{center}
      \ec{forall (x1 : t1) ... (xn : tn), A1 -> ... -> An -> f1 = f2}
     \end{center}
     \noindent then \tacname{} searches for the first subterm of the goal
     matching \ec{f1} and resulting in the full instantiation of the pattern.
     It then replaces, after instantiation of the pattern, all the occurrences
     of \ec{f1} by \ec{f2} in the goal, and creates $n$ new subgoals for the
     \ec{Ai}'s. If no subterms of the goal match \ec{f1} or if the pattern
     cannot be fully instantiated by matching, the tactic fails.
     The tactic works the same if the pattern ends by \ec{f1 <-> f2}. If the
     direction indicator \ec{-} is given, \tacname{} works in the reverse
     direction, searching for a match of \ec{f2} and then replacing all
     occurrences of \ec{f2} by \ec{f1}.
   \item If \ec{rw} is a \ec{/}-prefixed pattern of the form \ec{(o p1 ... pn)},
     with \ec{o} a defined symbol, then \tacname{} searches for the first subterm
     of the goal matching \ec{(o p1 ... pn)} and resulting in the full instantiation
     of the pattern. It then replaces, after instantiation of the pattern, all
     the occurrences of \ec{(o p1 ... pn)} by the $\beta\delta$ head-normal form
     of \ec{(o p1 ... pn)}, where the $\delta$-reduction are restricted to the one
     headed by the symbol \ec{o}. If no subterms of the goal match \ec{(o p1 ... pn)} or
     if the pattern cannot be fully instantiated by matching, the tactic fails. If the
     direction indicator \ec{-} is given, \tacname{} works in the reverse
     direction, searching for a match of the $\beta\delta_{\rm o}$ head-normal
     of \ec{(o p1 ... pn)} and then replacing all occurrences of this head-normal
     form with \ec{(o p1 ... pn)}.
  \end{itemize}
  
  \smallskip
  
  The occurrence selector \ec{\{i1 ... in\}} allows to restrict which occurrences
  of the matching pattern are replaced in the goal. If given, only the
  \ec{i1}-th, ..., \ec{in}-th ones are replaced (considering that the goal is
  traversed in DFS mode). Note that this selection applies after the matching has
  been done.
  
  \medskip
  
  Repetition markers allow the repetition of the same rewriting. For instance,
  \tacname{} \ec{!rw} leads to \ec{do!} \tacname{} \ec{rw}. See \ec{do} for
  more information.
  
  \medskip

  Last, \tacname{} \ec{rw1 ... rwn} is equivalent to
  \tacname{} \ec{rw1}; ...; \tacname{} \ec{rwn}
  
%subst
\addAmbTactic{subst}{\tacarg{x}{ident}?}
Search for the first equation of the form \ec{x = f} or \ec{f = x} in the context
 and replace all the occurrences of \ec{x} by \ec{f} everywhere in the context and the
 goal before clearing it. If no idents are given, repeatedly apply the tactic to
 all identifiers for which such an equation exists.

%congr
\addAmbTactic{congr}{}
This tactic applies to a goal of the form \ec{f t1 ... tn = f u1 ... un}
 replacing it by  the subgoals \ec{ti = ui} for all \ec{i}. Note that subgoals
 solvable by \ec{reflexivity} are automatically closed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% AUTO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Automation}

%smt
\addAmbTactic{smt}{[\ec{nolocal}]}
Try to solve the goal using SMT solvers. The goal is sent along with all the
 lemmas proved so far plus the local hypotheses, unless the \ec{nolocal} is
 given.
 
 \noindent\begin{center}
 \warningbox{Not all lemmas can be sent translated in such a way that they can
  be sent to the SMT provers. For instance, any formulas involving pRHL
  constructions are ignored.}
 \end{center}

%progress
\addAmbTactic{progress}{\ec{tactic}?}
Break the goal into multiple \emph{simpler} ones by repeatedly applying
\ec{split}, \ec{subst} and \ec{intros}. If a tactic is given to \tacname{},
it is tentatively applied after each step.

\warningbox{The optional parameter to \tacname{} may cause
performance issues (with \ec{smt}, in particular). It is recommended
to avoid using it.}

%trivial
\addAmbTactic{trivial}{}
Try to solve the goal by calling \ec{try assumption; progress; assumption}.
This tactic is called by the intro-pattern \ec{//}.
