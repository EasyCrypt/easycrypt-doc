Security properties are expressed in terms of probability of events,
rather than as pRHL judgments. Pleasingly, one can derive inequalities
(resp. equality) about probability quantities from valid judgments. In
particular, assume that the postcondition $\post$ implies $A\sidel
\Rightarrow B\sider$. Then for any programs $c_1$, $c_2$ and
precondition $\pre$ such that $\Equiv{c_1}{c_2}{\pre}{\post}$ is valid
and for any initial memories $m_1$, $m_2$ satisfying the precondition
$\pre$, we have
$$\Prm{c_1}{A}{m_1} \leq \Prm{c_2}{B}{m_2}$$
Up to now, \easycrypt assume that the two games start in the same initial
memory (i.e. $m_1 = m_2$), thus the equality of initial memories should
imply the validity of the precondition.

\section{Claims using equiv}

The natural way to obtain new claims is to deduce it from a pRHL judgment.
Assume we have proved a pRHL judgment of the form: 
\begin{verbatim}
equiv Fact1 : Game1.Main ~ Game2.Main : true ==> ={res}.
\end{verbatim} 
Then we can deduce:
\begin{verbatim}
claim c1 : Game1.Main[res] = Game2.Main[res] using Fact1.
\end{verbatim}
\easycrypt will check that the equality of the initial memories implies
the validity of the precondition (here \verb+true+) and that the
postcondition implies the logical equivalence of the two events 
(here \verb+ ={res} => (res{1} <=> res{2})+).

pRHL judgments also allow proving inequality relations between probability
expressions.  Assume we have proved a pRHL judgment of the form:
\begin{verbatim}
equiv Fact2 : Game1.Main ~ Game2.Main : 
    true ==> ={res} && (bad{1} => bad{2}).
\end{verbatim} 
Then we can deduce:
\begin{verbatim}
claim c2 : Game1.Main[res] = Game2.Main[res] using Fact2.
\end{verbatim}
but also:
\begin{verbatim}
claim c3 : Game1.Main[res && bad] <= Game2.Main[bad] using Fact2.
\end{verbatim}
For the last claim, \EasyCrypt checks that the postcondition of 
the pRHL judgment (\verb+={res} && (bad{1} => bad{2})+)
and the event associated to the first game (\verb+res{1} && bad{1}+)
imply the event associated to the second game (\verb+bad{2}+).

There is a third kind of claim which can be deduced from a pRHL judgment.
This kind of judgment is closely related to the fundamental lemma 
(also named difference lemma).
\paragraph{Fundamental lemma}{\it Let $F_1$ and $F_2$ be to distribution,
 and $A_1, A_2, B_1, B_2$ some events. Assume that
 \begin{itemize}
    \item $\Pr{F_1}{B_1} = \Pr{F_2}{B_2} $
    \item $\Pr{F_1}{A_1 \land \neg B_1} = \Pr{F_2}{A_2 \land \neg B_2}$
 \end{itemize}
then we have 
  $$ | \Pr{F_1}{B_1} - \Pr{F_2}{B_2} | \leq \Pr{F_i}{B_i}$$}

Now assume we have proved a specification of the form:
\begin{verbatim}
equiv Fact3 : Game1.Main ~ Game2.Main : 
    true ==> B1{1} <=> B2{2} && (!B1{1} => A1{1} <=> A2{2}).
\end{verbatim}
Then we can derive the following claims:
\begin{verbatim}
claim c4_1 : Game1.Main[B1] = Game2.Main[B2]
using Fact3.
claim c4_2 : Game1.Main[!B1 && A1] = Game2.Main[!B2 && A2]
using Fact3.
\end{verbatim}
So the two hypotheses of the fundamental lemma are satisfied. 
\EasyCrypt allows deriving directly the conclusion of the fundamental
lemma from \verb+Fact3+:
\begin{verbatim}
claim c4 : |Game1.Main[A1] - Game2.Main[A2] | <= Game2.Main[B2] 
using Fact3.
\end{verbatim} 
For this kind of claim, \EasyCrypt checks that the postcondition of
the pRHL judgment implies the equivalence of the bad events 
(here \verb+B1+ and \verb+B2+) in the two games. 
Furthermore if the postcondition is valid and the bad event (here \verb+B2+) 
is not set then the two events 
(here \verb+A1{1}+ and \verb+A2{2}+) should be equivalent.



\section{Claim using same and split}

There is some particular case of claim which can be deduced 
automatically without using pRHL judgments.
More precisely, the judgment $\Equiv{c}{c}{=}{=}$ is always valid 
(where $=$ means the equality of the memories).
Thus, we can derive some simple properties from it.
\begin{verbatim}
claim c_1 : G1.Main[res && (b || !b)] = G1.Main[res] 
same.
claim c_2 : G1.Main[res && b ] <= G1.Main[res]
same.
\end{verbatim}
Claim defined using \verb+same+ argument should relates the probability
of two events $A_1$ and $A_2$ in the same game.
If the comparison operator is the equality then we should have 
$A_1 \Leftrightarrow A_2$ (as in the claim \verb+c_1+).
If the comparison operator is the less or equal operator 
then we should have $A_1 \Rightarrow A_2$ (as in the claim \verb+c_2+).

Another way to simply derive claim is to use the \verb+split+ argument.
\begin{verbatim}
claim c_3 : G1.Main[res] = G1.Main[res && bad] + G1.Main[res && !bad]
split.
\end{verbatim}
If the comparison operator is the equality the claim should match the
generic form \verb?G.F[A] <= G.F[A&&B] + G.F[A&&!B]?.
If the comparison operator is the less or equal operator then
the claim should have the generic form \verb?G.F[A] <= G.F[B] + G.F[C]?.
Furthermore \easycrypt check that $A \Rightarrow (B \lor C)$.

An exemple of use of the \verb+split+ and \verb+same+ is the proof of the
fundamental lemma, assume we have proved the specification:
\begin{verbatim}
equiv Fact3 : Game1.Main ~ Game2.Main : 
    true ==> B1{1} <=> B2{2} && (!B1{1} => A1{1} <=> A2{2}).
\end{verbatim}
Then we can derive the following claims:
\begin{verbatim}
claim c4_1 : Game1.Main[B1] = Game2.Main[B2]
using Fact3.
claim c4_2 : Game1.Main[!B1 && A1] = Game2.Main[!B2 && A2]
using Fact3.
\end{verbatim}
but also:
\begin{verbatim}
claim c4_split1 : Game1.Main[A1] = Game1.Main[B1 && A1] + Game1.Main[!B1 && A1]
split.
claim c4_split2 : Game2.Main[A2] = Game2.Main[B2 && A2] + Game2.Main[!B2 && A2]
split.
claim c4_same1 : Game1.Main[B1 && A1] <= Game1.Main[A1]
same.
claim c4_same2 : Game2.Main[B2 && A2] <= Game1.Main[A2]
same. 
\end{verbatim}
Using the claims \verb+c4_1+, \verb+c4_2+, \verb+c4_split1+, \verb+c4_split2+,
\verb+c4_same1+, \verb+c4_same2+ the automatic provers (like \verb+alt-ergo+)
are able to derive the following claim:
\begin{verbatim}
claim c4 : |Game1.Main[A1] - Game2.Main[A2] | <= Game2.Main[B2].
\end{verbatim}





\section{Deducing claim from other claims}
Claim can be derived as a consequence of other claims.
When no argument is given after the statement of the claim \easycrypt
try to prove it using the previously proved claims.

Assume we have already proved the following claims:
\begin{verbatim}
claim c_1 : G1.Main[res] = G2.Main[res].
claim c_2 : | G2.Main[res] - G3.Main[res] | <= G3.Main[bad].
claim c_3 : G3.Main[res] = 1%r/2%r.
claim c_4 : G3.Main[bad] <= 1%r/(2^n)%r.
\end{verbatim}
Then the following claim is automatically deduced from the previous one:
\begin{verbatim}
claim c_5 : | G1.Main[res] - 1%r/2%r | <= 1%r/(2^n)%r.
\end{verbatim}

\section{Claims by compute}

During a reduction proof, we sometime need to compute or to bound
the probability of an event in a given game. This can be done using
the \verb+compute+ argument. Assume we have the following game:
\begin{verbatim}
game G = { 
   ...
   fun Main() : bool = {
     (pk,sk) = KG();
     (m0,m1) = A_1(pk);
     c       = {0,1}^k;
     b'      = A_2(c);
     b       = {0,1};
     return b = b';
  }
} 
\end{verbatim}
Then \easycrypt is able to compute the probability of \verb+res=true+
in the function \verb+G.Main+:
\begin{verbatim}
claim c : G.Main[res] = 1%r/2%r 
compute.
\end{verbatim} 

The \verb+compute+ argument is also able to prove the claim that can be
derive using \verb+split+ and \verb+same+, but it is less efficient.
On the other side it is also more powerful, for example we can prove:
\begin{verbatim}
claim c : G.Main[A || B || C] <= G.Main[A] + G.Main[B] + G.Main[C]
compute.  
\end{verbatim}
This claim can also be obtained using the \verb+split+ argument, using
the following sequence:
\begin{verbatim}
claim c_1 :  G.Main[A || B || C] <= G.Main[A || B] + G.Main[C]
split.
claim c_2 :  G.Main[A || B] <= G.Main[A] + G.Main[B]
split.
claim c : G.Main[A || B || C] <= G.Main[A] + G.Main[B] + G.Main[C]. 
\end{verbatim}
The claim \verb+c+ is a direct consequence of the claims \verb+c_1+ and 
\verb+c_2+.

A last example of use for \verb+compute+ is the following, assume
we have a game of the form:
\begin{verbatim}
game G = { 
   ...
   fun Main () : bool = {
     x = init();
     d = A(x);
     z = {0,1}^k;
     return d;
   }
}     
\end{verbatim}
Then \verb+compute+ is able to prove the following claim:
\begin{verbatim}
claim c :
  G.Main[res && mem(z,L) && length(L) <= q] <= q%r/(2^k)%r * G.Main[res]
compute.
\end{verbatim}

Sometime the event we want to bound is not set in the main function
but in an oracle, furthermore we known that the oracle can be call at
most $q$ time. Assume that the probability that the event is set during
one call to the oracle is bounded by $u$, we would like to conclude 
that the probability event is set in the main function is bounded by
$u*q$. This is possible using the failure event lemma.
\begin{verbatim}
game G = {
  var C: int
  var bad : bool
  fun O(x:int) : bitstring{k} = {
    var r = {0,1}^k;
    C = C + 1;
    if (r = 0) bad = true;
    return r;
  }
  abs A = A {O}
  fun Main() : bool = {
    var d : bool;
    C = 0;
    bad = false;
    d = A();
    return d;
  }    
\end{verbatim}
In the example the probability that \verb+bad+ is set in during a
call to the oracle \verb+O+ is $1/2^k$, furthermore the counter \verb+C+
count the number of call to \verb+O+.
We can use the following to bound the probability of \verb+bad+ in the main:
\begin{verbatim} 
claim pr_bad : G.Main[bad && C <= q] <= q%r * (1%r/(2^k)%r)
compute 2 (bad), (C).
\end{verbatim}

The second argument indicate the bad event (of the oracle) 
we consider and the third should be a expression representing the counter. 
The first argument is an integer indicating the number of instructions
in the main needed to initialize the failure event lemma. 
After those instructions the value associated to the counter should be 0
and the bad event should evaluate to false.
Then \easycrypt should be able to prove that the probability that the bad
event is set during an oracle call is bounded by $1/2^k$. Furthermore,
if the bad event is set during a call to the oracle then the counter
increase, and do not decrease in the other case, and that the bad event
is never reset.

\section{Claims by admit}
The last possibility to define a claim is to use the admit argument.
\begin{verbatim}
claim c : G.Main[res] = G'.Main[res] 
admit.
\end{verbatim}
It that case the validity of the claim is admitted without any check.

\section{Claims by auto}

It is also possible to directly define claim which normally should be 
defined using an \textit{equiv} specification directly:
\begin{verbatim}
claim c12 : G1.Main[res] = G2.Main[res]
auto.
\end{verbatim}
This is a shortcut for: 
\begin{verbatim}
equiv c12_aux : G1.Main ~ G2.Main : true ==> ={res}
by auto.
claim c12 : G1.Main[res] = G2.Main[res]
using c12_aux.
\end{verbatim}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "easycrypt"
%%% End: 
