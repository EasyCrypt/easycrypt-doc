% !TeX root = easycrypt.tex

%% TODO (Francois): For index, rather than \texttt, use \rawec and make a class of keywords for tactics and tacticals

\chapter{Writing Proofs\label{chap:tactics}}

\EasyCrypt comes with a proof engine that allows to state, in the \EasyCrypt
underneath formalism, properties about the user defined programs
and to prove them.
%
Proofs are built interactively, starting from final goal, by applying
\emph{tactics} that transform a goal (the property we want to prove)
to a set of subsequent goals (the subgoals) s.t. the latter logical
implies the former.
%
This process is repeated iteratively up to the point where all the
subgoals are trivial and can be solved by the system.

This chapter is about the description of this proof engine, and is
structured as follow. We first define the notion of goals and show
how it relates to the \EasyCrypt formalism. We then introduce the notion
of tactics as logically valid goal transformers. Finally, a listing
of all the existing tactics, along with their detailed descriptions,
is given.

\section{The proof engine}

The proof engine deals with \emph{judgments} or \emph{goals} of the form
$\Env; \Gamma \vdash \phi$ where $\Env$ is the (global) environments,
$\Gamma$ is a set of local facts and $\phi$ is the formula we want
to prove. Here is an example of such a judgment:

\begin{center}
$\Int; x, y , z: \tint, x \le y \vdash x + z \le y + z$.
\end{center}

It states that in the \emph{environment} ($\Env$) solely composed of the
theory $\Int$, having three local variables $x, y, z$ of type $\tint$ along
with the fact $x \le y$ (the \emph{context} $\Gamma$), we are interested
in proving $x + z \le y + z$.

\medskip

On top on this, a set of \emph{deduction rules} is given. They
describe how one can derive a judgment $\Env; \Gamma \vdash \phi$ given
that a set of prerequisites (or \emph{premises}) are fulfilled. The general
form of such a rule is given as follow:

\begin{displaymath}
 \infrule{A_1 \cdots A_n}{\Env; \Gamma \vdash \phi}
\end{displaymath}

It has to be read as: \emph{given that $A_1 \cdots A_n$ are derivable, then
so is $\Env, \Gamma \vdash \phi$}. We give three examples of such deduction
rules:

\begin{displaymath}
 \infrule
         {\Env; \Gamma \vdash \phi_1 \quad
          \Env; \Gamma \vdash \phi_1 \Rightarrow \phi_2}
         {\Env; \Gamma \vdash \phi_2}
         {\rname{MP}}
 \quad\quad
 \infrule
         {\Env; \Gamma, \phi_1 \vdash \phi_2}
         {\Env; \Gamma \vdash \phi_1 \Rightarrow \phi_2}
         {\rname{$\Rightarrow$-I}}
 \quad\quad
 \infrule{ }{\Env; \Gamma, \phi, \Delta \vdash \phi}{\rname{Ax}}
\end{displaymath}

The first, the \emph{modus ponens}, states that one can derive
$\Env; \Gamma \vdash \phi_2$ given that $\Env; \Gamma \vdash \phi_1
\Rightarrow \phi_2$ and $\Env; \Gamma \vdash \phi_1$ are derivable.
%
The next provides a way for deriving $\phi_1 \Rightarrow \phi_2$ from
a derivation of $\phi_2$, but with a context augmented by $\phi_1$.
%
The last states that $\Env; \Gamma, \phi, \Delta \vdash \phi$ is derivable as-is.

\medskip

Combining these deduction rules, it is possible to build a tree rooted by
a judgment $\Env; \Gamma \vdash \phi$ and with leaves composed of deduction
rules with no premises (as the third one in the previous example). Such a
tree forms a \emph{proof} of $\Env; \Gamma \vdash \phi$.
%
For instance, Figure~\ref{fig:LJproof} gives a proof of
%
\begin{center}
 $\Env; b_1, b_2 : \tbool \vdash (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2$
\end{center}

\begin{figure}
  \begin{displaymath}
    \infrule
      {\infrule{ }{\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_1 \Rightarrow b_2} \quad
       \infrule{ }{\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_1}}
      {\infrule
        {\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_2}
        {\infrule
           {\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2 \vdash b_1 \Rightarrow b_2}
           {\Env; b_1, b_2 : \tbool \vdash (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2}}}
  \end{displaymath}

  \caption{\label{fig:LJproof} Proof tree of
    $\Env; b_1, b_2 : \tbool \vdash
        (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2$}
\end{figure}

\bigskip

The \EasyCrypt proof engine helps the user building such proof. At each step
of the proof building, the system presents to the user the set of goals
that has to be proved. The user can then \emph{apply} a tactic to one of
them, each tactic corresponding to a deduction rule. If the conclusion
of the rule corresponding to the applied tactic matches the goal to witch
it is applied, the proof engine replaces it with the set of the
premises of the applied rule - the subgoals. This application may generate
no, one or several subgoals depending on the rule. This process is repeated
iteratively, up to the point where no goals remain.

\section{Tacticals}

\input{tacticals}

\section{Ambient Logic}

\input{ambient}

\section{Program Logics Tactics}

\subsection{Empty statements: the \rawec{skip} tactic}
\index{pL}{\rawec{skip}}

\Syntax \rawec{skip}

\Description Reduces logical program judgements with empty statements
to a first-order logical goal, as in the following rules:
%
\begin{displaymath}
\begin{array}{ccc}
\infrule{
  \pre \Rightarrow \post
}{
  \Hoare{\Skip}{\pre}{\post}
}
\qquad
\infrule{
  \pre \Rightarrow \post \qquad \bound = 1
}{
  \HoareLe{\Skip}{\pre}{\post}{\bound}
}
\qquad
\infrule{
  \pre \Rightarrow \post
}{
  \Equiv{\Skip}{\Skip}{\pre}{\post}
}
\end{array}
\end{displaymath}
%

\subsection{Random samplings: the \rawec{rnd} tactic}
\index{pL}{\rawec{rnd}}

\subsubsection{Hoare Logic}

\Description

The application of this tactic expects a goal of the form:
\begin{displaymath}
  \Hoare{c;\Rand{x}{d}}{\pre}{\post}
\end{displaymath}
where $d$ is of type \rawec{'a Distr.distr} for some type \rawec{'a}.

Invocations to this tactic expect no arguments and applies the
following rule:
\begin{displaymath}
\infrule{
  \Hoare{c}{\pre}{\forall z,\insupp{z}{d} \Rightarrow \post\subst{x}{z}}
}{
  \Hoare{c;\Rand{x}{d}}{\pre}{\post}
}
\end{displaymath}
where $\insupp{z}{d}$ stands for the predicate $\ECinsupp{z}{d}$.

\subsubsection{Probabilistic Hoare Logic}
\index{phl}{Program Reasoning!rnd@\rawec{rnd}}
\Syntax 
\rawec{rnd} [\textit{formula} | \textit{formula} \textit{formula}
\textit{formula} \textit{formula} \textit{formula} \textit{formula} ] 

\Description

The invocation of this tactic expects a goal of any of the following
forms:
\begin{itemize}
\item $\HoareLe{\pre}{c;\Rand{x}{d}}{\post}{\bound}$
\item $\HoareEq{\pre}{c;\Rand{x}{d}}{\post}{\bound}$
\item $\HoareGe{\pre}{c;\Rand{x}{d}}{\post}{\bound}$
\end{itemize}

The following rule, corresponding to the invocation of
$
\left[\mbox{\rawec{rnd}}\ \varphi\ \bound_1\ \bound_2\ \bound_3\ \bound_4\ p\right],
$
describes the most general variant implemented by
the \rawec{rnd} tactic for probabilistic Hoare judgements:
%
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \bound_1 \bound_2 + \bound_3 \bound_4 \leq \bound \\
    \HoareLe{c}{\pre}{\varphi}{\bound_1} \\
    \varphi \Rightarrow \mu\, d\, p \leq \bound_2 \land (\forall v,~\insupp{v}{d}\Rightarrow
    \post\subst{x}{v} \Rightarrow p\, v) \\
    \HoareLe{c}{\pre}{\neg \varphi}{\bound_3} \\
    \neg\varphi \Rightarrow \mu\, d\, p \leq \bound_4 \land (\forall v,~\insupp{v}{d}\Rightarrow
    \post\subst{x}{v} \Rightarrow p\, v) \\
  \end{array}
}{
  \HoareLe{c;\Rand{x}{d}}{\pre}{\post}{\bound}
}
\end{displaymath}
%
where $\insupp{z}{d}$ stands for the predicate $\ECinsupp{z}{d}$.
%
Similar rules hold by substituting every occurrence of the
comparison operator $\leq$ by the operator $=$, or by the operator $\geq$.

If a single parameter is given, then the \rawec{rnd} tactic implements
the following simpler rules:
\begin{displaymath}
  \infrule{
    \Hoare{c}{\pre}{\mu\, d\, p \leq f \land 
      (\forall v,~\insupp{v}{d}\Rightarrow \post\subst{x}{v} \Rightarrow p\, v)}
  }{
    \HoareLe{c;\Rand{x}{d}}{\pre}{\post}{f}
  }\left[\mathec{rnd}\ p\right]
\end{displaymath}
%
\begin{displaymath}
  \infrule{
    \HoareEq{c}{\pre}{\mu\, d\, p \geq \delta \land 
      (\forall v,~\insupp{v}{d} \Rightarrow p\, v \Rightarrow \post\subst{x}{v} )}{1} 
  }{
    \HoareGe{c;\Rand{x}{d}}{\pre}{\post}{\delta}
  }\left[\mathec{rnd}\ p\right]
\end{displaymath}
%
\begin{displaymath}
  \infrule{
    \HoareEq{c}{\pre}{\mu\, d\, p = \delta \land 
      \forall v,~ (\insupp{v}{d} \Rightarrow (p\, v \Leftrightarrow \post\subst{x}{v} ))}{1} 
  }{
    \HoareEq{c;\Rand{x}{d}}{\pre}{\post}{\delta}
  }\left[\mathec{rnd}\ p\right]
\end{displaymath}

If the \rawec{rnd} tactic is invoked with no parameters, and the
assigned variable does not occur in the postcondition, then the
following rule variants are applied:
%
\begin{displaymath}
  \infrule{
    \HoareLe{c}{\pre}{\post}{\bound}
  }{
    \HoareLe{c;\Rand{x}{d}}{\pre}{\post}{\bound}
  }\left[\mathec{rnd}\ p\right]
\end{displaymath}
%
\begin{displaymath}
  \infrule{
    \HoareEq{c}{\pre}{\post}{\bound} \qquad
    \mu\, d\, {true} = 1
  }{
    \HoareEq{c;\Rand{x}{d}}{\pre}{\post}{\delta}
  }\left[\mathec{rnd}\ p\right]
\end{displaymath}
%
\begin{displaymath}
  \infrule{
    \HoareGe{c}{\pre}{\post}{\bound} \qquad
    \mu\, d\, {true} = 1
  }{
    \HoareGe{c;\Rand{x}{d}}{\pre}{\post}{\bound}
  }\left[\mathec{rnd}\ p\right]
\end{displaymath}


\warningbox{Not yet implemented.}

If the judgement bound expression contains variables that are modified
by the judgement statement, then the same rules are applied after a
renaming of the bound expression enabled by the following equivalence: 
\begin{displaymath}
  \HoareLe{c;\Rand{x}{d}}{\pre}{\post}{\bound}
  \Longleftrightarrow
  \forall \bound', \HoareLe{c;\Rand{x}{d}}{\pre \land \bound=\bound'}{\post}{\bound'}
\end{displaymath}



% the first optional parameter $p$ is a computable predicate (i.e., \verb+'a cPred+)
% (i.e., \verb+'a -> bool+ ). Assume $d$ of type \verb+A Distr.distr+. 
% \begin{displaymath}
% \begin{array}{c}
%   \infrule{
%     \Hoare{c}{\pre}{\mu\, d\, p \leq f \land 
%       (\forall v\in \mathsf{support}(d).~ \post\subst{x}{v} \Rightarrow p\, v)}
%   }{
%     \HoareLe{c;\Rand{x}{d}}{\pre}{\post}{f}
%   }\left[\verb+rnd+\ p\right]
% \\[4ex]
% \end{array}
% \end{displaymath}
% If $p$ is not given then the tool attempts to build it from $\post$
% (not implemented yet).

% For lower-bounded and exact probabilistic judgments the tactic
% additionally accepts an optional parameter $g$ of type \verb+real+
% representing a bound:
% \begin{displaymath}
%   \infrule{
%     \HoareGe{c}{\pre}{\mu\, d\, p \geq g \land 
%       (\forall v\in \mathsf{support}(d).~ p\, v \Rightarrow \post\subst{x}{v} )}{\frac{f}{g}} 
%   }{
%     \HoareGe{c;\Rand{x}{d}}{\pre}{\post}{f}
%   }\left[\verb+rnd+\ p\ g\right]
% \end{displaymath}
% %
% \begin{displaymath}
%   \infrule{
%     \HoareEq{c}{\pre}{\mu\, d\, p = g \land 
%       (\forall v\in \mathsf{support}(d).~ p\, v \Leftrightarrow \post\subst{x}{v} )}{\frac{f}{g}} 
%   }{
%     \HoareEq{c;\Rand{x}{d}}{\pre}{\post}{f}
%   }\left[\verb+rnd+\ p\ g\right]
% \end{displaymath}
% %
% If $g$ is not given then $g=f$ in the rule.

\subsubsection{Relational Hoare Logic}

\Syntax \rawec{rnd}[\textit{side}] [\textit{form} | \textit{form} \textit{form}]

\Description

The logical rule implemented by the \rawec{rnd} tactic depends on the
the optional parameter \textit{side}. If a left/right side flag is
provided then the one-sided logical rule for random sampling is
applied. If missing, then the two-sided rule for random assignment is
considered.
%

\paragraph*{Two-sided application.} 
When no side flag is provided, then the \rawec{rnd} tactic takes as
parameter a representation of a bijective function.

When two formulae are provided as the bijection parameter,
they are verified to be bijective functions and inverse of each
other. If only one function is provided then this function is verified
to be an involution, and lastly if no argument is given then the
identity function is considered.

The description of the rule below assumes that a bijective function
$f$ and its inverse is provided and generates according verification
conditions. Furthermore, it requires the following type constraints
for some types \rawec{'a} and \rawec{'b}: 
\begin{itemize}
\item $d_1$ \rawec{: 'a Distr.distr}, 
\item $d_2$ \rawec{: 'b Distr.distr}
\item $f$ \rawec{: 'a} $\to$ \rawec{'b},
\item $f^{-1}$ \rawec{: 'b} $\to$ \rawec{'a}, 
\end{itemize}

\begin{displaymath}
\infrule{
  \Equiv{c_1}{c_2}{\pre} 
  { % \begin{array}{l}
      \forall z\,v,\insupp{z}{d_1}\Rightarrow
      \insupp{v}{d_2}\Rightarrow \mathsf{bij}\,f\,f^{-1}
       \land
      \post\subst{x}{z}\subst{y}{f\,z}
    % \end{array}
  }
}{
  \Equiv{c_1;\Rand{x}{d_1}}{c_2;\Rand{y}{d_2}}{\pre}{\post}
}
\end{displaymath}
where
$\mathsf{bij}\,f\,f^{-1}$ stands for
\begin{displaymath}
  \mu\,d_1\,\charfun_{\{z\}}=\mu\,d_2\,\charfun_{\{f\,z\}} 
  \land \insupp{(f^{-1}\,v)} {d_1} \land
  f^{-1}\,(f\,z)=z \land f\,(f^{-1}\,v)=v
\end{displaymath}
    

\paragraph*{One-sided application.} 
If the \emph{side} optional argument is provided, then the \rawec{rnd}
tactic implements the following rule:
%
\begin{displaymath}
\infrule{
  \Equiv{c}{c'}{\pre}{\forall z,\insupp{z}{d} \Rightarrow \post\subst{x}{z}}
}{
  \Equiv{c;\Rand{x}{d}}{c'}{\pre}{\post}
}\left[\mathec{rnd}\{1\}\right]
\end{displaymath}
%
A similar rule holds for an invocation to $\left[\mathec{rnd}\{2\}\right]$.

\subsection{Sequential composition: the \rawec{seq} tactic}
\index{pL}{\rawec{seq}}
%
\subsubsection{Hoare Logic}

\Syntax 
\rawec{seq} \textit{codepos} \textit{formula} 

\Description

\Description
Applies the Hoare Logic rule for sequential composition:
$$
\infrule{\Hoare{c}{\post}{\post'} \quad
         \Hoare{c'}{\post'}{\post''}}
        {\Hoare{c;c'}{\post}{\post''}}
$$
The application of tactic $\mathec{seq}\ k\ p$ defines $c$ as the first
$k$ instructions of the statement $c;c'$ and $\post'$ as
$p$.


\subsubsection{Probabilistic Hoare Logic}
\Syntax 
\rawec{seq}  \textit{codepos} \textit{formula}
[\textit{formula} | \textit{formula} \textit{formula}
\textit{formula} \textit{formula}]

\Description

\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \Hoare{s1}{P}{\varphi}
      \\
      \HoareLe{s1}{P}{\chi}{f_1} \qquad 
          \HoareLe{s2}{\varphi \land \chi }{Q}{f_2}
      \\
      \HoareLe{s1}{P}{\neg \chi}{f_3} \qquad 
             \HoareLe{s2}{\varphi \land \neg\chi}{Q}{f_4}
      \\
      f_1 f_2 + f_3 f_4 \leq f 
    \end{array}
  }{
    \HoareLe{s1;s2}{P}{Q}{f}
  }\left[\mathec{seq}\ \varphi\ \chi\ f_1\ f_2\ f_3\ f_4 \right]
\end{displaymath}

(idem with ($=$) and ($\geq$)).

% The application of the \verb+seq+ tactic is more complicated when
% dealing with Probabilistic Hoare Logic judgements. 

% The direction parameter is accepted for \emph{lower-bounded} and \emph{exact}
% judgments. The direction \verb+<<+ is assumed by default (as it is globally).
% The first formula represents the intermediate predicate that must hold
% at the splitting program point.

% In the following, the rule descriptions assume that $n$ indicates the
% program position of statement $s_2$.

% \warningbox{The functionality described below is currently disabled}

% \paragraph*{Upper bounded judgements.}
% For upper bounded judgments, the most general variant of the
% \verb+seq+ rule (i.e., when four bounds are given as parameters) implements the following rule:
% \begin{displaymath}
%   \infrule{
%     \begin{array}{c}
%       \Hoare{s1}{P}{\varphi}
%       \\
%       \HoareLe{s1}{P}{R}{f_1} \qquad 
%              \HoareLe{s2}{\varphi \land R}{Q}{f_2}
%       \\
%       \HoareLe{s1}{P}{\neg R}{g_1} \qquad 
%              \HoareLe{s2}{\varphi \land \neg R}{Q}{g_2}
%       \\
%       f_1 f_2 + g_1 g_2 \leq f 
%     \end{array}
%   }{
%     \HoareLe{s1;s2}{P}{Q}{f}
%   }\left[\verb+seq+\ \varphi\ f_1\ f_2\ g_1\ g_2 \right]
% \end{displaymath}
% %
% If no argument is given then the following rule is applied:
% \begin{displaymath}
%   \infrule{
%     \Hoare{s1}{P}{R} \qquad \HoareLe{s2}{R}{Q}{f}
%   }{
%     \HoareLe{s1;s2}{P}{Q}{f}
%   }\left[\verb+seq+\ n\ R\right]
% \end{displaymath}

% Single bound parameters are not accepted for upper-bounded judgements.

% \paragraph*{Lower-bounded and exact  judgements.}

% The application of the \verb+seq+ tactic have similar regardless of
% lower or exact bounds. 

% The second optional parameter of type $\verb+real+$ represents a
% probability bound (only supported for $=$ and $\geq$), and the
% optional direction parameter indicates whether this bound is to be
% applied to the first or second half of the split statement.

% \begin{displaymath}
% \begin{array}{c}
%   \infrule{
%     \HoareGe{s1}{P}{R}{f/g} \qquad \HoareGe{s2}{R}{Q}{g}
%   }{
%     \HoareGe{s1;s2}{P}{Q}{f}
%   }\left[\verb+seq+\ n\ R\ g\right]
% \\[4ex]
%   \infrule{
%     \HoareGe{s1}{P}{R}{g} \qquad \HoareGe{s2}{R}{Q}{f/g}
%   }{
%     \HoareGe{s1;s2}{P}{Q}{f}
%   }\left[\verb+seq>>+\ n\ R\ g\right]
% \end{array}
% \end{displaymath}
% %
% %
% Similar rules hold for $=$. If the bound parameter $g$ is not given then
% $g$ is defined as $f$ in the above rule description.

\subsubsection{Relational Hoare Logic}

\Syntax
\rawec{app} \textit{codepos} \textit{form}

\Description
Applies the RHL rule for sequential composition:
$$
\infrule{\Equiv{c_1}{c_2}{\post}{\post'} \quad
         \Equiv{c_1'}{c_2'}{\post'}{\post''}}
        {\Equiv{c_1;c_1'}{c_2;c_2'}{\post}{\post''}}[\textrm{R-Seq}]
$$
The application of tactic $\mathec{app}\ m\ n\ p$ defines $c_1$ as the first
$m$ instructions of the program on the left-hand side and $c_2$ as
the first $n$ instructions of the program on the right-hand side
and $\post'$ as $p$.


\subsection{Conditional statements: the \rawec{condt,condf} tactic}
\index{pL}{\rawec{condt,condf}}
%
\NotDocumented

\subsection{Conditional statements: the \rawec{if} tactic}
\index{pL}{\rawec{if}}
%

\subsubsection{Hoare Logic}

Applies the following rule for conditional statements. It expects a
conditional statement at the first program position.
\begin{displaymath}
\begin{array}{c}
  \infrule{
    \Hoare{c_1}{\pre \land b}{\post}\qquad
    \Hoare{c_2}{\pre \land \neg b}{\post}
  }{
    \Hoare{\Cond{b}{c_1}{c_2}}{\pre}{\post}
  }\left[\mathec{if} \right] 
\\[4ex]
\end{array}
\end{displaymath}


\subsubsection{Hoare and Probabilistic Hoare Logic}

Applies the following rule for conditional statements. It expects a
conditional statement at the first program position.
\begin{displaymath}
\begin{array}{c}
  \infrule{
    \HoareLe{c_1}{\pre \land b}{\post}{f}\qquad
    \HoareLe{c_2}{\pre \land \neg b}{\post}{f}
  }{
    \HoareLe{\Cond{b}{c_1}{c_2}}{\pre}{\post}{f}
  }\left[\mathec{if} \right] 
\\[4ex]
\end{array}
\end{displaymath}
Similar rules hold for $=,\geq$.

\subsubsection{Relational Hoare Logic}

\Syntax \rawec{if} [\textit{side}]

\Description Applies the pRHL rule for conditional.
If the \textit{side} argument is given then the corresponding
one side rule is used, else the two side rule is used.
The \rawec{if} tactic expects a conditional as first instruction. 
\begin{center}
\begin{tabular}{c|c}
Syntax & Rule \\
\hline\\
\mathec{if{1}} &
$
\infrule{\Equiv{c_1;c}{c'}{\pre \land e\sidel}{\post}
        \quad \Equiv{c_2;c}{c'}{\pre \land \neg e\sidel}{\post}}
        {\Equiv{\Cond{e}{c_1}{c_2};c}{c'}{\pre}{\post}}
$\\
\\\hline\\
\mathec{if{2}} &
$
\infrule{\Equiv{c'}{c_1;c}{\pre \land e\sider}{\post}
        \quad \Equiv{c'}{c_2;c}{\pre \land \neg e\sider}{\post}}
        {\Equiv{c'}{\Cond{e}{c_1}{c_2};c}{\pre}{\post}}
$\\
\\\hline\\
\mathec{if} &
$
\infrule{
 \begin{array}{c}
   \vdash \pre \Rightarrow e\sidel = e'\sider \\
   \Equiv{c_1;c}{c'_1;c'}{\pre \land e\sidel \land e'\sider}{\post}\\
   \Equiv{c_2;c}{c'_2;c'}{\pre \land \neg e\sidel \land \neg e'\sider}{\post}
 \end{array}
}{\Equiv{\Cond{e}{c_1}{c_2};c}
        {\Cond{e'}{c'_1}{c'_2};c'}
        {\pre}{\post}}
$\\
\end{tabular}
\end{center}


\subsection{Deterministic straight-line code: the \rawec{wp} tactic}
\index{pL}{\rawec{wp}}

\Syntax \rawec{wp} [\textit{codepos}]

\Description The \rawec{wp} tactic computes the weakest-precondition of
deterministic, loop and procedure-call free program fragments
(i.e. deterministic assignments and conditionals).  If the op code
position parameter is not provided, The tactic processes instructions
bottom-up until a random sampling, a loop or a function call is
reached. The computation of the weakest precondition over a
conditional instruction is only possible if its branches do not
contain random samplings, while-loops nor function calls.

The optional code position parameter \textit{pos} restricts the range
of instructions that may be affected by the tactic invocation. 

\subsubsection{Hoare Logic}

\subsubsection{Probabilistic Hoare Logic}

\begin{displaymath}
  \infrule{
    \HoareLe{c_1}{\pre }{\mathsf{wp}(c_2,\post)}{f}
  }{
    \HoareLe{c_1;c_2}{\pre}{\post}{f}
  }\left[\mathec{wp} \right] 
\end{displaymath}
Similar rules hold for $=,\geq$.

\subsubsection{Relational Hoare Logic}

% \subsection{Concluding proofs of programs: the \rawec{skip} tactic}
% \index{hoare}{Program Reasoning!skip@\rawec{skip}}
% \index{phl}{Program Reasoning!skip@\rawec{skip}}
% \index{prhl}{Program Reasoning!skip@\rawec{skip}}
%
\subsection{Function call statements: the \rawec{call} tactic}
\index{pL}{\rawec{call}}
%
\subsubsection{Hoare Logic}
\Syntax \rawec{call} \textit{formula} \textit{formula}
\Description

Let $p$ stand for the formal parameters of function $f$, $\result_f$
the result variable of function $f$, and $\vec{m}$ the set of
variables modifiable by $f$.
\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \Hoare{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}
      }
      \\[.5ex]
      \Hoare{f}{\pre_f}{\post_f}
    \end{array}
  }{
    \Hoare{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}
  }\left[\mathec{call}~ \pre_f~ \post_f \right]
\end{displaymath}



\subsubsection{Probabilistic Hoare Logic}

\Syntax \mathec{call} \textit{formula} \textit{formula} [\textit{formula}]

\Description

Let $p$ stand for the formal parameters of function $f$, $\result_f$
the result variable of function $f$, and $\vec{m}$ the set of
variables modifiable by $f$.
\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \Hoare{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}
      }
      \\[.5ex]
      \HoareLe{f}{\pre_f}{\post_f}{\delta}
    \end{array}
  }{
    \HoareLe{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}{\delta}
  } \left[\mathec{call}~ \pre_f~ \post_f \right]
\end{displaymath}

\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \HoareEq{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}}{\frac{\delta}{\delta'}}
    \\[.5ex]
    \HoareEq{f}{\pre_f}{\post_f}{\delta'}
  \end{array}
  }{
    \HoareEq{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}{\delta}
  } \left[\mathec{call}~ \pre_f~ \post_f~ \delta' \right]
\end{displaymath}

\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \HoareGe{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}}
      {\frac{\delta}{\delta'}}
    \\[.5ex]
    \HoareGe{f}{\pre_f}{\post_f}{\delta'}
  \end{array}
  }{
    \HoareGe{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}{\delta}
  } \left[\mathec{call}~ \pre_f~ \post_f ~\delta' \right]
\end{displaymath}

If no parameter is given for the lower-bounded and exact judgements
then $\delta'=1$.


\subsection{While loop statements: the \rawec{while} tactic}
\index{pL}{\rawec{while}}

\subsubsection{Hoare Logic}

\Syntax

\Description


\subsubsection{Probabilistic Hoare Logic}

\Syntax \rawec{while} \textit{formula} \textit{formula} 
[\textit{formula} \textit{formula}]
%

\Description
%
The argument is the loop invariant, and the second one is a variant
expression used to prove termination. 
%
The third one is a real expression bound $g$ and the fourth one an
integer expression $n$.
%
If $g$ is not given then it is interpreted as $g=1$, and the fourth
formula is ignored, otherwise required. $M$ stands for the variables
that may be modified by $c$.

\begin{displaymath}
  \infrule{
    \begin{array}{c}
    \HoareGe{c'}{\pre }{\chi \land 
      \forall M.~ (\chi \land 0 \leq e \Rightarrow \neg b)  \land
      \chi \land \neg b \Rightarrow \post}{f} 
    \\[.5ex]
    \forall k.~ \HoareEq{c}{\chi \land b \land e = k}{\chi \land e
      < k}{1}
  \end{array}
}{
    \HoareGe{c';\While{b}{c}}{\pre}{\post}{f}
  }\left[\mathec{while}\ \chi\ e \right] 
\end{displaymath}
Similarly for (=).

\warningbox{The following variants are not implemented}

For an arbitrary bound $g$ the following rule generalizes the one
above for lower bounded judgments:
\begin{displaymath}
  \infrule{
    \begin{array}{c}
    \HoareGe{c'}{\pre }{\chi \land e \leq n \land 
      \forall M.~ (\chi \land 0 \leq e \Rightarrow \neg b) 
      \land (\chi \land \neg b \Rightarrow \post)}{\frac{f}{g^n}} 
    \\[.5ex]
    \HoareGe{c}{\chi \land b}{\chi}{g}
    \\[.5ex]
    \forall k.~ \HoareEq{c}{\chi \land b \land e = k}{e<k}{1}
  \end{array}
}{
    \HoareGe{c';\While{b}{c}}{\pre}{\post}{f}
  }\left[\mathec{while}\ \chi\ e\ g\ n \right] 
\end{displaymath}

and the folowing one for exact judgments (=):
\begin{displaymath}
  \infrule{
    \begin{array}{c}
    \HoareGe{c'}{\pre }{\chi \land e = n \land 
      \forall M.~ (\chi\Rightarrow (0\leq e \Leftrightarrow \neg b)) 
        \land (\chi \land \neg b \Rightarrow \post)}
      {\frac{f}{g^n}}
    \\[.5ex]
    \HoareGe{c}{\chi \land b}{\chi}{g}
    \\[.5ex]
    \forall k.~ \HoareEq{c}{\chi \land b \land e = k}{e=k-1}{1}
  \end{array}
}{
    \HoareGe{c';\While{b}{c}}{\pre}{\post}{f}
  }\left[\mathec{while}\ \chi\ e\ g\ n \right] 
\end{displaymath}

There is no appropriate rule for $(\leq)$.


\subsubsection{Relational Hoare Logic}

\Syntax  \rawec{while} [\textit{side}] \textit{form} [\textit{form}]

\Description This tactic applies the pRHL verification rules for
loops:
\begin{itemize}
\item the optional argument \textit{side} can be either \rawec{{1}} or
  \rawec{{2}} to indicate the application of one-sided versions of the
  rule. If missing, the two-sided rule for loops is considered.
\item the first \textit{form} argument is mandatory and is used as
  loop invariant. It can refer to variables in both the left and right
  programs.
\item the optional parameter \textit{form} is required (and accepted
  only) in the one-sided application of the rule. This parameter
  corresponds to the decreasing variant expression used to prove loop
  termination.
\end{itemize}



\paragraph{Two-sided version.}
%
\Syntax \rawec{while} \textit{form} 
%
\Description Applies the two-sided RHL rule for while loops, using the
\textit{form} parameter as loop invariant. This tactic requires that
the last instruction of both left and right statements are while loops.
In the rule, $M$ refers to the variables that may be modified by the
loop bodies.

\begin{displaymath}
\infrule{ 
  \begin{array}{c}
    \Equiv{c_2}{c'_2}{I \land e\sidel \land e'\sider}{I \land  e\sidel = e'\sider}\\
    \Equiv{c_1}{c'_1}{\pre}{ I \land e\sidel = e'\sider \land 
      \forall M, (I \land \neg e\sidel \land \neg e'\sider \Rightarrow \post)}
  \end{array}
}{
  \Equiv{c_1;\While{e}{c_2}}{c'_1;\While{e'}{c'_1}}{\pre}{\post}
}
\end{displaymath}

\paragraph{One-sided version.}

\Syntax \rawec{while} \textit{side} \textit{form} \textit{form} 

\Description Applies the one-sided pRHL rule for while loops, using
the first parameter \textit{form} as loop invariant and the second
parameter \textit{form} as a decreasing \textit{variant}
expression. The variant is used to verify the loop termination. The
one-sided rule are described below. Only the left (\rawec{{1}}) variant
is shown; the right (\rawec{{2}}) variant is symmetric. The expressions
$\forall X,~\varphi$ and $\exists X,~\varphi$ denote, respectively,
universal and existential quantification over the set of variables $X$
modified in the loop body $c$.

\begin{displaymath}
\infrule{
  \begin{array}{c}
    \vdash I \land v \leq b \Rightarrow \neg e  \\
    \Equiv{c}{\Skip}{b=B \land v=C \land e \land I }{b=B \land v<C \land I} \\
    \Equiv{c_1}{c_2}{\pre}{I \land \forall X, (I \land \neg e
      \Rightarrow \post)}
  \end{array}
}{
  \Equiv{c_1;\While{e}{c}}{c_2}{\pre}{\post}
}
\end{displaymath}


\subsection{Abstract adversaries: the \rawec{fun} tactic}
\index{pL}{\rawec{fun}}

\subsubsection{Verifying invariants}


\paragraph*{Probabilistic Hoare Logic}
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \pre \Rightarrow \chi  \qquad 
    \chi \Leftrightarrow\post
    \\[.5ex]
    \HoareEq{O_i}{\chi}{\chi}{1}
  \end{array}
}{
  \HoareEq{A}{\pre}{\post}{1}
} [\mathec{fun}~\chi]
\end{displaymath}

\paragraph*{Hoare Logic}
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \pre \Rightarrow \chi  \qquad 
    \chi \Rightarrow\post
    \\[.5ex]
    \Hoare{O_i}{\chi}{\chi}
  \end{array}
}{
  \Hoare{A}{\pre}{\post}
} [\mathec{fun}~\chi]
\end{displaymath}

\paragraph*{Relational Hoare Logic}

% \Syntax \rawec{fun} \textit{formula}

% \Description
\paragraph*{ }
The formula given as parameter represents the general oracle
invariant. 
%
The tactic implements the following rule:
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \pre \Rightarrow \chi \land \glob_A = \glob_B \land \vec{p}_A=\vec{p}_B
    \\[.5ex]
    \chi\land\glob_A=\glob_B\land\result_A=\result_B\Rightarrow\post
    \\ 
    \Equiv{O_i}{O_i'}{\chi\land
      \vec{p}_{O_i}=\vec{p}_{O'_i}}{\chi\land \result_{o_i}=\result_{o'_i}}
  \end{array}
}{
  \Equiv{A}{B}{\pre}{\post}
} [\mathec{fun}~\chi]
\end{displaymath}
%
where $\vec{p}_f$ represent the formal parameters of a function
(abstract adversary or oracle) $f$, $\result_f$ represents the result of
a function (abstract adversary or oracle) $f$, $\left\{O_i\right\}_{i=0}^k$ and
$\left\{O'_i\right\}_{i=0}^k$ are the oracles of the abstract adversaries $A$ and
$B$, $\glob_A$ and $\glob_B$ represent the global state of the abstract
adversaries $A$ and $B$, ...

\subsubsection{Verifying invariants upto bad}
\NotDocumented

\subsection{Trivial judgements: the \rawec{exfalso} tactic}
\index{pL}{\rawec{exfalso}}
\NotDocumented

\subsection{Trivial judgements: the \rawec{eqobsin} tactic}
\index{pL}{\rawec{eqobsin}}
\NotDocumented

\subsection{Trivial judgements: the \rawec{pr\_bounded} tactic}
\index{pL}{\rawec{pr_bounded}}

\subsubsection{Probabilistic Hoare Logic}
\Syntax \rawec{pr_bounded}
discharges goals by applying trivial probability properties:
\begin{displaymath}
\begin{array}{cc}
\infrule{
}{
  \HoareLe{c}{\pre}{\post}{1}
}
&
\infrule{
}{
  \HoareGe{c}{\pre}{\post}{0}
}
\end{array}
\end{displaymath}



\subsection{Strengthening goals: the \rawec{conseq} tactic}
\index{pL}{\rawec{conseq}}

\Syntax \rawec{conseq} \textit{formula} \textit{formula}
\subsubsection{Hoare Logic}

\begin{displaymath}
\infrule{
  \Hoare{c}{\pre'}{\post'} \qquad \pre\Rightarrow\pre' \qquad  \post'\Rightarrow\post
}{
  \Hoare{c}{\pre}{\post}
}\left[\mathec{conseq}~ \pre'~ \post' \right]
\end{displaymath}

\subsubsection{Probabilistic Hoare Logic}
\begin{displaymath}
\infrule{
  \HoareLe{c}{\pre'}{\post'}{\delta} \qquad \pre\Rightarrow\pre' \qquad  \post\Rightarrow\post'
}{
  \HoareLe{c}{\pre}{\post}{\delta}
}\left[\mathec{conseq}~ \pre'~ \post' \right]
\end{displaymath}

\begin{displaymath}
\infrule{
  \HoareEq{c}{\pre'}{\post'}{\delta} \qquad \pre\Rightarrow\pre' \qquad  \post\Leftrightarrow\post'
}{
  \HoareEq{c}{\pre}{\post}{\delta}
}\left[\mathec{conseq}~ \pre'~ \post' \right]
\end{displaymath}

\begin{displaymath}
\infrule{
  \HoareGe{c}{\pre'}{\post'}{\delta} \qquad \pre\Rightarrow\pre' \qquad  \post'\Rightarrow\post
}{
  \HoareGe{c}{\pre}{\post}{\delta}
}\left[\mathec{conseq}~ \pre'~ \post' \right]
\end{displaymath}

\warningbox{(changing the bound is not yet implemented)}

\subsubsection{Relational Hoare Logic}

\begin{displaymath}
\infrule{
  \Equiv{c_1}{c_2}{\pre'}{\post'} \qquad \pre\Rightarrow\pre' \qquad  \post'\Rightarrow\post
}{
  \Equiv{c_1}{c_2}{\pre}{\post}
}\left[\mathec{conseq}~ \pre'~ \post' \right]
\end{displaymath}

\subsection{Strengthening goals: the \rawec{bd\_eq}}
\index{pL}{\rawec{bd_eq}}
%
\Syntax \rawec{bd_eq}
\begin{displaymath}
\begin{array}{cc}
\infrule{
  \HoareEq{c}{\pre}{\post}{f}
}{
  \HoareLe{c}{\pre}{\post}{f}
}
&
\infrule{
  \HoareEq{c}{\pre}{\post}{f}
}{
  \HoareGe{c}{\pre}{\post}{f}
}
\end{array}
\end{displaymath}


\subsection{Strengthening goals: the \rawec{bypr} tactic}
\index{pL}{\rawec{bypr}}
%
\subsubsection{Relational Hoare Logic}

\begin{displaymath}
\infrule{
  \forall m_1,\ \forall m_2,\ 
  \Prm{f_1}{m_1}{\varphi_1} = \Prm{f_2}{m_2}{\varphi_2}
}{
  \Equiv{f_1}{f_2}{\pre}{\post}
}
\end{displaymath}




\subsection{Possibilistic or probabilistic: the \rawec{hoare,hoare\_bd} tactic}
\index{pL}{\rawec{hoare,hoare_db}}

\subsubsection{Possibilistic and probabilistic Hoare Logic}
\Syntax \mathec{hoare}, \mathec{hoare_bd}
allows to switch between possibilistic and probabilistic logics
according to these rules:
\begin{displaymath}
\begin{array}{cc}
\infrule{
  \Hoare{c}{\pre}{\neg \post} \quad f = 0
}{
  \HoareEq{c}{\pre}{\post}{f}
}
&
\infrule{
  \HoareEq{c}{\pre}{\neg\post}{0}
}{
  \Hoare{c}{\pre}{\post}
}
\end{array}
\end{displaymath}




\subsection{Probability expressions: \rawec{deno} tactics}
\index{pL}{\rawec{deno,hoare_deno}}
\subsubsection{Probabilistic Hoare Logic}

\begin{displaymath}
\infrule{
    \pre 
    \qquad 
    \chi\Rightarrow\post 
    \qquad 
    \HoareLe{f}{\pre}{\post}{\delta}
}{
  \Prm{c}{m}{\chi} \leq \delta
}\left[\mathec{hoare_deno}\ \pre\ \post\right]
\end{displaymath}

\begin{displaymath}
\infrule{
    \pre 
    \qquad 
    \post\Leftrightarrow \chi 
    \qquad 
    \HoareEq{f}{\pre}{\post}{\delta}
}{
  \Prm{c}{m}{\chi} = \delta
}\left[\mathec{hoare_deno}\ \pre\ \post\right]
\end{displaymath}

\begin{displaymath}
\infrule{
    \pre 
    \qquad 
    \post\Rightarrow\chi
    \qquad 
    \HoareGe{f}{\pre}{\post}{\delta}
}{
  \delta \leq \Prm{c}{m}{\chi}
}\left[\mathec{hoare_deno}\ \pre\ \post\right]
\end{displaymath}


\subsubsection{Relational Hoare Logic}

\begin{displaymath}
\infrule{
  \Equiv{c_1}{c_2}{\pre}{\post} 
  \qquad
  \pre
  \qquad
  \post \Rightarrow \chi_1 \Rightarrow \chi_2
}{
  \Prm{c_1}{m_1}{\chi_1} \leq \Prm{c_2}{m_2}{\chi_2}
}\left[\mathec{deno}\ \pre\ \post\right]
\end{displaymath}

\begin{displaymath}
\infrule{
  \Equiv{c_1}{c_2}{\pre}{\post} 
  \qquad
  \pre
  \qquad
  \post \Rightarrow (\chi_1 \Leftrightarrow \chi_2)
}{
  \Prm{c_1}{m_1}{\chi_1} = \Prm{c_2}{m_2}{\chi_2}
}\left[\mathec{deno}\ \pre\ \post\right]
\end{displaymath}


\subsection{Probability expressions: the \rawec{pr_false, pr_or} tactics}
\index{pL}{\rawec{pr_false,pr_or}}

\begin{displaymath}
\infrule{
  \false \Rightarrow \post
}{
  \Prm{c}{m}{\post} = 0
}
\end{displaymath}

\begin{displaymath}
\infrule{
\Prm{c}{m}{\pre} \land
  \Prm{c}{m}{\post} \land \Prm{c}{m}{\pre \wedge \post} = \delta
}{
  \Prm{c}{m}{\pre \vee \post} = \delta
}
\end{displaymath}


\subsection{Program transformations: the \rawec{inline} tactic}
\index{pL}{\rawec{inline}}
%

\subsection{Program transformations: the \rawec{swap} tactic}
\index{pL}{\rawec{swap}}
%
\Syntax \rawec{swap} [\textit{side}] \textit{swap\_pos}

\textbf{where:} 
\begin{tabular}[t]{l}
  \textit{swap\_pos} ::= 
  \textit{n} \textit{n} \textit{n} $\mid$ \textit{n} \textit{z} $\mid$ [\textit{n}:\textit{n}] \textit{z}
  \\
  $n$ a natural number
  \\
  $z$ an integer number
\end{tabular}
  

The tactic [\rawec{swap} $p_1$ $p_2$ $p_3$] swaps the code between
positions $p_1$ and $p_2$ with the code between positions $p_2$ and
$p_3$. That is, assuming that $c_1$ and $c_2$ are syntactically
independent, that $c_1$ is between positions $p_1$ and $p_2$ and that
$c_2$ is between positions $p_2$ and $p_3$, the tactic implements the
following rule:
\begin{displaymath}
\infrule{
  \Hoare{c;c_2;c_1;c_3}{\pre}{\post}
}{
  \Hoare{c;c_1;c_2;c_3}{\pre}{\post}
} [\mathec{swap}\ p_1\ p_2\ p_3]
\end{displaymath}

If $k$ is positive (negative) then [\rawec{swap} $k$] moves the first
(last) instruction $k$ positions forwards (backwards). Similarly,
[\rawec{swap} $i$ $k$] moves the $i^{th}$ instruction forwards or
backwards, and [\rawec{swap} $[i_1:i_2]$ $k$] moves the instructions
between positions $i_1$ and $i_2$.

\subsection{Program transformations: the \rawec{fun} tactic}
\index{pL}{\rawec{fun}}
\NotDocumented
\subsection{Program transformations: the \rawec{unroll} tactic}
\index{pL}{\rawec{unroll}}
\NotDocumented
\subsection{Program transformations: the \rawec{splitwhile} tactic}
\index{pL}{\rawec{splitwhile}}
\NotDocumented
\subsection{Program transformations: the \rawec{fusion,fission}
  tactic}
\index{pL}{\rawec{fusion,fission}}
\NotDocumented
\subsection{Program transformations: the \rawec{condt,condf} tactic}
\index{pL}{\rawec{condt,condf}}
\NotDocumented
\subsection{Program transformations: the \rawec{kill} tactic}
\index{pL}{\rawec{kill}}
\NotDocumented




\subsection{Failure events: the \rawec{fel} tactic}
\index{pL}{\rawec{fel}}
%
The following rule describes the application of the tactic
$\mathec{fel}\ k\ q\ c\ \delta\ F\ P$.  Assume $f$ is defined and
$c_1,c_2$ stands for the splitting of its body at position $n$. Let
$\left\{O_i\right\}_{i=0}^k$ stand for all oracles accessed by any
adversary called at $c_2$. Assume that variables in $F$ can at most be
modified by $\left\{O_i\right\}_{i=0}^k$.
 
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \left\{
    \begin{array}{l}
      \HoareLe{O_i}{\neg F}{F}{h(c)} \\
      \forall c_0,\ \Hoare{O_i}{P\land c=c_0}{c_0 < c} \\
      \forall c_0,\ \forall f_0,\ \Hoare{O_i}{\neg P\land F=f_0 \land c=c_0}{F=f_0 \land c=c_0} \\
    \end{array}\right\}_{i=0}^k\\[5ex]
    \forall m', (\varphi \Rightarrow F \land c\leq q) 
    \qquad 
    \sum_{i=0}^{q-1} h(i) \leq \epsilon 
    \qquad
    \Hoare{c_1}{\true}{\neg F \land c=0}
  \end{array}
}{
  \Prm{f}{m}{\varphi} \leq \epsilon  
} \left[\mathec{fel}\ n\ q\ h\ c\ F\ P\right]
\end{displaymath}



% \subsection{Loop reordering}
% \Syntax 
% \Description 
% An invocation of 
% $$\left[\verb+reordering+\ i\ (p_{w_1},p_{\mathsf{incr}_1})\
%   (p_{w_2},p_{\mathsf{incr}_2})\ \mathcal{I}\ \varolessthan\ (f,f^{-1})\right]$$
% %
% where $i$ is the iteration expression, $p_{w_1},p_{w_2}$ indicates the
% position of the while loops and
% $p_{\mathsf{incr}_1},p_{\mathsf{incr}_2}$ the position of the $d$
% statement increasing $i$, $b$ only depends on $i$, $c$ does not modify
% $i$, $\mathcal{I}:\verb+'a+\to \verb+Bool+$, $\varolessthan:
% \verb+'a+\to\verb+'a+\to\verb+Bool+$, $f:\verb+'a+\to\verb+'a+$
%  implements the following rule
% %
% \begin{displaymath}
% \infrule{
% \begin{array}{c}
%   \Equiv{c_1}{c_2}{\pre}{\varphi \land \left| 
%       \begin{array}{l}
%         (\mathcal{I}\,i \Rightarrow\forall j,~\mathcal{I}\,j
%         \Rightarrow i<j) \land  
%       \\
%       \varphi \land
%       \\
%       \forall j.~\neg\mathcal{I}\,j\Rightarrow \neg\,j \land
%       \\
%       \forall M.~ (\varphi\Rightarrow Q) \land
%     \end{array}
%     \right.
%   }
%   \\
%   \mbox{$f$ bijection on $\mathcal{I}$}
%   \\
%   \forall z_1\,z_2\Equiv
%   {c\subst{i}{f\,z_1};c\subst{i}{f\,z_2}}
%   {c\subst{i}{f\,z_2};c\subst{i}{f\,z_1}}
%   {
%     \begin{array}{l}
%       \mathcal{I}\,z_1 \land \mathcal{I}\,z_2 \land z_1\varolessthan
%       z_2 
%       \\ 
%       \land f\, z_2\varolessthan f\, z_1\land \varphi
%     \end{array}
%   }
%   {\varphi}
%   \\
%   \Equiv{c}{c}
%   {\mathcal{I}\,i \land i\sidel=i\sider \land \varphi}
%   {\varphi}
% \end{array}
% }{
% \Equiv{c_1;\While{b}{(c(i);d)}}{c_2;\While{b}{(c(f\,i);d)}}{\pre}{\post}
% }
% \end{displaymath}


\section{Tacticals}


\section{Automated Tactics}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "easycrypt"
%%% End: 
