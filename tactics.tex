% !TeX root = easycrypt.tex

%% TODO (Francois): For index, rather than \texttt, use \rawec and make a class of keywords for tactics and tacticals

\chapter{Writing Proofs\label{chap:tactics}}

\EasyCrypt comes with a proof engine that allows to state, in the \EasyCrypt
underneath formalism, properties about the user defined programs
and to prove them.
%
Proofs are built interactively, starting from final goal, by applying
\emph{tactics} that transform a goal (the property we want to prove)
to a set of subsequent goals (the subgoals) s.t. the latter logical
implies the former.
%
This process is repeated iteratively up to the point where all the
subgoals are trivial and can be solved by the system.

This chapter is about the description of this proof engine, and is
structured as follow. We first define the notion of goals and show
how it relates to the \EasyCrypt formalism. We then introduce the notion
of tactics as logically valid goal transformers. Finally, a listing
of all the existing tactics, along with their detailed descriptions,
is given.

\section{The proof engine}

The proof engine deals with \emph{judgments} or \emph{goals} of the form
$\Env; \Gamma \vdash \phi$ where $\Env$ is the (global) environments,
$\Gamma$ is a set of local facts and $\phi$ is the formula we want
to prove. Here is an example of such a judgment:

\begin{center}
$\Int; x, y , z: \tint, x \le y \vdash x + z \le y + z$.
\end{center}

It states that in the \emph{environment} ($\Env$) solely composed of the
theory $\Int$, having three local variables $x, y, z$ of type $\tint$ along
with the fact $x \le y$ (the \emph{context} $\Gamma$), we are interested
in proving $x + z \le y + z$.

\medskip

On top on this, a set of \emph{deduction rules} is given. They
describe how one can derive a judgment $\Env; \Gamma \vdash \phi$ given
that a set of prerequisites (or \emph{premises}) are fulfilled. The general
form of such a rule is given as follow:

\begin{displaymath}
 \infrule{A_1 \cdots A_n}{\Env; \Gamma \vdash \phi}
\end{displaymath}

It has to be read as: \emph{given that $A_1 \cdots A_n$ are derivable, then
so is $\Env, \Gamma \vdash \phi$}. We give three examples of such deduction
rules:

\begin{displaymath}
 \infrule
         {\Env; \Gamma \vdash \phi_1 \quad
          \Env; \Gamma \vdash \phi_1 \Rightarrow \phi_2}
         {\Env; \Gamma \vdash \phi_2}
         {\rname{MP}}
 \quad\quad
 \infrule
         {\Env; \Gamma, \phi_1 \vdash \phi_2}
         {\Env; \Gamma \vdash \phi_1 \Rightarrow \phi_2}
         {\rname{$\Rightarrow$-I}}
 \quad\quad
 \infrule{ }{\Env; \Gamma, \phi, \Delta \vdash \phi}{\rname{Ax}}
\end{displaymath}

The first, the \emph{modus ponens}, states that one can derive
$\Env; \Gamma \vdash \phi_2$ given that $\Env; \Gamma \vdash \phi_1
\Rightarrow \phi_2$ and $\Env; \Gamma \vdash \phi_1$ are derivable.
%
The next provides a way for deriving $\phi_1 \Rightarrow \phi_2$ from
a derivation of $\phi_2$, but with a context augmented by $\phi_1$.
%
The last states that $\Env; \Gamma, \phi, \Delta \vdash \phi$ is derivable as-is.

\medskip

Combining these deduction rules, it is possible to build a tree rooted by
a judgment $\Env; \Gamma \vdash \phi$ and with leaves composed of deduction
rules with no premises (as the third one in the previous example). Such a
tree forms a \emph{proof} of $\Env; \Gamma \vdash \phi$.
%
For instance, Figure~\ref{fig:LJproof} gives a proof of
%
\begin{center}
 $\Env; b_1, b_2 : \tbool \vdash (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2$
\end{center}

\begin{figure}
  \begin{displaymath}
    \infrule
      {\infrule{ }{\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_1 \Rightarrow b_2} \quad
       \infrule{ }{\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_1}}
      {\infrule
        {\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_2}
        {\infrule
           {\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2 \vdash b_1 \Rightarrow b_2}
           {\Env; b_1, b_2 : \tbool \vdash (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2}}}
  \end{displaymath}

  \caption{\label{fig:LJproof} Proof tree of
    $\Env; b_1, b_2 : \tbool \vdash
        (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2$}
\end{figure}

\bigskip

The \EasyCrypt proof engine helps the user building such proof. At each step
of the proof building, the system presents to the user the set of goals
that has to be proved. The user can then \emph{apply} a tactic to one of
them, each tactic corresponding to a deduction rule. If the conclusion
of the rule corresponding to the applied tactic matches the goal to witch
it is applied, the proof engine replaces it with the set of the
premises of the applied rule - the subgoals. This application may generate
no, one or several subgoals depending on the rule. This process is repeated
iteratively, up to the point where no goals remain.

\section{Ambient Logic}

\ambientDesc

\section{Program Transformation Tactics}

TODO: fun, inline, swap, unroll, splitwhile, fusion, fission, condt, condf, 

\section{Program Logics Tactics}

\subsection{The \rawec{skip} tactic}

\Syntax \rawec{skip}

\Description Reduces logical program judgements with empty statements
to a first-order logical goal, as in the following rule for relational
Hoare Logic.
%
\begin{displaymath}
\infrule{
  \pre \Rightarrow \post
}{
  \Equiv{\Skip}{\Skip}{\pre}{\post}
}
\end{displaymath}
%
Similar rules apply for Hoare judgements and probabilistic Hoare
judgements.

\subsection{Reasoning about random samplings: the \rawec{rnd} tactic}
%
\subsubsection{Hoare Logic}
\index{hoare}{Program Reasoning!rnd@\rawec{rnd}}

\Description

% Assume $d:A\, \verb+distr+$...

\begin{displaymath}
\infrule{
  \Hoare{c}{\pre}{\forall z:A,in\_supp\,z\,d \Rightarrow \post\subst{x}{z}}
}{
  \Hoare{c;\Rand{x}{d}}{\pre}{\post}
}
\end{displaymath}

\subsubsection{Probabilistic Hoare Logic}
\index{phl}{Program Reasoning!rnd@\rawec{rnd}}
\Syntax 
\verb+rnd+ [\textit{formula} | \textit{formula} \textit{formula}
\textit{formula} \textit{formula} \textit{formula} \textit{formula} ] 

\Description

The following rule describes the most general variant implemented by
the \rawec{rnd} tactic for \rawec{bd_hoare} judgements:

\begin{displaymath}
\infrule{
  \begin{array}{c}
    \delta_1 \delta_2 + \delta_3 \delta_4 \leq \delta \\
    \HoareLe{c}{\pre}{\varphi}{\delta_1} \\
    \varphi \Rightarrow \mu\, d\, p \leq \delta_2 \land (\forall v\in \mathsf{support}(d).~
    \post\subst{x}{v} \Rightarrow p\, v) \\
    \HoareLe{c}{\pre}{\neg \varphi}{\delta_3} \\
    \neg\varphi \Rightarrow \mu\, d\, p \leq \delta_4 \land (\forall v\in \mathsf{support}(d).~
    \post\subst{x}{v} \Rightarrow p\, v) \\
  \end{array}
}{
  \HoareLe{c;\Rand{x}{d}}{\pre}{\post}{\delta}
}
[\verb+rnd+\ \varphi\ \delta_1\ \delta_2\ \delta_3\ \delta_4\ p]
\end{displaymath}

(idem for $(=)$ and $(\geq)$)

When a single parameter is given, the following rule variants are
implemented:
\begin{displaymath}
\begin{array}{c}
  \infrule{
    \Hoare{c}{\pre}{\mu\, d\, p \leq f \land 
      (\forall v\in \mathsf{support}(d).~ \post\subst{x}{v} \Rightarrow p\, v)}
  }{
    \HoareLe{c;\Rand{x}{d}}{\pre}{\post}{f}
  }\left[\verb+rnd+\ p\right]
\\[4ex]
\end{array}
\end{displaymath}

\begin{displaymath}
  \infrule{
    \HoareEq{c}{\pre}{\mu\, d\, p \geq \delta \land 
      (\forall v\in \mathsf{support}(d).~ p\, v \Rightarrow \post\subst{x}{v} )}{1} 
  }{
    \HoareGe{c;\Rand{x}{d}}{\pre}{\post}{\delta}
  }\left[\verb+rnd+\ p\right]
\end{displaymath}
%
\begin{displaymath}
  \infrule{
    \HoareEq{c}{\pre}{\mu\, d\, p = \delta \land 
      (\forall v\in \mathsf{support}(d).~ p\, v \Leftrightarrow \post\subst{x}{v} )}{1} 
  }{
    \HoareEq{c;\Rand{x}{d}}{\pre}{\post}{\delta}
  }\left[\verb+rnd+\ p\right]
\end{displaymath}



% the first optional parameter $p$ is a computable predicate (i.e., \verb+'a cPred+)
% (i.e., \verb+'a -> bool+ ). Assume $d$ of type \verb+A Distr.distr+. 
% \begin{displaymath}
% \begin{array}{c}
%   \infrule{
%     \Hoare{c}{\pre}{\mu\, d\, p \leq f \land 
%       (\forall v\in \mathsf{support}(d).~ \post\subst{x}{v} \Rightarrow p\, v)}
%   }{
%     \HoareLe{c;\Rand{x}{d}}{\pre}{\post}{f}
%   }\left[\verb+rnd+\ p\right]
% \\[4ex]
% \end{array}
% \end{displaymath}
% If $p$ is not given then the tool attempts to build it from $\post$
% (not implemented yet).

% For lower-bounded and exact probabilistic judgments the tactic
% additionally accepts an optional parameter $g$ of type \verb+real+
% representing a bound:
% \begin{displaymath}
%   \infrule{
%     \HoareGe{c}{\pre}{\mu\, d\, p \geq g \land 
%       (\forall v\in \mathsf{support}(d).~ p\, v \Rightarrow \post\subst{x}{v} )}{\frac{f}{g}} 
%   }{
%     \HoareGe{c;\Rand{x}{d}}{\pre}{\post}{f}
%   }\left[\verb+rnd+\ p\ g\right]
% \end{displaymath}
% %
% \begin{displaymath}
%   \infrule{
%     \HoareEq{c}{\pre}{\mu\, d\, p = g \land 
%       (\forall v\in \mathsf{support}(d).~ p\, v \Leftrightarrow \post\subst{x}{v} )}{\frac{f}{g}} 
%   }{
%     \HoareEq{c;\Rand{x}{d}}{\pre}{\post}{f}
%   }\left[\verb+rnd+\ p\ g\right]
% \end{displaymath}
% %
% If $g$ is not given then $g=f$ in the rule.

\subsubsection{Relational Hoare Logic}
\index{prhl}{Program Reasoning!rnd@\rawec{rnd}}

\Syntax \verb+rnd+[\textit{side}] [\textit{bij\_info}]
where
\textit{bij\_info} is either
\begin{itemize}
  \item \textit{form} \textit{form}
  \item \textit{form} \_
\end{itemize}


\Description

The logical rule implemented by the \verb+rnd+ tactic depends on the
the optional parameter \textit{side}. If a left/right side flag is
provided then the one-sided logical rule for random sampling is
applied. If missing, then the two-sided rule for random assignment is
considered.
%

\paragraph*{Two-sided application.} 
In this case case, the \verb+rnd+ tactic takes as parameter a
representation of a bijective function. 

When two formulae are provided as the \textit{bij\_info} parameter,
they are verified to be a bijective function and its inverse. If only
one function is given then it is required to be an involution, and
lastly if no argument is given then the identity function is assumed.

The description of the rule below assumes that a bijective function
$f$ and its inverse is provided and generates according verification
conditions. Furthermore, it requires the following type constraints
for some types \verb+'a+ and \verb+'b+: 
\begin{itemize}
\item $d_1:\verb+'a distr+$,
\item $d_2:\verb+'b distr+$, $f:\verb+'a+\to\verb+'b+$,
\item $f^{-1}:\verb+'b+\to\verb+'a+$, 
\item ...
\end{itemize}

\begin{displaymath}
\infrule{
  \Equiv{c_1}{c_2}{\pre} 
  { \forall z,z',in\_supp \,z\,d_1\Rightarrow in\_supp \,z'\,d_2\Rightarrow
    \begin{array}{l}
      (\mu\,d_1\,\charfun_{\{z\}}=\mu\,d_2\,\charfun_{\{f\,z\}} ) 
      \land \\
      (in\_supp\,d_1\,(f^{-1}\,z'))
      \land \\
      (f^{-1}\,(f\,z)=z)
      \land \\
      (f\,(f^{-1}\,z')=z')
      \land \\
      (\post\subst{x_1}{z}\subst{x_2}{f\,z})
    \end{array}
  }
}{
  \Equiv{c_1;\Rand{x_1}{d_1}}{c_2;\Rand{x_2}{d_2}}{\pre}{\post}
}
\end{displaymath}

\paragraph*{Two-sided application.} 
The logical rule implemented when the optional parameter \textit{side}
is used is similar to the random sampling rule for Hoare judgements:


\begin{displaymath}
\infrule{
  \Equiv{c}{c'}{\pre}{\forall z:A,in\_supp\,z\,d \Rightarrow \post\subst{x}{z}}
}{
  \Equiv{c;\Rand{x}{d}}{c'}{\pre}{\post}
}
\end{displaymath}


\subsection{Reasoning about sequential composition: the \rawec{seq} tactic}
%
\subsubsection{Hoare Logic}
\index{hoare}{Program Reasoning!seq@\rawec{seq}}

\Syntax 
\verb+seq+ \textit{codepos} \textit{formula} 

\Description

\Description
Applies the Hoare Logic rule for sequential composition:
$$
\infrule{\Hoare{c}{\post}{\post'} \quad
         \Hoare{c'}{\post'}{\post''}}
        {\Hoare{c;c'}{\post}{\post''}}
$$
The application of tactic \verb+seq k p+ defines $c$ as the first
\verb+k+ instructions of the statement $c;c'$ and $\post'$ as
\verb+p+.


\subsubsection{Probabilistic Hoare Logic}
\index{phl}{Program Reasoning!seq@\rawec{seq}}
\Syntax 
\verb+seq+  \textit{codepos} \textit{formula} (
[\textit{formula} \verb+|+ \textit{formula} \textit{formula}
\textit{formula} \textit{formula}]

\Description

\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \Hoare{s1}{P}{\varphi}
      \\
      \HoareLe{s1}{P}{\chi}{f_1} \qquad 
          \HoareLe{s2}{\varphi \land \chi }{Q}{f_2}
      \\
      \HoareLe{s1}{P}{\neg \chi}{f_3} \qquad 
             \HoareLe{s2}{\varphi \land \neg\chi}{Q}{f_4}
      \\
      f_1 f_2 + f_3 f_4 \leq f 
    \end{array}
  }{
    \HoareLe{s1;s2}{P}{Q}{f}
  }\left[\verb+seq+\ \varphi\ \chi\ f_1\ f_2\ f_3\ f_4 \right]
\end{displaymath}

(idem with ($=$) and ($\geq$)).

% The application of the \verb+seq+ tactic is more complicated when
% dealing with Probabilistic Hoare Logic judgements. 

% The direction parameter is accepted for \emph{lower-bounded} and \emph{exact}
% judgments. The direction \verb+<<+ is assumed by default (as it is globally).
% The first formula represents the intermediate predicate that must hold
% at the splitting program point.

% In the following, the rule descriptions assume that $n$ indicates the
% program position of statement $s_2$.

% \warningbox{The functionality described below is currently disabled}

% \paragraph*{Upper bounded judgements.}
% For upper bounded judgments, the most general variant of the
% \verb+seq+ rule (i.e., when four bounds are given as parameters) implements the following rule:
% \begin{displaymath}
%   \infrule{
%     \begin{array}{c}
%       \Hoare{s1}{P}{\varphi}
%       \\
%       \HoareLe{s1}{P}{R}{f_1} \qquad 
%              \HoareLe{s2}{\varphi \land R}{Q}{f_2}
%       \\
%       \HoareLe{s1}{P}{\neg R}{g_1} \qquad 
%              \HoareLe{s2}{\varphi \land \neg R}{Q}{g_2}
%       \\
%       f_1 f_2 + g_1 g_2 \leq f 
%     \end{array}
%   }{
%     \HoareLe{s1;s2}{P}{Q}{f}
%   }\left[\verb+seq+\ \varphi\ f_1\ f_2\ g_1\ g_2 \right]
% \end{displaymath}
% %
% If no argument is given then the following rule is applied:
% \begin{displaymath}
%   \infrule{
%     \Hoare{s1}{P}{R} \qquad \HoareLe{s2}{R}{Q}{f}
%   }{
%     \HoareLe{s1;s2}{P}{Q}{f}
%   }\left[\verb+seq+\ n\ R\right]
% \end{displaymath}

% Single bound parameters are not accepted for upper-bounded judgements.

% \paragraph*{Lower-bounded and exact  judgements.}

% The application of the \verb+seq+ tactic have similar regardless of
% lower or exact bounds. 

% The second optional parameter of type $\verb+real+$ represents a
% probability bound (only supported for $=$ and $\geq$), and the
% optional direction parameter indicates whether this bound is to be
% applied to the first or second half of the split statement.

% \begin{displaymath}
% \begin{array}{c}
%   \infrule{
%     \HoareGe{s1}{P}{R}{f/g} \qquad \HoareGe{s2}{R}{Q}{g}
%   }{
%     \HoareGe{s1;s2}{P}{Q}{f}
%   }\left[\verb+seq+\ n\ R\ g\right]
% \\[4ex]
%   \infrule{
%     \HoareGe{s1}{P}{R}{g} \qquad \HoareGe{s2}{R}{Q}{f/g}
%   }{
%     \HoareGe{s1;s2}{P}{Q}{f}
%   }\left[\verb+seq>>+\ n\ R\ g\right]
% \end{array}
% \end{displaymath}
% %
% %
% Similar rules hold for $=$. If the bound parameter $g$ is not given then
% $g$ is defined as $f$ in the above rule description.

\subsubsection{Relational Hoare Logic}
\index{prhl}{Program Reasoning!seq@\rawec{seq}}

\Syntax
\verb+app+ \textit{codepos} \textit{form}

\Description
Applies the RHL rule for sequential composition:
$$
\infrule{\Equiv{c_1}{c_2}{\post}{\post'} \quad
         \Equiv{c_1'}{c_2'}{\post'}{\post''}}
        {\Equiv{c_1;c_1'}{c_2;c_2'}{\post}{\post''}}[\textrm{R-Seq}]
$$
The application of tactic \verb+app m n p+ defines $c_1$ as the first
\verb+m+ instructions of the program on the left-hand side and $c_2$ as
the first \verb+n+ instructions of the program on the right-hand side
and $\post'$ as \verb+p+.



\subsection{Reasoning about conditionals: the \rawec{if} tactic}
%

\subsubsection{Hoare Logic}
\index{hoare}{Program Reasoning!if@\rawec{if}}
\index{phl}{Program Reasoning!if@\rawec{if}}

Applies the following rule for conditional statements. It expects a
conditional statement at the first program position.
\begin{displaymath}
\begin{array}{c}
  \infrule{
    \Hoare{c_1}{\pre \land b}{\post}\qquad
    \Hoare{c_2}{\pre \land \neg b}{\post}
  }{
    \Hoare{\Cond{b}{c_1}{c_2}}{\pre}{\post}
  }\left[\verb+if+ \right] 
\\[4ex]
\end{array}
\end{displaymath}


\subsubsection{Hoare and Probabilistic Hoare Logic}
\index{hoare}{Program Reasoning!if@\rawec{if}}
\index{phl}{Program Reasoning!if@\rawec{if}}

Applies the following rule for conditional statements. It expects a
conditional statement at the first program position.
\begin{displaymath}
\begin{array}{c}
  \infrule{
    \HoareLe{c_1}{\pre \land b}{\post}{f}\qquad
    \HoareLe{c_2}{\pre \land \neg b}{\post}{f}
  }{
    \HoareLe{\Cond{b}{c_1}{c_2}}{\pre}{\post}{f}
  }\left[\verb+if+ \right] 
\\[4ex]
\end{array}
\end{displaymath}
Similar rules hold for $=,\geq$.

\subsubsection{Relational Hoare Logic}
\index{prhl}{Program Reasoning!if@\rawec{if}}

\Syntax \verb+if+ [\textit{side}]

\Description Applies the pRHL rule for conditional.
If the \textit{side} argument is given then the corresponding
one side rule is used, else the two side rule is used.
The \verb+if+ tactic expects a conditional as first instruction. 
\begin{center}
\begin{tabular}{c|c}
Syntax & Rule \\
\hline\\
\verb+if{1}+ &
$
\infrule{\Equiv{c_1;c}{c'}{\pre \land e\sidel}{\post}
        \quad \Equiv{c_2;c}{c'}{\pre \land \neg e\sidel}{\post}}
        {\Equiv{\Cond{e}{c_1}{c_2};c}{c'}{\pre}{\post}}
$\\
\\\hline\\
\verb+if{2}+ &
$
\infrule{\Equiv{c'}{c_1;c}{\pre \land e\sider}{\post}
        \quad \Equiv{c'}{c_2;c}{\pre \land \neg e\sider}{\post}}
        {\Equiv{c'}{\Cond{e}{c_1}{c_2};c}{\pre}{\post}}
$\\
\\\hline\\
\verb+if+ &
$
\infrule{
 \begin{array}{c}
   \vdash \pre \Rightarrow e\sidel = e'\sider \\
   \Equiv{c_1;c}{c'_1;c'}{\pre \land e\sidel \land e'\sider}{\post}\\
   \Equiv{c_2;c}{c'_2;c'}{\pre \land \neg e\sidel \land \neg e'\sider}{\post}
 \end{array}
}{\Equiv{\Cond{e}{c_1}{c_2};c}
        {\Cond{e'}{c'_1}{c'_2};c'}
        {\pre}{\post}}
$\\
\end{tabular}
\end{center}


\subsection{Computing weakest preconditions: the \rawec{wp} tactic}
%

\Syntax \verb+wp+ [\textit{codepos}]

\Description The \verb+wp+ tactic computes the weakest-precondition of
deterministic, loop and procedure-call free program fragments
(i.e. deterministic assignments and conditionals).  If the op code
position parameter is not provided, The tactic processes instructions
bottom-up until a random sampling, a loop or a function call is
reached. The computation of the weakest precondition over a
conditional instruction is only possible if its branches do not
contain random samplings, while loops nor function calls.

The optional code position parameter \textit{pos} restricts the range
of instructions that may be affected by the tactic invocation. 
See \ref{???} for a description of its syntax.


\Example


\subsubsection{Hoare Logic}
\index{hoare}{Program Reasoning!wp@\rawec{wp}}

\subsubsection{Probabilistic Hoare Logic}
\index{phl}{Program Reasoning!wp@\rawec{wp}}

\begin{displaymath}
  \infrule{
    \HoareLe{c_1}{\pre }{\mathsf{wp}(c_2,\post)}{f}
  }{
    \HoareLe{c_1;c_2}{\pre}{\post}{f}
  }\left[\verb+wp+ \right] 
\end{displaymath}
Similar rules hold for $=,\geq$.

\subsubsection{Relational Hoare Logic}
\index{prhl}{Program Reasoning!wp@\rawec{wp}}

\subsection{Concluding proofs of programs: the \rawec{skip} tactic}
\index{hoare}{Program Reasoning!skip@\rawec{skip}}
\index{phl}{Program Reasoning!skip@\rawec{skip}}
\index{prhl}{Program Reasoning!skip@\rawec{skip}}
%

\subsection{Simplifying conditionals: the \rawec{condt,condf} tactic}
%
\subsubsection{Probabilistic Hoare Logic}
\index{tactics}{probabilistic Hoare logic!condt@\rawec{condt}}
\index{tactics}{probabilistic Hoare logic!condf@\rawec{condf}}

\subsection{Reasoning about abstract adversaries: the \rawec{fun} tactic}

\subsubsection{Relational Hoare Logic}

\Syntax \verb+fun+ formula

\Description
The formula given as parameter represents the general oracle
invariant. 

The tactic implements the following rule:
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \pre \Rightarrow \chi \land \glob_A = \glob_B \land \vec{p}_A=\vec{p}_B
    \\[.5ex]
    \chi\land\glob_A=\glob_B\land\result_A=\result_B\Rightarrow\post
    \\ 
    \Equiv{O_i}{O_i'}{\chi\land
      \vec{p}_{O_i}=\vec{p}_{O'_i}}{\chi\land \result_{o_i}=\result_{o'_i}}
  \end{array}
}{
  \Equiv{A}{B}{\pre}{\post}
} [\verb+fun+~\chi]
\end{displaymath}
%
where $\vec{p}_f$ represent the formal parameters of a function
(abstract adversary or oracle) $f$, $\result_f$ represents the result of
a function (abstract adversary or oracle) $f$, $\left\{O_i\right\}_{i=0}^k$ and
$\left\{O'_i\right\}_{i=0}^k$ are the oracles of the abstract adversaries $A$ and
$B$, $\glob_A$ and $\glob_B$ represent the global state of the abstract
adversaries $A$ and $B$, ...

\subsubsection{Probabilistic Hoare Logic}
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \pre \Rightarrow \chi  \qquad 
    \chi \Leftrightarrow\post
    \\[.5ex]
    \HoareEq{O_i}{\chi}{\chi}{1}
  \end{array}
}{
  \HoareEq{A}{\pre}{\post}{1}
} [\verb+fun+~\chi]
\end{displaymath}

\subsubsection{Hoare Logic}
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \pre \Rightarrow \chi  \qquad 
    \chi \Rightarrow\post
    \\[.5ex]
    \Hoare{O_i}{\chi}{\chi}
  \end{array}
}{
  \Hoare{A}{\pre}{\post}
} [\verb+fun+~\chi]
\end{displaymath}

\subsection{??????: The \rawec{exfalso} rule}

\subsection{Frame rules ?? : The \rawec{eqobsin} rule}

\subsection{Weakening judgements: The \rawec{conseq} rule}

\Syntax \verb+conseq+ \textit{formula} \textit{formula}
\subsubsection{Hoare Logic}

\begin{displaymath}
\infrule{
  \Hoare{c}{\pre'}{\post'} \qquad \pre\Rightarrow\pre' \qquad  \post'\Rightarrow\post
}{
  \Hoare{c}{\pre}{\post}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}

\subsubsection{Probabilistic Hoare Logic}
\begin{displaymath}
\infrule{
  \HoareLe{c}{\pre'}{\post'}{\delta} \qquad \pre\Rightarrow\pre' \qquad  \post\Rightarrow\post'
}{
  \HoareLe{c}{\pre}{\post}{\delta}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}

\begin{displaymath}
\infrule{
  \HoareEq{c}{\pre'}{\post'}{\delta} \qquad \pre\Rightarrow\pre' \qquad  \post\Leftrightarrow\post'
}{
  \HoareEq{c}{\pre}{\post}{\delta}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}

\begin{displaymath}
\infrule{
  \HoareGe{c}{\pre'}{\post'}{\delta} \qquad \pre\Rightarrow\pre' \qquad  \post'\Rightarrow\post
}{
  \HoareGe{c}{\pre}{\post}{\delta}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}

\warningbox{(changing the bound is not yet implemented)}

\subsubsection{Relational Hoare Logic}

\begin{displaymath}
\infrule{
  \Equiv{c_1}{c_2}{\pre'}{\post'} \qquad \pre\Rightarrow\pre' \qquad  \post'\Rightarrow\post
}{
  \Equiv{c_1}{c_2}{\pre}{\post}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}


\subsection{Reasoning about function calls: the \rawec{call} tactic}
%
\subsubsection{Hoare Logic}
\index{hoare}{Program Reasoning!call@\rawec{call}}
\Syntax \verb+call+ formula formula
\Description

Let $p$ stand for the formal parameters of function $f$, $\result_f$
the result variable of function $f$, and $\vec{m}$ the set of
variables modifiable by $f$.
\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \Hoare{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}
      }
      \\[.5ex]
      \Hoare{f}{\pre_f}{\post_f}
    \end{array}
  }{
    \Hoare{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}
  }\left[\verb+call+~ \pre_f~ \post_f \right]
\end{displaymath}



\subsubsection{Probabilistic Hoare Logic}
\index{phl}{probabilistic Hoare logic!call@\rawec{call}}

\Syntax \verb+call+ formula formula [formula]

\Description

Let $p$ stand for the formal parameters of function $f$, $\result_f$
the result variable of function $f$, and $\vec{m}$ the set of
variables modifiable by $f$.
\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \Hoare{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}
      }
      \\[.5ex]
      \HoareLe{f}{\pre_f}{\post_f}{\delta}
    \end{array}
  }{
    \HoareLe{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}{\delta}
  } \left[\verb+call+~ \pre_f~ \post_f \right]
\end{displaymath}

\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \HoareEq{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}}{\frac{\delta}{\delta'}}
    \\[.5ex]
    \HoareEq{f}{\pre_f}{\post_f}{\delta'}
  \end{array}
  }{
    \HoareEq{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}{\delta}
  } \left[\verb+call+~ \pre_f~ \post_f~ \delta' \right]
\end{displaymath}

\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \HoareGe{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}}
      {\frac{\delta}{\delta'}}
    \\[.5ex]
    \HoareGe{f}{\pre_f}{\post_f}{\delta'}
  \end{array}
  }{
    \HoareGe{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}{\delta}
  } \left[\verb+call+~ \pre_f~ \post_f ~\delta' \right]
\end{displaymath}

If no parameter is given for the lower-bounded and exact judgements
then $\delta'=1$.

\warningbox{New tactics, needs structuring.}

\subsection{: the \rawec{hoare,hoare\_bd,pr\_bounded,bd\_eq}}

\subsubsection{Possibilistic and probabilistic Hoare Logic}
\Syntax \verb+hoare+, \verb+hoare_bd+
allows to switch between possibilistic and probabilistic logics
according to these rules:
\begin{displaymath}
\begin{array}{cc}
\infrule{
  \Hoare{c}{\pre}{\neg \post} \quad f = 0
}{
  \HoareEq{c}{\pre}{\post}{f}
}
&
\infrule{
  \HoareEq{c}{\pre}{\neg\post}{0}
}{
  \Hoare{c}{\pre}{\post}
}
\end{array}
\end{displaymath}

\Syntax \verb+pr_bounded+
discharges goals by applying trivial probability properties:
\begin{displaymath}
\begin{array}{cc}
\infrule{
}{
  \HoareLe{c}{\pre}{\post}{1}
}
&
\infrule{
}{
  \HoareGe{c}{\pre}{\post}{0}
}
% \\[3ex]
% \infrule{
% }{
%   \Prm{c}{m}{\post} \leq 1
% }
% &
% \infrule{
% }{
%   \Prm{c}{m}{\post} \geq 0
% }
\end{array}
\end{displaymath}

\Syntax \verb+bd_eq+
\begin{displaymath}
\begin{array}{cc}
\infrule{
  \HoareEq{c}{\pre}{\post}{f}
}{
  \HoareLe{c}{\pre}{\post}{f}
}
&
\infrule{
  \HoareEq{c}{\pre}{\post}{f}
}{
  \HoareGe{c}{\pre}{\post}{f}
}
\end{array}
\end{displaymath}


\subsection{\rawec{Denot} tactics}
%
\subsubsection{Probabilistic Hoare Logic}

\begin{displaymath}
\infrule{
    \pre 
    \qquad 
    \chi\Rightarrow\post 
    \qquad 
    \HoareLe{f}{\pre}{\post}{\delta}
}{
  \Prm{c}{m}{\chi} \leq \delta
}\left[\verb+hoare_deno+\ \pre\ \post\right]
\end{displaymath}

\begin{displaymath}
\infrule{
    \pre 
    \qquad 
    \post\Leftrightarrow \chi 
    \qquad 
    \HoareEq{f}{\pre}{\post}{\delta}
}{
  \Prm{c}{m}{\chi} = \delta
}\left[\verb+hoare_deno+\ \pre\ \post\right]
\end{displaymath}

\begin{displaymath}
\infrule{
    \pre 
    \qquad 
    \post\Rightarrow\chi
    \qquad 
    \HoareGe{f}{\pre}{\post}{\delta}
}{
  \delta \leq \Prm{c}{m}{\chi}
}\left[\verb+hoare_deno+\ \pre\ \post\right]
\end{displaymath}


\subsubsection{Relational Hoare Logic}

\begin{displaymath}
\infrule{
  \Equiv{c_1}{c_2}{\pre}{\post} 
  \qquad
  \pre
  \qquad
  \post \Rightarrow \chi_1 \Rightarrow \chi_2
}{
  \Prm{c_1}{m_1}{\chi_1} \leq \Prm{c_2}{m_2}{\chi_2}
}\left[\verb+deno+\ \pre\ \post\right]
\end{displaymath}

\begin{displaymath}
\infrule{
  \Equiv{c_1}{c_2}{\pre}{\post} 
  \qquad
  \pre
  \qquad
  \post \Rightarrow (\chi_1 \Leftrightarrow \chi_2)
}{
  \Prm{c_1}{m_1}{\chi_1} = \Prm{c_2}{m_2}{\chi_2}
}\left[\verb+deno+\ \pre\ \post\right]
\end{displaymath}


\subsection{Some \textsf{Pr} tactics: \rawec{pr\_false},
  \rawec{pr\_or}}

\begin{displaymath}
\infrule{
  \false \Rightarrow \post
}{
  \Prm{c}{m}{\post} = 0
}
\end{displaymath}

\begin{displaymath}
\infrule{
\Prm{c}{m}{\pre} \land
  \Prm{c}{m}{\post} \land \Prm{c}{m}{\pre \wedge \post} = \delta
}{
  \Prm{c}{m}{\pre \vee \post} = \delta
}
\end{displaymath}


\subsection{The \rawec{inline} tactic}
%

\subsection{The \rawec{swap} tactic}
%
\Syntax \verb+swap+ [\textit{side}] \textit{swap\_pos}

\textbf{where:} 
\begin{tabular}[t]{l}
  \textit{swap\_pos} ::= 
  \textit{n} \textit{n} \textit{n} $\mid$ \textit{n} \textit{z} $\mid$ [\textit{n}:\textit{n}] \textit{z}
  \\
  $n$ a natural number
  \\
  $z$ an integer number
\end{tabular}
  

The tactic [\verb+swap+ $p_1$ $p_2$ $p_3$] swaps the code between
positions $p_1$ and $p_2$ with the code between positions $p_2$ and
$p_3$. That is, assuming that $c_1$ and $c_2$ are syntactically
independent, that $c_1$ is between positions $p_1$ and $p_2$ and that
$c_2$ is between positions $p_2$ and $p_3$, the tactic implements the
following rule:
\begin{displaymath}
\infrule{
  \Hoare{c;c_2;c_1;c_3}{\pre}{\post}
}{
  \Hoare{c;c_1;c_2;c_3}{\pre}{\post}
} [\verb+swap+\ p_1\ p_2\ p_3]
\end{displaymath}

If $k$ is positive (negative) then [\verb+swap+ $k$] moves the first
(last) instruction $k$ positions forwards (backwards). Similarly,
[\verb+swap+ $i$ $k$] moves the $i^{th}$ instruction forwards or
backwards, and [\verb+swap+ $[i_1:i_2]$ $k$] moves the instructions
between positions $i_1$ and $i_2$.


\subsection{Reasoning about loops: the \rawec{while} tactic}
%
\subsubsection{Hoare Logic}

\Syntax

\Description


\subsubsection{Probabilistic Hoare Logic}
\index{phl}{Program Reasoning!while@\rawec{while}}

\Syntax \verb+while+ \textit{formula} \textit{formula} 
[\textit{formula} \textit{formula}]
%

\Description
%
The first formula is the loop invariant.
%
The second one is a variant expression. 
%
The third one is a real expression bound $g$ and the fourth one an
integer expression $n$.
%
If $g$ is not given then it is interpreted as $g=1$, and the fourth
formula is ignored, otherwise required. $M$ stands for the variables
that may be modified by $c$.

\begin{displaymath}
  \infrule{
    \begin{array}{c}
    \HoareGe{c'}{\pre }{\chi \land 
      \forall M.~ (\chi \land 0 \leq e \Rightarrow \neg b)  \land
      \chi \land \neg b \Rightarrow \post}{f} 
    \\[.5ex]
    \forall k.~ \HoareEq{c}{\chi \land b \land e = k}{\chi \land e
      < k}{1}
  \end{array}
}{
    \HoareGe{c';\While{b}{c}}{\pre}{\post}{f}
  }\left[\verb+while+\ \chi\ e \right] 
\end{displaymath}
Similarly for (=).

\warningbox{The following variants are not implemented}

For an arbitrary bound $g$ the following rule generalizes the one
above for lower bounded judgments:
\begin{displaymath}
  \infrule{
    \begin{array}{c}
    \HoareGe{c'}{\pre }{\chi \land e \leq n \land 
      \forall M.~ (\chi \land 0 \leq e \Rightarrow \neg b) 
      \land (\chi \land \neg b \Rightarrow \post)}{\frac{f}{g^n}} 
    \\[.5ex]
    \HoareGe{c}{\chi \land b}{\chi}{g}
    \\[.5ex]
    \forall k.~ \HoareEq{c}{\chi \land b \land e = k}{e<k}{1}
  \end{array}
}{
    \HoareGe{c';\While{b}{c}}{\pre}{\post}{f}
  }\left[\verb+while+\ \chi\ e\ g\ n \right] 
\end{displaymath}

and the folowing one for exact judgments (=):
\begin{displaymath}
  \infrule{
    \begin{array}{c}
    \HoareGe{c'}{\pre }{\chi \land e = n \land 
      \forall M.~ (\chi\Rightarrow (0\leq e \Leftrightarrow \neg b)) 
        \land (\chi \land \neg b \Rightarrow \post)}
      {\frac{f}{g^n}}
    \\[.5ex]
    \HoareGe{c}{\chi \land b}{\chi}{g}
    \\[.5ex]
    \forall k.~ \HoareEq{c}{\chi \land b \land e = k}{e=k-1}{1}
  \end{array}
}{
    \HoareGe{c';\While{b}{c}}{\pre}{\post}{f}
  }\left[\verb+while+\ \chi\ e\ g\ n \right] 
\end{displaymath}

There is no appropriate rule for $(\leq)$.


\subsubsection{Relational Hoare Logic}

\Syntax  \verb+while+ [\textit{side}] \textit{form} [\textit{form}]

\Description This tactic applies the pRHL verification rules for
loops:
\begin{itemize}
\item the optional argument \textit{side} can be either \verb+{1}+ or
  \verb+{2}+ to indicate the application of one-sided versions of the
  rule. If missing, the two-sided rule for loops is considered.
\item the first \textit{form} argument is mandatory and is used as
  loop invariant. It can refer to variables in both the left and right
  programs.
\item the optional parameter \textit{form} is required (and accepted
  only) in the one-sided application of the rule. This parameter
  corresponds to the decreasing variant expression used to prove loop
  termination.
\end{itemize}



\paragraph{Two-sided version.}
%
\Syntax \verb+while+ \textit{form} 
%
\Description Applies the two-sided RHL rule for while loops, using the
\textit{form} parameter as loop invariant. This tactic requires that
the last instruction of both left and right statements are while loops.
In the rule, $M$ refers to the variables that may be modified by the
loop bodies.

\begin{displaymath}
\infrule{ 
  \begin{array}{c}
    \Equiv{c_2}{c'_2}{I \land e\sidel \land e'\sider}{I \land  e\sidel = e'\sider}\\
    \Equiv{c_1}{c'_1}{\pre}{ I \land e\sidel = e'\sider \land 
      \forall M, (I \land \neg e\sidel \land \neg e'\sider \Rightarrow \post)}
  \end{array}
}{
  \Equiv{c_1;\While{e}{c_2}}{c'_1;\While{e'}{c'_1}}{\pre}{\post}
}
\end{displaymath}

\paragraph{One-sided version.}

\Syntax \verb+while+ \textit{side} \textit{form} \textit{form} 

\Description Applies the one-sided pRHL rule for while loops, using
the first parameter \textit{form} as loop invariant and the second
parameter \textit{form} as a decreasing \textit{variant}
expression. The variant is used to verify the loop termination. The
one-sided rule are described below. Only the left (\verb+{1}+) variant
is shown; the right (\verb+{2}+) variant is symmetric. The expressions
$\forall X,~\varphi$ and $\exists X,~\varphi$ denote, respectively,
universal and existential quantification over the set of variables $X$
modified in the loop body $c$.

\begin{displaymath}
\infrule{
  \begin{array}{c}
    \vdash I \land v \leq b \Rightarrow \neg e  \\
    \Equiv{c}{\Skip}{b=B \land v=C \land e \land I }{b=B \land v<C \land I} \\
    \Equiv{c_1}{c_2}{\pre}{I \land \forall X, (I \land \neg e
      \Rightarrow \post)}
  \end{array}
}{
  \Equiv{c_1;\While{e}{c}}{c_2}{\pre}{\post}
}
\end{displaymath}

\subsection{Reasoning on function invocation: the \rawec{call}
  tactic}

\subsubsection{Hoare Logic}

\subsubsection{Probabilistic Hoare Logic}

\subsubsection{Relational Hoare Logic}


\subsection{Reasoning with \emph{failure events}: the \rawec{fel} tactic}
%
The following rule describes the application of the tactic
$\verb+fel+\ k\ q\ c\ \delta\ F\ P$.  Assume $f$ is defined and
$c_1,c_2$ stands for the splitting of its body at position $n$. Let
$\left\{O_i\right\}_{i=0}^k$ stand for all oracles accessed by any
adversary called at $c_2$. Assume that variables in $F$ can at most be
modified by $\left\{O_i\right\}_{i=0}^k$.
 
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \left\{
    \begin{array}{l}
      \HoareLe{O_i}{\neg F}{F}{h(c)} \\
      \forall c_0,\ \Hoare{O_i}{P\land c=c_0}{c_0 < c} \\
      \forall c_0,\ \forall f_0,\ \Hoare{O_i}{\neg P\land F=f_0 \land c=c_0}{F=f_0 \land c=c_0} \\
    \end{array}\right\}_{i=0}^k\\[5ex]
    \forall m', (\varphi \Rightarrow F \land c\leq q) 
    \qquad 
    \sum_{i=0}^{q-1} h(i) \leq \epsilon 
    \qquad
    \Hoare{c_1}{\true}{\neg F \land c=0}
  \end{array}
}{
  \Prm{f}{m}{\varphi} \leq \epsilon  
} \left[\verb+fel+\ n\ q\ h\ c\ F\ P\right]
\end{displaymath}

\subsection{Proving equivalences by probability computation: 
  the \rawec{bypr} tactic}
%
\subsubsection{Relational Hoare Logic}

\begin{displaymath}
\infrule{
  \forall m_1,\ \forall m_2,\ 
  \Prm{f_1}{m_1}{\varphi_1} = \Prm{f_2}{m_2}{\varphi_2}
}{
  \Equiv{f_1}{f_2}{\pre}{\post}
}
\end{displaymath}


\subsection{Loop reordering}

\Syntax 

\Description 
An invocation of 
$$\left[\verb+reordering+\ i\ (p_{w_1},p_{\mathsf{incr}_1})\
  (p_{w_2},p_{\mathsf{incr}_2})\ \mathcal{I}\ \varolessthan\ (f,f^{-1})\right]$$
%
where $i$ is the iteration expression, $p_{w_1},p_{w_2}$ indicates the
position of the while loops and
$p_{\mathsf{incr}_1},p_{\mathsf{incr}_2}$ the position of the $d$
statement increasing $i$, $b$ only depends on $i$, $c$ does not modify
$i$, $\mathcal{I}:\verb+'a+\to \verb+Bool+$, $\varolessthan:
\verb+'a+\to\verb+'a+\to\verb+Bool+$, $f:\verb+'a+\to\verb+'a+$

 implements the following rule
%
\begin{displaymath}
\infrule{
\begin{array}{c}
  \Equiv{c_1}{c_2}{\pre}{\varphi \land \left| 
      \begin{array}{l}
        (\mathcal{I}\,i \Rightarrow\forall j,~\mathcal{I}\,j
        \Rightarrow i<j) \land  
      \\
      \varphi \land
      \\
      \forall j.~\neg\mathcal{I}\,j\Rightarrow \neg\,j \land
      \\
      \forall M.~ (\varphi\Rightarrow Q) \land
    \end{array}
    \right.
  }
  \\
  \mbox{$f$ bijection on $\mathcal{I}$}
  \\
  \forall z_1\,z_2\Equiv
  {c\subst{i}{f\,z_1};c\subst{i}{f\,z_2}}
  {c\subst{i}{f\,z_2};c\subst{i}{f\,z_1}}
  {
    \begin{array}{l}
      \mathcal{I}\,z_1 \land \mathcal{I}\,z_2 \land z_1\varolessthan
      z_2 
      \\ 
      \land f\, z_2\varolessthan f\, z_1\land \varphi
    \end{array}
  }
  {\varphi}
  \\
  \Equiv{c}{c}
  {\mathcal{I}\,i \land i\sidel=i\sider \land \varphi}
  {\varphi}
\end{array}
}{
\Equiv{c_1;\While{b}{(c(i);d)}}{c_2;\While{b}{(c(f\,i);d)}}{\pre}{\post}
}
\end{displaymath}


\section{Tacticals}


\section{Automated Tactics}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "easycrypt"
%%% End: 
