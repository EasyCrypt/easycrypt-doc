% !TeX root = easycrypt.tex

%% TODO (Francois): For index, rather than \texttt, use \rawec and make a class of keywords for tactics and tacticals

\chapter{Writing Proofs}

\EC comes with a proof engine that allows to state, in the \EC
underneath formalism, properties about the user defined programs
and to prove them.
%
Proofs are built interactively, starting from final goal, by applying
\emph{tactics} that transform a goal (the property we want to prove)
to a set of subsequent goals (the subgoals) s.t. the latter logical
implies the former.
%
This process is repeated iteratively up to the point where all the
subgoals are trivial and can be solved by the system.

This chapter is about the description of this proof engine, and is
structured as follow. We first define the notion of goals and show
how it relates to the \EC formalism. We then introduce the notion
of tactics as logically valid goal transformers. Finally, a listing
of all the existing tactics, along with their detailed descriptions,
is given.

\section{The proof engine}

The proof engine deals with \emph{judgments} or \emph{goals} of the form
$\Env; \Gamma \vdash \phi$ where $\Env$ is the (global) environments,
$\Gamma$ is a set of local facts and $\phi$ is the formula we want
to prove. Here is an example of such a judgment:

\begin{center}
$\Int; x, y , z: \tint, x \le y \vdash x + z \le y + z$.
\end{center}

It states that in the \emph{environment} ($\Env$) solely composed of the
theory $\Int$, having three local variables $x, y, z$ of type $\tint$ along
with the fact $x \le y$ (the \emph{context} $\Gamma$), we are interested
in proving $x + z \le y + z$.

\medskip

On top on this, a set of \emph{deduction rules} is given. They
describe how one can derive a judgment $\Env; \Gamma \vdash \phi$ given
that a set of prerequisites (or \emph{premises}) are fulfilled. The general
form of such a rule is given as follow:

\begin{displaymath}
 \infrule{A_1 \cdots A_n}{\Env; \Gamma \vdash \phi}
\end{displaymath}

It has to be read as: \emph{given that $A_1 \cdots A_n$ are derivable, then
so is $\Env, \Gamma \vdash \phi$}. We give three examples of such deduction
rules:

\begin{displaymath}
 \infrule
         {\Env; \Gamma \vdash \phi_1 \quad
          \Env; \Gamma \vdash \phi_1 \Rightarrow \phi_2}
         {\Env; \Gamma \vdash \phi_2}
         {\rname{MP}}
 \quad\quad
 \infrule
         {\Env; \Gamma, \phi_1 \vdash \phi_2}
         {\Env; \Gamma \vdash \phi_1 \Rightarrow \phi_2}
         {\rname{$\Rightarrow$-I}}
 \quad\quad
 \infrule{ }{\Env; \Gamma, \phi, \Delta \vdash \phi}{\rname{Ax}}
\end{displaymath}

The first, the \emph{modus ponens}, states that one can derive
$\Env; \Gamma \vdash \phi_2$ given that $\Env; \Gamma \vdash \phi_1
\Rightarrow \phi_2$ and $\Env; \Gamma \vdash \phi_1$ are derivable.
%
The next provides a way for deriving $\phi_1 \Rightarrow \phi_2$ from
a derivation of $\phi_2$, but with a context augmented by $\phi_1$.
%
The last states that $\Env; \Gamma, \phi, \Delta \vdash \phi$ is derivable as-is.

\medskip

Combining these deduction rules, it is possible to build a tree rooted by
a judgment $\Env; \Gamma \vdash \phi$ and with leaves composed of deduction
rules with no premises (as the third one in the previous example). Such a
tree forms a \emph{proof} of $\Env; \Gamma \vdash \phi$.
%
For instance, Figure~\ref{fig:LJproof} gives a proof of
%
\begin{center}
 $\Env; b_1, b_2 : \tbool \vdash (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2$
\end{center}

\begin{figure}
  \begin{displaymath}
    \infrule
      {\infrule{ }{\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_1 \Rightarrow b_2} \quad
       \infrule{ }{\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_1}}
      {\infrule
        {\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2, b_1 \vdash b_2}
        {\infrule
           {\Env; b_1, b_2 : \tbool, b_1 \Rightarrow b_2 \vdash b_1 \Rightarrow b_2}
           {\Env; b_1, b_2 : \tbool \vdash (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2}}}
  \end{displaymath}

  \caption{\label{fig:LJproof} Proof tree of
    $\Env; b_1, b_2 : \tbool \vdash
        (b_1 \Rightarrow b_2) \Rightarrow b_1 \Rightarrow b_2$}
\end{figure}

\section{Ambient Logic (Guillaume)}

\ambientDesc%prints the description of all tactics see ambient.tex
  %to modify them

\section{Program Logics (C\'esar)}

\subsection{Reasoning about random samplings: the \rawec{rnd} tactic}
%
\subsubsection{Hoare Logic}
\index{hoare}{Program Reasoning!rnd@\rawec{rnd}}

\subsubsection{Probabilistic Hoare Logic}
\index{phl}{Program Reasoning!rnd@\rawec{rnd}}
\Syntax 
\verb+rnd+ (\textit{formula} $|$ \_ ) (\textit{formula} $|$ \_ )

\Description
the first optional parameter $p$ is a computable predicate (i.e., \verb+'a cPred+)
(i.e., \verb+'a -> bool+ ). Assume $d$ of type \verb+A Distr.distr+. 
\begin{displaymath}
\begin{array}{c}
  \infrule{
    \hoareS{c}{\pre}{\mu\, d\, p \leq f \land 
      (\forall v\in \mathsf{support}(d).~ \post\subst{x}{v} \Rightarrow p\, v)}
  }{
    \bdHoareSle{c;\Rand{x}{d}}{\pre}{\post}{f}
  }\left[\verb+rnd+\ p\right]
\\[4ex]
\end{array}
\end{displaymath}
If $p$ is not given then the tool attempts to build it from $\post$
(not implemented yet).

For lower-bounded and exact probabilistic judgments the tactic
additionally accepts an optional parameter $g$ of type \verb+real+
representing a bound:
\begin{displaymath}
  \infrule{
    \bdHoareSge{c}{\pre}{\mu\, d\, p \geq g \land 
      (\forall v\in \mathsf{support}(d).~ p\, v \Rightarrow \post\subst{x}{v} )}{\frac{f}{g}} 
  }{
    \bdHoareSge{c;\Rand{x}{d}}{\pre}{\post}{f}
  }\left[\verb+rnd+\ p\ g\right]
\end{displaymath}
%
\begin{displaymath}
  \infrule{
    \bdHoareSeq{c}{\pre}{\mu\, d\, p = g \land 
      (\forall v\in \mathsf{support}(d).~ p\, v \Leftrightarrow \post\subst{x}{v} )}{\frac{f}{g}} 
  }{
    \bdHoareSeq{c;\Rand{x}{d}}{\pre}{\post}{f}
  }\left[\verb+rnd+\ p\ g\right]
\end{displaymath}
%
If $g$ is not given then $g=f$ in the rule.

\subsubsection{Relational Hoare Logic}
\index{prhl}{Program Reasoning!rnd@\rawec{rnd}}

\subsection{Reasoning about sequential composition: the \rawec{seq} tactic}
%
\subsubsection{Hoare Logic}
\index{hoare}{Program Reasoning!seq@\rawec{seq}}

\subsubsection{Probabilistic Hoare Logic}
\index{phl}{Program Reasoning!seq@\rawec{seq}}
\Syntax 
\verb+app+ \verb+[>>|<<]+ \textit{num} \textit{formula} (
[\textit{formula} \verb+|+ \textit{formula} \textit{formula}
\textit{formula} \textit{formula}]

\Description
Direction \verb+<<+ by default.
The first formula is the intermediate predicate.
Assume $s_2$ is at program position $n$.

For upper bounded judgments, the most general variant of the
\verb+app+ rule (i.e., when four bounds are given as parameters) implements the following rule:
\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \bdHoareSle{s1}{P}{R}{f_1} \qquad \bdHoareSle{s2}{R}{Q}{f_2}
      \\
      \bdHoareSle{s1}{P}{R}{g_1} \qquad \bdHoareSle{s2}{R}{Q}{g_2}
      \\
      f_1 f_2 + g_1 g_2 \leq f 
    \end{array}
  }{
    \bdHoareSle{s1;s2}{P}{Q}{f}
  }
\end{displaymath}
%
If no argument is given then the following rule is applied:
\begin{displaymath}
  \infrule{
    \hoareS{s1}{P}{R} \qquad \bdHoareSle{s2}{R}{Q}{f}
  }{
    \bdHoareSle{s1;s2}{P}{Q}{f}
  }\left[\verb+app+\ n\ R\right]
\end{displaymath}
%
\warningbox{Which, if preferred, can be rewritten to:}
\begin{displaymath}
  \infrule{
    \hoareS{s1}{P}{\lambda m. \Prm{s_2}{m}{Q}\leq f} \qquad 
  }{
    \bdHoareSle{s1;s2}{P}{Q}{f}
  }\left[\verb+app+\ n\ R\right]
\end{displaymath}



For lower bounded and exact judgments, the app tactic implements the following rules

\begin{displaymath}
\begin{array}{c}
  \infrule{
    \bdHoareSge{s1}{P}{R}{f/g} \qquad \bdHoareSge{s2}{R}{Q}{g}
  }{
    \bdHoareSge{s1;s2}{P}{Q}{f}
  }\left[\verb+app+\ n\ R\ g\right]
\\[4ex]
  \infrule{
    \bdHoareSge{s1}{P}{R}{g} \qquad \bdHoareSge{s2}{R}{Q}{f/g}
  }{
    \bdHoareSge{s1;s2}{P}{Q}{f}
  }\left[\verb+app>>+\ n\ R\ g\right]
\end{array}
\end{displaymath}
%
The second parameter (optional) is a real number representing a bound (only supported for $=$ and $\geq$).
%
Similar rules hold for $=$. If the parameter $g$ is not given then
$g=f$ in the rule. 

\subsubsection{Relational Hoare Logic}
\index{prhl}{Program Reasoning!seq@\rawec{seq}}

\subsection{Reasoning about conditionals: the \rawec{if} tactic}
%
\subsubsection{Hoare and Probabilistic Hoare Logic}
\index{hoare}{Program Reasoning!if@\rawec{if}}
\index{phl}{Program Reasoning!if@\rawec{if}}
(similar to probabilistic Hoare \verb+if+ tactic)
\begin{displaymath}
\begin{array}{c}
  \infrule{
    \bdHoareSle{c_1}{\pre \land b}{\post}{f}\qquad
    \bdHoareSle{c_2}{\pre \land \neg b}{\post}{f}
  }{
    \bdHoareSle{\Cond{b}{c_1}{c_2}}{\pre}{\post}{f}
  }\left[\verb+if+ \right] 
\\[4ex]
\end{array}
\end{displaymath}
Similar rules hold for $=,\geq$.

\subsubsection{Relational Hoare Logic}
\index{prhl}{Program Reasoning!if@\rawec{if}}

\subsection{Computing weakest preconditions: the \rawec{wp} tactic}
%
\subsubsection{Hoare Logic}
\index{hoare}{Program Reasoning!wp@\rawec{wp}}

\subsubsection{Probabilistic Hoare Logic}
\index{phl}{Program Reasoning!wp@\rawec{wp}}
\Syntax \verb+wp+

\Description
Assuming \verb+wp+ complete (weakest) and $c$ is straight-line code,
$\bdHoareSeq{c}{\mathsf{wp}(c,\post)}{\post}{1}$, plus sequential
composition rule, we have:
\begin{displaymath}
  \infrule{
    \bdHoareSle{c_1}{\pre }{\mathsf{wp}(c_2,\post)}{f}
  }{
    \bdHoareSle{c_1;c_2}{\pre}{\post}{f}
  }\left[\verb+wp+ \right] 
\end{displaymath}
Similar rules hold for $=,\geq$.

\subsubsection{Relational Hoare Logic}
\index{prhl}{Program Reasoning!wp@\rawec{wp}}

\subsection{Concluding proofs of programs: the \rawec{skip} tactic}
\index{hoare}{Program Reasoning!skip@\rawec{skip}}
\index{phl}{Program Reasoning!skip@\rawec{skip}}
\index{prhl}{Program Reasoning!skip@\rawec{skip}}
%

\subsection{Simplifying conditionals: the \rawec{condt,condf} tactic}
%
\subsubsection{Probabilistic Hoare Logic}
\index{tactics}{probabilistic Hoare logic!condt@\rawec{condt}}
\index{tactics}{probabilistic Hoare logic!condf@\rawec{condf}}

\subsection{Reasoning about abstract adversaries: the \rawec{fun} tactic}

\subsubsection{Relational Hoare Logic}

\Syntax \verb+fun+ formula

\Description
The formula given as parameter represents the general oracle
invariant. 

The tactic implements the following rule:
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \pre \Rightarrow \chi \land \glob_A = \glob_B \land \vec{p}_A=\vec{p}_B
    \\[.5ex]
    \chi\land\glob_A=\glob_B\land\result_A=\result_B\Rightarrow\post
    \\ 
    \equivF{O_i}{O_i'}{\chi\land
      \vec{p}_{O_i}=\vec{p}_{O'_i}}{\chi\land \result_{o_i}=\result_{o'_i}}
  \end{array}
}{
  \equivF{A}{B}{\pre}{\post}
} [\verb+fun+~\chi]
\end{displaymath}
%
where $\vec{p}_f$ represent the formal parameters of a function
(abstract adversary or oracle) $f$, $\result_f$ represents the result of
a function (abstract adversary or oracle) $f$, $\left\{O_i\right\}_{i=0}^k$ and
$\left\{O'_i\right\}_{i=0}^k$ are the oracles of the abstract adversaries $A$ and
$B$, $\glob_A$ and $\glob_B$ represent the global state of the abstract
adversaries $A$ and $B$, ...

\subsubsection{Probabilistic Hoare Logic}
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \pre \Rightarrow \chi  \qquad 
    \chi \Leftrightarrow\post
    \\[.5ex]
    \bdHoareSeq{O_i}{\chi}{\chi}{1}
  \end{array}
}{
  \bdHoareSeq{A}{\pre}{\post}{1}
} [\verb+fun+~\chi]
\end{displaymath}

\subsubsection{Hoare Logic}
\begin{displaymath}
\infrule{
  \begin{array}{c}
    \pre \Rightarrow \chi  \qquad 
    \chi \Rightarrow\post
    \\[.5ex]
    \hoareS{O_i}{\chi}{\chi}
  \end{array}
}{
  \hoareS{A}{\pre}{\post}
} [\verb+fun+~\chi]
\end{displaymath}

\subsection{Weakening judgements: The \rawec{conseq} rule}

\Syntax \verb+conseq+ \textit{formula} \textit{formula}
\subsubsection{Hoare Logic}

\begin{displaymath}
\infrule{
  \hoareS{c}{\pre'}{\post'} \qquad \pre\Rightarrow\pre' \qquad  \post'\Rightarrow\post
}{
  \hoareS{c}{\pre}{\post}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}

\subsubsection{Probabilistic Hoare Logic}
\begin{displaymath}
\infrule{
  \bdHoareSle{c}{\pre'}{\post'}{\delta} \qquad \pre\Rightarrow\pre' \qquad  \post\Rightarrow\post'
}{
  \bdHoareSle{c}{\pre}{\post}{\delta}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}

\begin{displaymath}
\infrule{
  \bdHoareSeq{c}{\pre'}{\post'}{\delta} \qquad \pre\Rightarrow\pre' \qquad  \post\Leftrightarrow\post'
}{
  \bdHoareSeq{c}{\pre}{\post}{\delta}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}

\begin{displaymath}
\infrule{
  \bdHoareSge{c}{\pre'}{\post'}{\delta} \qquad \pre\Rightarrow\pre' \qquad  \post'\Rightarrow\post
}{
  \bdHoareSge{c}{\pre}{\post}{\delta}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}

\warningbox{(changing the bound is not yet implemented)}

\subsubsection{Relational Hoare Logic}

\begin{displaymath}
\infrule{
  \equivF{c_1}{c_2}{\pre'}{\post'} \qquad \pre\Rightarrow\pre' \qquad  \post'\Rightarrow\post
}{
  \equivF{c_1}{c_2}{\pre}{\post}
}\left[\verb+conseq+~ \pre'~ \post' \right]
\end{displaymath}


\subsection{Reasoning about function calls: the \rawec{call} tactic}
%
\subsubsection{Hoare Logic}
\index{hoare}{Program Reasoning!call@\rawec{call}}
\Syntax \verb+call+ formula formula
\Description

Let $p$ stand for the formal parameters of function $f$, $\result_f$
the result variable of function $f$, and $\vec{m}$ the set of
variables modifiable by $f$.
\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \hoareS{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}
      }
      \\[.5ex]
      \hoareS{f}{\pre_f}{\post_f}
    \end{array}
  }{
    \hoareS{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}
  }\left[\verb+call+~ \pre_f~ \post_f \right]
\end{displaymath}



\subsubsection{Probabilistic Hoare Logic}
\index{phl}{probabilistic Hoare logic!call@\rawec{call}}

\Syntax \verb+call+ formula formula [formula]

\Description

Let $p$ stand for the formal parameters of function $f$, $\result_f$
the result variable of function $f$, and $\vec{m}$ the set of
variables modifiable by $f$.
\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \hoareS{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}
      }
      \\[.5ex]
      \bdHoareSle{f}{\pre_f}{\post_f}{\delta}
    \end{array}
  }{
    \bdHoareSle{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}{\delta}
  } \left[\verb+call+~ \pre_f~ \post_f \right]
\end{displaymath}

\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \bdHoareSeq{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}}{\frac{\delta}{\delta'}}
    \\[.5ex]
    \bdHoareSeq{f}{\pre_f}{\post_f}{\delta'}
  \end{array}
  }{
    \bdHoareSeq{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}{\delta}
  } \left[\verb+call+~ \pre_f~ \post_f~ \delta' \right]
\end{displaymath}

\begin{displaymath}
  \infrule{
    \begin{array}{c}
      \bdHoareSge{c}{\pre}{\pre_f\subst{\vec{p}}{\vec{y}} \land
        \forall v.~ \forall \vec{z}.~ 
        \post_f\subst{\result_f}{v}\subst{\vec{m}}{\vec{z}}
        \Rightarrow \post\subst{x}{v}\subst{\vec{m}}{\vec{z}}}
      {\frac{\delta}{\delta'}}
    \\[.5ex]
    \bdHoareSge{f}{\pre_f}{\post_f}{\delta'}
  \end{array}
  }{
    \bdHoareSge{c;\Call{x}{f}{\vec{y}}}{\pre}{\post}{\delta}
  } \left[\verb+call+~ \pre_f~ \post_f ~\delta' \right]
\end{displaymath}

If no parameter is given for the lower-bounded and exact judgements
then $\delta'=1$.

\warningbox{New tactics, needs structuring.}

\subsection{: the \rawec{hoare,hoare\_bd,pr\_bounded,bd\_eq}}

\subsubsection{Possibilistic and probabilistic Hoare Logic}
\Syntax \verb+hoare+, \verb+hoare_bd+
allows to switch between possibilistic and probabilistic logics
according to these rules:
\begin{displaymath}
\begin{array}{cc}
\infrule{
  \hoareS{c}{\pre}{\neg \post} \quad f = 0
}{
  \bdHoareSeq{c}{\pre}{\post}{f}
}
&
\infrule{
  \bdHoareSeq{c}{\pre}{\neg\post}{0}
}{
  \hoareS{c}{\pre}{\post}
}
\end{array}
\end{displaymath}

\Syntax \verb+pr_bounded+
discharges goals by applying trivial probability properties:
\begin{displaymath}
\begin{array}{cc}
\infrule{
}{
  \bdHoareSle{c}{\pre}{\post}{1}
}
&
\infrule{
}{
  \bdHoareSge{c}{\pre}{\post}{0}
}
% \\[3ex]
% \infrule{
% }{
%   \Prm{c}{m}{\post} \leq 1
% }
% &
% \infrule{
% }{
%   \Prm{c}{m}{\post} \geq 0
% }
\end{array}
\end{displaymath}

\Syntax \verb+bd_eq+
\begin{displaymath}
\begin{array}{cc}
\infrule{
  \bdHoareSeq{c}{\pre}{\post}{f}
}{
  \bdHoareSle{c}{\pre}{\post}{f}
}
&
\infrule{
  \bdHoareSeq{c}{\pre}{\post}{f}
}{
  \bdHoareSge{c}{\pre}{\post}{f}
}
\end{array}
\end{displaymath}


\subsection{\rawec{Denot} tactics}
%
\subsubsection{Probabilistic Hoare Logic}

\begin{displaymath}
\infrule{
    \pre 
    \qquad 
    \chi\Rightarrow\post 
    \qquad 
    \bdHoareSle{f}{\pre}{\post}{\delta}
}{
  \Prm{c}{m}{\chi} \leq \delta
}\left[\verb+hoare_deno+\ \pre\ \post\right]
\end{displaymath}

\begin{displaymath}
\infrule{
    \pre 
    \qquad 
    \post\Leftrightarrow \chi 
    \qquad 
    \bdHoareSeq{f}{\pre}{\post}{\delta}
}{
  \Prm{c}{m}{\chi} = \delta
}\left[\verb+hoare_deno+\ \pre\ \post\right]
\end{displaymath}

\begin{displaymath}
\infrule{
    \pre 
    \qquad 
    \post\Rightarrow\chi
    \qquad 
    \bdHoareSge{f}{\pre}{\post}{\delta}
}{
  \delta \leq \Prm{c}{m}{\chi}
}\left[\verb+hoare_deno+\ \pre\ \post\right]
\end{displaymath}


\subsubsection{Relational Hoare Logic}

\begin{displaymath}
\infrule{
  \equivF{c_1}{c_2}{\pre}{\post} 
  \qquad
  \pre
  \qquad
  \post \Rightarrow \chi_1 \Rightarrow \chi_2
}{
  \Prm{c_1}{m_1}{\chi_1} \leq \Prm{c_2}{m_2}{\chi_2}
}\left[\verb+deno+\ \pre\ \post\right]
\end{displaymath}

\begin{displaymath}
\infrule{
  \equivF{c_1}{c_2}{\pre}{\post} 
  \qquad
  \pre
  \qquad
  \post \Rightarrow (\chi_1 \Leftrightarrow \chi_2)
}{
  \Prm{c_1}{m_1}{\chi_1} = \Prm{c_2}{m_2}{\chi_2}
}\left[\verb+deno+\ \pre\ \post\right]
\end{displaymath}


\subsection{Some \textsf{Pr} tactics: \rawec{pr\_false},
  \rawec{pr\_or}}

\begin{displaymath}
\infrule{
  \false \Rightarrow \post
}{
  \Prm{c}{m}{\post} = 0
}
\end{displaymath}

\begin{displaymath}
\infrule{
\Prm{c}{m}{\pre} \land
  \Prm{c}{m}{\post} \land \Prm{c}{m}{\pre \wedge \post} = \delta
}{
  \Prm{c}{m}{\pre \vee \post} = \delta
}
\end{displaymath}


\subsection{The \rawec{inline} tactic}
%

\subsection{The \rawec{swap} tactic}
%
\Syntax \verb+swap+ [\textit{side}] \textit{swap\_pos}

\textbf{where:} 
\begin{tabular}[t]{l}
  \textit{swap\_pos} ::= 
  \textit{n} \textit{n} \textit{n} $\mid$ \textit{n} \textit{z} $\mid$ [\textit{n}:\textit{n}] \textit{z}
  \\
  $n$ a natural number
  \\
  $z$ an integer number
\end{tabular}
  

The tactic [\verb+swap+ $p_1$ $p_2$ $p_3$] swaps the code between
positions $p_1$ and $p_2$ with the code between positions $p_2$ and
$p_3$. That is, assuming that $c_1$ and $c_2$ are syntactically
independent, that $c_1$ is between positions $p_1$ and $p_2$ and that
$c_2$ is between positions $p_2$ and $p_3$, the tactic implements the
following rule:
\begin{displaymath}
\infrule{
  \hoareS{c;c_2;c_1;c_3}{\pre}{\post}
}{
  \hoareS{c;c_1;c_2;c_3}{\pre}{\post}
} [\verb+swap+\ p_1\ p_2\ p_3]
\end{displaymath}

If $k$ is positive (negative) then [\verb+swap+ $k$] moves the first
(last) instruction $k$ positions forwards (backwards). Similarly,
[\verb+swap+ $i$ $k$] moves the $i^{th}$ instruction forwards or
backwards, and [\verb+swap+ $[i_1:i_2]$ $k$] moves the instructions
between positions $i_1$ and $i_2$.


\subsection{Reasoning about loops: the \rawec{while} tactic}
%
\subsubsection{Probabilistic Hoare Logic}
\index{phl}{Program Reasoning!while@\rawec{while}}

\Syntax \verb+while+ \textit{formula} \textit{formula} 
[\textit{formula} \textit{formula}]
%

\Description
%
The first formula is the loop invariant.
%
The second one is a variant expression. 
%
The third one is a real expression bound $g$ and the fourth one an
integer expression $n$.
%
If $g$ is not given then it is interpreted as $g=1$, and the fourth
formula is ignored, otherwise required. $M$ stands for the variables
that may be modified by $c$.

\begin{displaymath}
  \infrule{
    \begin{array}{c}
    \bdHoareSge{c'}{\pre }{\chi \land 
      \forall M.~ (\chi \land 0 \leq e \Rightarrow \neg b)  \land
      \chi \land \neg b \Rightarrow \post}{f} 
    \\[.5ex]
    \forall k.~ \bdHoareSeq{c}{\chi \land b \land e = k}{\chi \land e
      < k}{1}
  \end{array}
}{
    \bdHoareSge{c';\While{b}{c}}{\pre}{\post}{f}
  }\left[\verb+while+\ \chi\ e \right] 
\end{displaymath}
Similarly for (=).

For an arbitrary bound $g$ the following rule generalizes the one
above for lower bounded judgments:
\begin{displaymath}
  \infrule{
    \begin{array}{c}
    \bdHoareSge{c'}{\pre }{\chi \land e \leq n \land 
      \forall M.~ (\chi \land 0 \leq e \Rightarrow \neg b) 
      \land (\chi \land \neg b \Rightarrow \post)}{\frac{f}{g^n}} 
    \\[.5ex]
    \bdHoareSge{c}{\chi \land b}{\chi}{g}
    \\[.5ex]
    \forall k.~ \bdHoareSeq{c}{\chi \land b \land e = k}{e<k}{1}
  \end{array}
}{
    \bdHoareSge{c';\While{b}{c}}{\pre}{\post}{f}
  }\left[\verb+while+\ \chi\ e\ g\ n \right] 
\end{displaymath}

and the folowing one for exact judgments (=):
\begin{displaymath}
  \infrule{
    \begin{array}{c}
    \bdHoareSge{c'}{\pre }{\chi \land e = n \land 
      \forall M.~ (\chi\Rightarrow (0\leq e \Leftrightarrow \neg b)) 
        \land (\chi \land \neg b \Rightarrow \post)}
      {\frac{f}{g^n}}
    \\[.5ex]
    \bdHoareSge{c}{\chi \land b}{\chi}{g}
    \\[.5ex]
    \forall k.~ \bdHoareSeq{c}{\chi \land b \land e = k}{e=k-1}{1}
  \end{array}
}{
    \bdHoareSge{c';\While{b}{c}}{\pre}{\post}{f}
  }\left[\verb+while+\ \chi\ e\ g\ n \right] 
\end{displaymath}


There is no appropriate rule for $(\leq)$.



\section{Tacticals}


\section{Automated Tactics}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "easycrypt"
%%% End: 
