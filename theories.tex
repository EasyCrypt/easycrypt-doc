% !TeX root = easycrypt.tex

\chapter{The Languages of \EasyCrypt\label{chap:theories}}
Definitions and lemmas can be grouped in theories, that can be imported to
provide new language functionalities as required for a particular proof.
Currently, \EasyCrypt supports user-defined types and operators
(Section~\ref{sec:types}) and user-defined distributions
(Section~\ref{sec:distributions}). In addition, theories can declare modules and
functors (Section~\ref{sec:modules}), used to represent schemes, oracles and
experiments, as well as abstract types for such modules, which can be used to
modularize proofs or represent abstract adversaries. Finally, theories can be
cloned and refined (Section~\ref{sec:cloning}), which allows the user to
consider small variants of a theory without having to create a new one from
scratch, or to consider concrete implementation details only when necessary for
the proof.


\section{The Expression Language\label{sec:types}}
At the core of any \EasyCrypt specification is a collection of types and functional
operators on those types. Formally, \EasyCrypt types are \emph{non-empty} sets of
values, and operators are \emph{mathematical} functions between them.

\warningbox{Currently, the easiest way to define types and operators is to
declare them abstractly and specify them using axioms. It is \emph{very}
important for the consistency of the logical context to remember that types are
\emph{always} assumed to be non-empty, and that operators are total mathematical
functions when writing such definitions.}

The \EasyCrypt type system supports polymorphic, higher-order types: the type of
lists can be declared independently of the type of their contents, and operators
can take and return other operators. We first describe the various built-in
types and relevant operators before moving on to explaining how new definitions
can be built from them.

\subsection{Built-Ins}
The language is equipped with a few built-in types\footnote{This is only to
bridge our language with \WhyThree's logic and avoid the introduction of
indirection layers in the proof obligations sent to the SMT solvers: all these
built-in types could in theory be defined in \EasyCrypt itself.}:
\begin{itemize}\itemsep-.5em
\item the \rawec{unit}\index{easycrypt}{types!unit@\ec{unit}} type, which
        contains a unique element
        \rawec{tt}\index{easycrypt}{constants!tt@\ec{tt : unit}},
\item the \rawec{bool} type of booleans,
\item the \rawec{int} type of arithmetic integers (in $\mathbb{Z}$),
\item the \rawec{real} type of real numbers (in $\mathbb{R}$).
\end{itemize}

Some symbols are defined, declared or imported from \WhyThree in the
corresponding libraries, and are discussed further in the library documentation.

\subsubsection*{The \rawec{bool} type}
\index{easycrypt}{types!bool@\ec{bool}}
Boolean expression terms can be built from the constant
\rawec{true}\index{easycrypt}{constants!true@\ec{true : bool}} and
\rawec{false}\index{easycrypt}{constants!true@\ec{true : bool}}, in combination
with operators for logical conjunction and disjunction
(\rawec{/\\}\index{easycrypt}{operators!and@\ec{(/\\) : bool -> bool -> bool}} and
\rawec{\\\/}\index{easycrypt}{operators!or@\ec{(\\/) : bool -> bool -> bool}}),
short-circuiting conjunction and disjunction
(\rawec{\&\&}\index{easycrypt}{operators!anda@\ec{(&&) : bool -> bool -> bool}}
and
\rawec{||}\index{easycrypt}{operators!ora@\ec{(''ora) : bool -> bool -> bool}}),
and xor
(\rawec{\^\^}\index{easycrypt}{operators!xor@\ec{(\^\^) : bool -> bool -> bool}}).
Additional operators and simple rewriting rules are made available in the
\rawec{Bool} theory.

\subsubsection*{The \rawec{int} type}
\index{easycrypt}{types!int@\ec{int}}
Integer expression terms can be built from numerical constants between $0$ and
$2^{62} - 1$ (non-negative OCaml integers), in combintation with operators for
unary negation (\rawec{-}), and all arithmetic and comparison (\rawec{+},
\rawec{-}, \rawec{*}, \rawec{/}, \rawec{\%}, \rawec{^}, \rawec{=}, \rawec{<},
\rawec{<=}, \rawec{>}, \rawec{>=} \ldots). It is necessary to import the integer
library (via \rawec{require import Int.}, see Section~\ref{sec:cloning}) to have
access to these operators. Since this type is identified with the \WhyThree type
of integers, all \WhyThree lemmas on it can be used by the SMT solvers, and are
accessible by name for use in interactive proofs. We will eventually be
providing uniformly named wrappers and algebraic structures.

\subsubsection*{The \rawec{real} type}
\index{easycrypt}{types!real@\ec{real}}
Real expression terms can be built from integer constants suffixed with a
\rawec{\%r} (for example, \rawec{0\%r} is 0 in the \rawec{real} type), in
combination with the same operators available on integers. It is necessary to
import the library (using \rawec{require import Real.}) to access these
operators in scope. This type is also identified with the \WhyThree type of
reals, which provides some lemmas and tighter integration with the underlying
theories, but SMT solvers often have very limited support for real numbers and
will often fail to prove seemingly trivial results, with Z3 often outperforming
other solvers. We will be working on enriching the library of lemmas available
in this theory to allow more complex interactive proofs when automation fails.

\warningbox{\rawec{(1/2)\%r} and \rawec{1\%r/2\%r} are very different
expressions. The former evaluates to $0$ (the division is in $\mathbb{Z}$, and
the result ($0$) is interpreted in $\mathbb{R}$) whereas the latter evaluates to
$0.5$ (the operands are interpreted and the operator is applied in
$\mathbb{R}$). Eventually, we will introduce notations for scoping that should
allow less cluttered real expressions.}

\subsection{Types}
From these base types, many more can be built. \EasyCrypt allows the user to declare
 (polymorphic) abstract types, and combine existing types into tuple types or
function types.

\subsubsection*{Tuple types}
Given two types \ec{'t} and \ec{'t'}, \ec{('t * 't')} denotes the type of pairs
of elements of \ec{'t} and \ec{'t'}. More generally, the product can be iterated
to produce tuple types of arbitrary arity. For example, Listing~\ref{lst:tuples}
declares two abstract types, \ec{pkey} and \ec{skey}, and then defines a type
\ec{keypairs} as the type of pairs of elements of \ec{pkey} and \ec{skey}.

\warningbox{Types \ec{('t * 't' * 't'')}, \ec{(('t * 't') * 't'')} and
\ec{('t * ('t' * 't''))} are distinct (but isomorphic).}

\begin{easycrypt}[label={lst:tuples}]{A simple tuple type.}
type pkey.
type skey.

type keypair = (pkey * skey).
\end{easycrypt}

\subsubsection*{Function types}
Given two types \ec{'t} and \ec{'t'}, \ec{'t -> 't'} is the type of total
functions from \ec{'t} to \ec{'t'}. Listing~\ref{lst:functions} illustrates such
a type definition, and the use of polymorphism, by defining a polymorphic type
of predicates. For any type \rawec{'a}, we construct a type \rawec{'a cpred} of
functions from \rawec{'a} to \rawec{bool}.

\begin{easycrypt}[label={lst:functions}]{A simple polymorphic function type.}
type 'a cpred = 'a -> bool.
\end{easycrypt}

\subsubsection*{Type application}
Polymorphic types can be instantiated with particular type parameters if
desired. For example, sets of integers could be defined as predicates on
integers as shown in Listing~\ref{lst:type_app}. Using the polymorphic type of
predicates defined in Listing~\ref{lst:functions}, we simply apply it to
\ec{int} to instatiate \rawec{'a} with \rawec{int}.

\begin{easycrypt}[label={lst:type_app}]{A simple type application.}
type intSet = int cpred.
\end{easycrypt}

\subsubsection*{On currying}
It is standard practice to write functions of several arguments in curried form,
where applying the function symbol to the first argument returns a function that
takes the second argument, and so on. This very easily allows the user to
partially apply functions to fix some of their arguments. This does not restrict
or increase the expressivity of the language in any way, although it may
initially cause some syntax issues for users unfamiliar with the concept. When
applying a curried function to several arguments, the arguments should be
separated by spaces rather than the more standard commas.
Listing~\ref{lst:currying} illustrates this.

\begin{easycrypt}[label={lst:currying}]{Currying and partial function application.}
op log: int -> int -> int.
op log2: int-> int = log_curried 2.

op log_pair: (int * int) -> int.
op log2_pair (n:int): int = log (2,n).
\end{easycrypt}

The \rawec{log} is declared as an integer function of two (curried) integer
arguments, and the log base 2, \rawec{log2}, is defined as its partial
application to 2. This definition could have been equivalently written as
follows.
\begin{easycrypt}[frame=none]{}
op log2 (n:int): int = log 2 n.
\end{easycrypt}
Contrasting with the curried form described above, \rawec{log_pair} is declared
as an integer function of a single argument (whose type is a pair type).
Partial application is slightly more verbose, but the syntax of application may
look more familiar to imperative programmers.

\subsection{Terms}
Under the assumption that all abstract types are inhabited, all types that can
be constructed using the operations above are also inhabited. We now show how
terms of each of the types can be constructed, serving as witnesses. The partial
applications in Listing~\ref{lst:currying} are small examples of building terms
of type \rawec{int -> int} given terms of other types.
%The reader eager to
%perform proofs can start drawing parallels between this subsection and the term
%reduction (computation) rules at the beginning of Chapter~\ref{chap:tactics}.
%TODO: More precise cross-reference

We provide almost all standard constructions of the polymophic
$\lambda$-calculus, with the notable exception of pattern-matching and fixpoint
constructions, since we do not currently support inductive types or recursion
directly. This limitation is easily worked around by axiomatically defining the
recursion and induction principle whenever declaring a type that is meant to be
inductive, and using them to provide realizations of axiomatically specified
theories. For example, the \textsf{List} standard theory of inductive lists
currently uses this two-stage architecture.

\warningbox{This version of the documentation is incomplete on this subject,
and only provides pointers to examples that may not be sufficient to fully
document the language. Please contact us as needed.}

\subsection{Predicates and Ambient Lemmas\label{sec:ec-specifics}}
In \EasyCrypt, booleans are used not only to represent binary program variables, but
also to type logical formulas. In addition to the operator symbols already
introduced, the \rawec{bool} type is therefore equipped with
symbols for universal and existential quantification, equivalence and
implication. However, since the program logic assumes that expressions are
terminating, we need to restrict the class of boolean formulas that can be used
when defining operators and writing programs. To this effect, we consider two
distinct classes of functional symbols: \emph{predicates}, that may not be
computable in general, and cannot be used to write programs (although they can
be used to specify them), and \emph{operators}, that are computable and can be
used for defining predicates and other operators, and to write programs.
Universal and existential quantification (\rawec{forall} and \rawec{exists}),
implication (\rawec{=>}) and equivalence (\rawec{<=>}) are internally defined as
predicate symbols, and therefore cannot be used to define operators. All other
boolean function symbols (in particular those discussed previously) are defined
as operators and can be used in any context.

Using these symbols, and since functions are values, one can express complex
logical formulas in higher-order logic, that can then be wrapped into
predicates, lemmas or axioms. We call this fragment of our logic that only
deals with operators the \emph{ambient logic}. Listing~\ref{lst:formulas}
displays a possible definition for a commutativity predicate on internal
operators, and expresses the fact that integer addition is commutative by
applying it. We also display a simple proof using the \rawec{smt} tactic, which
simply asks the SMT solvers to discharge the lemma. (The proof system and
tactics are documented more throroughly in Chapter~\ref{chap:tactics}.

\begin{easycrypt}[label={lst:formulas}]{Examples of ambient formulas: predicates and lemmas}
pred commutative (ope: 'a -> 'a -> 'a) =
  forall x y, ope x y = ope y x.

lemma addiC: commutative Int.(+) by smt.
\end{easycrypt}

\section{Probabilistic Expressions\label{sec:distributions}}

%%%% From Gilles:
\EasyCrypt features a polymorphic type \rawec{'a distr} of \emph{discrete
sub-distributions} over a base type \rawec{'a}. The primary operation over
sub-distributions is the function \rawec{op mu: 'a distr -> ('a -> bool) ->
real.} which measures the probability of an event. The function is assumed to
satisfy the basic axioms of probability sub-distributions:
\begin{itemize}\itemsep-.5em
\item probabilities lie in the unit interval;
\item the probability of false is null;
\item the probability of a union of events is equal to the sum of
  their probabilities, minus the probability of their intersection;
\item probabilities are monotonic with respect to event inclusion;
\item the probability of an event is equal to the probability of the
  intersection of that event and the distribution's support;
\item two sub-distributions are equal if and only if they are pointwise equal.
\end{itemize}

Sub-distributions are introduced axiomatically, and no well-formedness checks
are performed. For example, the uniform distribution on booleans is defined, in
the standard library, as displayed in Listing~\ref{lst:dbool}, where
\rawec{charfun P x} is the characteristic function of \rawec{P} evaluated in
\rawec{x} (that is, \rawec{1\%r} if \rawec{P} holds on \rawec{x} and
\rawec{0\%r} otherwise).

\begin{easycrypt}[label={lst:dbool}]{[Uniform Boolean distribution]Defining the uniform distribution on booleans}
op dbool: bool distr.

axiom mu_def: forall (p:bool -> bool), 
  mu dbool p =
    (1%r/2%r) * charfun p true +
    (1%r/2%r) * charfun p false.
\end{easycrypt}

The standard library on distributions
%, discussed further in Chapter~\ref{chap:libraries},
introduces several auxiliary quantities on distributions that are useful in
probability computations and for defining more complex distributions (that may
be difficult, or even impossible, to describe purely using \rawec{mu}). The
definitions of these quantities is shown in Listing~\ref{lst:mu_aux}, where
\rawec{cpTrue} is the constantly true predicate. Note the use of partial
application to the equality operator when defining \rawec{mu_x}.

\begin{easycrypt}[label={lst:mu_aux}]{Auxiliary operators on distributions}
op mu_x (d:'a distr) (x:'a): real = mu d ((=) x).
op weight (d:'a distr): real = mu d cPtrue.
op in_supp (x:'a) (d:'a distr): bool = 0%r < mu_x d x.
\end{easycrypt}

With these auxiliary operators, it is in fact fairly easy to check that the
simple axiom from Listing~\ref{lst:dbool} does indeed define a distribution, by
proving the following lemma, which can be discharged automatically.

\begin{easycrypt}[]{}
lemma lossless : weight dbool = 1%r by smt.
\end{easycrypt}

\section{\pWHILE, Modules and Functors\label{sec:modules}}

Although the languages for expressions and probabilistic expressions are quite
powerful, they fail to properly capture the kind of objects cryptographers
manipulate. \EasyCrypt uses the same language, \pWHILE, to describe
cryptographic schemes, oracles, and experiments as modules and functors.

We first briefly describe the \pWHILE language before giving an overview of
modules, as well as the two main mechanisms for their composition: direct usage
and functor application.



\subsection{Module Signatures}
We first formally define the functionalities a random oracle is expected to
provide, as a \emph{module type}, or \emph{signature}
(Listing~\ref{lst:modulesig}). Any module implementation \rawec{M} that provides
\emph{at least} the functions from a module type \rawec{Mt} is said to be of
type \rawec{Mt} (denoted \rawec{M :> Mt}). Module types cannot specify state
directly. Instead, if a global variable of the module should be exposed to the
outside, getter and setter functions can be added to the module signature.

\begin{easycrypt}[label={lst:modulesig}]{[A signature for random oracles]A signature for random oracles from bitstrings to bitstrings}
module type RO = {
  fun init():unit
  fun h(x:bitstring):bitstring }.
\end{easycrypt}

Such a module signature can then be given various realizations. For example, Listing~\ref{lst:modules} shows two possible realizations of a random oracle, both of which assume a positive integer constant \rawec{qH}, used to bound the number of calls to the oracle, and two positive integer constants \rawec{inLen} and \rawec{outLen} representing the input and output lengths of the random oracles.

%% The following is probably the single most disgusting thing I've ever typeset in Latex... and I've done ugly things.
\begin{minipage}{\textwidth}
\hrule
\begin{multicols}{2}
\begin{easycrypt}[frame=none,xleftmargin=0pt,xrightmargin=0pt]{}
module RO_L: RO = {
  var cG: int
  var mG: (bitstring,bitstring) map

  fun init() = {
    mG = empty;
    cG = 0;
  }

  fun h(x:bitstring) = {
    var r:bitstring;
    var res:bitstring = empty;
    if (length x = inLen && cG < qG)
    {
      cG = cG + 1;
      r = $dbitstring(outLen);
      if (!mem(x,dom mG)) mG[x] = r;
      res = mG[x];
    }
    return res;
  }
}.
\end{easycrypt}
\columnbreak
\begin{easycrypt}[frame=none,xleftmargin=0pt,xrightmargin=0pt]{}
module RO_E: RO = {
  var tape: bitstring list
  var mG: (bitstring,bitstring) map

  fun init() = {
    var r:bitstring;
    tape = [];
    mG = empty;
    while (length tape < qG)
    {
      r = $dbitstring(outLen);
      tape = r :: tape;
    }
  }

  fun h(x:bitstring) = {
    var r:bitstring;
    var res:bitstring = empty;
    if (length x = inLen &&
       length tape <> 0)
    {
      r = hd tape;
      if (!mem(x,dom mG))
        mG[x] = r;
      res = mG[x];
      tape = tl tape;
    }
    return res;
  }
}.
\end{easycrypt}
\end{multicols}
\hrule
\begin{easycrypt}[frame=non,xleftmargin=0pt,xrightmargin=0pt,label={lst:modules}]{[Two random oracles]Two possible implementations of module type \rawec{RO}}
\end{easycrypt}
\end{minipage}

\subsection{Functors and Oracle Annotations}
Modules can in fact be specified as functors, parameterized by other modules
whose functions can be accessed as oracles. For example, the signature shown in
Listing~\ref{lst:functorsig} describes a class of modules that are given access
to a random oracle but whose unique function can in fact only call the \rawec{h}
function provided by the parameter.

\begin{easycrypt}[label={lst:functorsig}]{[A functor signature]A functor signature}
module type RO_adv(O:RO) = {
  fun a(): bool { O.h }
}.
\end{easycrypt}

\section{Lemmas and Judgements}

\warningbox{Note that we use different implication symbols. $\Rightarrow$ is implication in the ambient logic (corresponding to the \rawec{=>} predicate), whereas $\Longrightarrow$ is used to express contracts on functions.\footnote{From Francois: it may be worth considering the use of another arrow symbol (for example $\Rrightarrow$) for contracts.}}

\subsection{(Possibilistic) Hoare Judgements}

Interpretation:
\begin{displaymath}
\Hoare{c}{\pre}{\post}
\quad\doteq\quad
\forall m.~ \pre\,m \Rightarrow \range Q ([\![ c ]\!]\,m)
\end{displaymath}
%
where $\range \varphi \mu \doteq \forall f.~ (\forall x.~ \varphi\,x
\Rightarrow f\,x=0) \Rightarrow \mu\,f=0$




\subsection{Probabilistic Hoare Judgements}

Interpretation:
\begin{displaymath}
\HoareLe{c}{\pre}{\post}{\delta} 
\quad\doteq\quad
\forall m.~ \pre\,m \Rightarrow [\![ c ]\!]\,m\,\charfun_\post \leq
\delta\,m
\end{displaymath}

Property?:
\begin{displaymath}
\Hoare{c}{\pre}{\post}
\Leftrightarrow
\HoareEq{c}{\pre}{\neg\post}{0}
\end{displaymath}

Property?:
\begin{displaymath}
\Hoare{c}{\pre}{\post} \land \HoareEq{c}{\pre}{\true}{1}
\Leftrightarrow
\HoareEq{c}{\pre}{\post}{1}
\end{displaymath}

\subsection{Relational Hoare Judgements}

\section{Sections}

\section{Working with Theories\label{sec:cloning}}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "easycrypt"
%%% End: 

