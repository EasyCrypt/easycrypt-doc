% !TeX root = easycrypt.tex

\chapter{The Languages of \EasyCrypt\label{chap:theories}}
Definitions and lemmas can be grouped in theories, that can be imported to
provide new language functionalities as required for a particular proof.
Currently, \EasyCrypt supports user-defined types and operators
(Section~\ref{sec:types}) and user-defined distributions
(Section~\ref{sec:distributions}). In addition, theories can declare modules and
functors (Section~\ref{sec:modules}), used to represent schemes, oracles and
experiments, as well as abstract types for such modules, which can be used to
modularize proofs or represent abstract adversaries. Finally, theories can be
cloned and refined (Section~\ref{sec:cloning}), which allows the user to
consider small variants of a theory without having to create a new one from
scratch, or to consider concrete implementation details only when necessary for
the proof.


\section{The Expression Language\label{sec:types}}
At the core of any \EasyCrypt specification is a collection of types and functional
operators on those types. Formally, \EasyCrypt types are \emph{non-empty} sets of
values, and operators are \emph{mathematical} functions between them.

\warningbox{Currently, the easiest way to define types and operators is to
declare them abstractly and specify them using axioms. It is \emph{very}
important for the consistency of the logical context to remember that types are
\emph{always} assumed to be non-empty, and that operators are total mathematical
functions when writing such definitions.}

The \EasyCrypt type system supports polymorphic, higher-order types: the type of
lists can be declared independently of the type of their contents, and operators
can take and return other operators. We first describe the various built-in
types and relevant operators before moving on to explaining how new definitions
can be built from them.

\subsection{Built-Ins}
The language is equipped with a few built-in types\footnote{This is only to
bridge our language with \WhyThree's logic and avoid the introduction of
indirection layers in the proof obligations sent to the SMT solvers: all these
built-in types could in theory be defined in \EasyCrypt itself.}:
\begin{itemize}\itemsep-.5em
\item the \rawec{unit}\index{easycrypt}{types!unit@\ec{unit}} type, which
        contains a unique element
        \rawec{tt}\index{easycrypt}{constants!tt@\ec{tt : unit}},
\item the \rawec{bool} type of booleans,
\item the \rawec{int} type of arithmetic integers (in $\mathbb{Z}$),
\item the \rawec{real} type of real numbers (in $\mathbb{R}$).
\end{itemize}

Some symbols are defined, declared or imported from \WhyThree in the
corresponding libraries, and are discussed further in the library documentation.

\subsubsection*{The \rawec{bool} type}
\index{easycrypt}{types!bool@\ec{bool}}
Boolean expression terms can be built from the constant
\rawec{true}\index{easycrypt}{constants!true@\ec{true : bool}} and
\rawec{false}\index{easycrypt}{constants!true@\ec{true : bool}}, in combination
with operators for logical conjunction and disjunction
(\rawec{/\\}\index{easycrypt}{operators!and@\ec{(/\\) : bool -> bool -> bool}} and
\rawec{\\\/}\index{easycrypt}{operators!or@\ec{(\\/) : bool -> bool -> bool}}),
short-circuiting conjunction and disjunction
(\rawec{\&\&}\index{easycrypt}{operators!anda@\ec{(&&) : bool -> bool -> bool}}
and
\rawec{||}\index{easycrypt}{operators!ora@\ec{(''ora) : bool -> bool -> bool}}),
and xor
(\rawec{\^\^}\index{easycrypt}{operators!xor@\ec{(\^\^) : bool -> bool -> bool}}).
Additional operators and simple rewriting rules are made available in the
\rawec{Bool} theory.

\subsubsection*{The \rawec{int} type}
\index{easycrypt}{types!int@\ec{int}}
Integer expression terms can be built from numerical constants between $0$ and
$2^{62} - 1$ (non-negative OCaml integers), in combintation with operators for
unary negation (\rawec{-}), and all arithmetic and comparison (\rawec{+},
\rawec{-}, \rawec{*}, \rawec{/}, \rawec{\%}, \rawec{^}, \rawec{=}, \rawec{<},
\rawec{<=}, \rawec{>}, \rawec{>=} \ldots). It is necessary to import the integer
library (via \rawec{require import Int.}, see Section~\ref{sec:cloning}) to have
access to these operators. Since this type is identified with the \WhyThree type
of integers, all \WhyThree lemmas on it can be used by the SMT solvers, and are
accessible by name for use in interactive proofs. We will eventually be
providing uniformly named wrappers and algebraic structures.

\subsubsection*{The \rawec{real} type}
\index{easycrypt}{types!real@\ec{real}}
Real expression terms can be built from integer constants suffixed with a
\rawec{\%r} (for example, \rawec{0\%r} is 0 in the \rawec{real} type), in
combination with the same operators available on integers. It is necessary to
import the library (using \rawec{require import Real.}) to access these
operators in scope. This type is also identified with the \WhyThree type of
reals, which provides some lemmas and tighter integration with the underlying
theories, but SMT solvers often have very limited support for real numbers and
will often fail to prove seemingly trivial results, with Z3 often outperforming
other solvers. We will be working on enriching the library of lemmas available
in this theory to allow more complex interactive proofs when automation fails.

\warningbox{\rawec{(1/2)\%r} and \rawec{1\%r/2\%r} are very different
expressions. The former evaluates to $0$ (the division is in $\mathbb{Z}$, and
the result ($0$) is interpreted in $\mathbb{R}$) whereas the latter evaluates to
$0.5$ (the operands are interpreted and the operator is applied in
$\mathbb{R}$). Eventually, we will introduce notations for scoping that should
allow less cluttered real expressions.}

\subsection{Building Types}
From these base types, many more can be built. \EasyCrypt allows the user to declare
 (polymorphic) abstract types, and combine existing types into tuple types or
function types.



\subsubsection*{Tuple types}
Given two types \ec{'t} and \ec{'t'}, \ec{('t * 't')} denotes the type of pairs
of elements of \ec{'t} and \ec{'t'}. More generally, the product can be iterated
to produce tuple types of arbitrary arity. For example, Listing~\ref{lst:tuples}
declares two abstract types, \ec{pkey} and \ec{skey}, and then defines a type
\ec{keypairs} as the type of pairs of elements of \ec{pkey} and \ec{skey}.

\warningbox{Types \ec{('t * 't' * 't'')}, \ec{(('t * 't') * 't'')} and
\ec{('t * ('t' * 't''))} are distinct (but isomorphic).}

\begin{easycrypt}[label={lst:tuples}]{A simple tuple type.}
type pkey.
type skey.

type keypair = (pkey * skey).
\end{easycrypt}

\subsubsection*{Function types}
Given two types \ec{'t} and \ec{'t'}, \ec{'t -> 't'} is the type of total
functions from \ec{'t} to \ec{'t'}. Listing~\ref{lst:functions} illustrates such
a type definition, and the use of polymorphism, by defining a polymorphic type
of predicates. For any type \rawec{'a}, we construct a type \rawec{'a cpred} of
functions from \rawec{'a} to \rawec{bool}.

\begin{easycrypt}[label={lst:functions}]{A simple polymorphic function type.}
type 'a cpred = 'a -> bool.
\end{easycrypt}

\subsubsection*{Type application}
Polymorphic types can be instantiated with particular type parameters if
desired. For example, sets of integers could be defined as predicates on
integers as shown in Listing~\ref{lst:type_app}. Using the polymorphic type of
predicates defined in Listing~\ref{lst:functions}, we simply apply it to
\ec{int} to instatiate \rawec{'a} with \rawec{int}.

\begin{easycrypt}[label={lst:type_app}]{A simple type application.}
type intSet = int cpred.
\end{easycrypt}

\subsubsection*{On currying}
It is standard practice to write functions of several arguments in curried form,
where applying the function symbol to the first argument returns a function that
takes the second argument, and so on. This very easily allows the user to
partially apply functions to fix some of their arguments. This does not restrict
or increase the expressivity of the language in any way, although it may
initially cause some syntax issues for users unfamiliar with the concept. When
applying a curried function to several arguments, the arguments should be
separated by spaces rather than the more standard commas.
Listing~\ref{lst:currying} illustrates this.

\begin{easycrypt}[label={lst:currying}]{Currying.}
op log: int -> int -> int.
op log2: int-> int = log_curried 2.

op log_pair: (int * int) -> int.
op log2_pair (n:int): int = log (2,n).
\end{easycrypt}

The \rawec{log} is declared as an integer function of two (curried) integer
arguments, and the log base 2, \rawec{log2}, is defined as its partial
application to 2. This definition could have been equivalently written as
follows.
\begin{easycrypt}[frame=none]{}
op log2 (n:int): int = log 2 n.
\end{easycrypt}
Contrasting with the curried form described above, \rawec{log_pair} is declared
as an integer function of a single argument (whose type is a pair type).
Partial application is slightly more verbose, but the syntax of application may
look more familiar to imperative programmers.

\subsection{Building Terms}
The partial applications in Listing~\ref{lst:currying} are small examples of
building terms of a given type. We will now discuss this more generally. The
reader eager to perform proofs can start drawing parallels between this
subsection and the term reduction (computation) rules at the beginning of
Chapter~\ref{chap:tactics}. %TODO: More precise cross-reference

\subsection{Predicates and Ambient Lemmas\label{sec:ec-specifics}}
In \EasyCrypt, booleans are used not only to represent binary program variables, but
also to type logical formulas. The \rawec{bool} type is therefore equipped with
symbols for universal and existential quantification, implication, logical and
short-circuiting conjunction and disjunction and xor. However, since the program
logic assumes that expressions are terminating, we need to restrict the class of
boolean formulas that can be used when defining operators and writing programs.
To this effect, we consider two distinct classes of functional symbols:
\emph{predicates}, that may not be computable in general, and cannot be used to
write programs (although they can be used to specify them), and
\emph{operators}, that are computable and can be used for defining predicates
and other operators, and to write programs.

Universal and existential quantification (\rawec{forall} and \rawec{exists}),
implication (\rawec{=>}) and equivalence (\rawec{<=>}) are internally defined as
predicate symbols, and therefore cannot be used to define operators. All other
boolean function symbols are defined as operators and can be used in any
context. They include logical conjunction and disjunction (\rawec{/\\} and
\rawec{\\\/}), short-circuiting conjunction and disjunction (\rawec{\&\&} and
\rawec{\|\|}), and xor (\rawec{\^\^}).


% TODO: redistribute the following
%
%The following \EasyCrypt code (Listing~\ref{lst:bitstrings}) declares an abstract type of bitstrings, equipped
%with a length operator (whose result is never negative) and an infix addition
%operator that enjoys interesting properties both with respect to length and by
%itself.
%
%\begin{easycrypt}[label={lst:bitstrings}]{[A type for bitstrings]A core type for bitstrings}
%type bitstring.
%
%op length: bitstring -> int.
%axiom length_pos: forall bs, 0 <= length bs.
%
%op (+): bitstring -> bitstring -> bitstring.
%axiom length_xor: forall b0 b1,
%  length b0 = length b1 => length (b0 + b1) = length b0.
%axiom xor_associative: forall b0 b1 b2,
%  (b0 + b1) + b2 = b0 + (b1 + b2).
%axiom xor_commutative: forall b0 b1, b0 + b1 = b1 + b0.
%\end{easycrypt}
%
%\subsubsection{Types}
%\EasyCrypt expressions are equipped with polymorphic, higher-order types, that can be declared abstractly (as in Listing~\ref{lst:bitstrings}), or given concrete definitions, depending on the needs of the proof.
%
%
%\warningbox{One could expect the type annotations in the \rawec{extensionality}
%axiom to be optional. However, they are currently required so that the type
%variable can be instantiated.}
%
%\subsubsection{Operators}
%The language of operators and predicates is functional in style, and
%comma-separated lists of parameters are in fact currified, in this context, to
%yield functional symbols that can be partially applied. (For example, the infix
%extensional equality predicate \ec{(==)} defined in Listing~\ref{lst:arrays} has
%type \ec{'x array -> 'x array -> bool}.)
%
%\paragraph{Mixfix operators}
%Special syntax is used to introduce two hard-coded mixfix operators (generally
%considered to correspond to set and get operations on various types). The
%``\rawec[literate={\_}{{$\cdot$}}1]{_.[_]}'' operator (named \emph{get}
%throughout this manual) is hard-coded as a binary operator. The
%``\rawec[literate={_}{{$\cdot$}}1]{_.[_<-_]}'' operator (not yet encountered,
%and named \emph{set} in the rest of this manual) is hard-coded as a ternary
%operator. In addition, a constant operator ``\rawec{[]}'' can be defined, and
%will often be referred to as the \emph{empty} constant, depending on its type
%and the current scope.
%
%\paragraph{Infix operators}
%Infix operators are declared between parentheses, and can be used either in
%infix syntax using the symbol itself (for example, \rawec{x == y}), or in prefix
%syntax using their parenthesized form (for example, \rawec{(==) x y}).
%
%\subsection{Higher-Order Operators}
%Operators can be higher-order. For example, the code sample shown in
%Listing~\ref{lst:init_arrays} illustrates how one can axiomatically specify an
%operator which creates a fresh array and initializes its elements with
%index-dependent values. We illustrate its usage by defining an operator
%\ec{init} that, given an integer $n$, produces the array containing integers $0$
%through $n$, in ascending order.
%
%\begin{easycrypt}[label={lst:init_arrays}]{[Index-dependent array initializer]An operator initializing an array with index-dependent values}
%op init: (int -> 'x) -> int -> 'x array.
%
%axiom init_length: forall (f:int -> 'x) l,
%  0 <= l => length (init f l) = l.
%
%axiom init_get: forall (f:int -> 'x) l i,
%  0 <= l => 0 <= i => i < l =>
%  (init f l).[i] = f i.
%
%op first_ints n = init (lambda i, i) n.
%\end{easycrypt}
%
%The \rawec{lambda} notation works as expected. The argument types can be
%specified where necessary. Equality on lambda terms is extensional.

\section{Probabilistic Expressions\label{sec:distributions}}

%%%% From Gilles:
\EasyCrypt features a polymorphic type \rawec{'a distr} of \emph{discrete
sub-distributions} over a base type \rawec{'a}. The primary operation over
sub-distributions is the function \rawec{op mu: 'a distr -> ('a -> bool) ->
real.} which measures the probability of an event. The function is assumed to
satisfy the basic axioms of probability sub-distributions:
\begin{itemize}\itemsep-.5em
\item probabilities lie in the unit interval;
\item the probability of the union of events is equal to the sum of
  their probabilities, minus the sum of their intersection;
\item probabilities are monotonic with respect to event inclusion;
\item two sub-distributions over the same base type are equal if and only if
  they are equal on each of the elements in the base type.
\end{itemize}

Sub-distributions are introduced axiomatically, and no well-formedness checks
are performed. For example, the uniform distribution on booleans is defined, in
the standard library, as displayed in Listing~\ref{lst:dbool}, where
\rawec{caract P x} is \rawec{1\%r} if \rawec{P} holds on \rawec{x} and
\rawec{0\%r} otherwise.

\begin{easycrypt}[label={lst:dbool}]{[Uniform Boolean distribution]Defining the uniform distribution on booleans}
op dbool: bool distr.

axiom mu_def: forall (p:bool -> bool), 
  mu dbool p =
    (1%r/2%r) * caract p true +
    (1%r/2%r) * caract p false.
\end{easycrypt}

The standard library on distributions, discussed further in
Chapter~\ref{chap:libraries}, introduces several auxiliary quantities on
distributions that are useful in probability computations and for defining more
complex distributions that are difficult, or impossible, to describe purely
using \rawec{mu}. The definitions of these quantities is shown in
Listing~\ref{lst:mu_aux}, where \rawec{cPtrue} is the constantly true predicate.
Note the use of partial application to the equality operator when defining
\rawec{mu_x}.

\begin{easycrypt}[label={lst:mu_aux}]{Auxiliary operators on distributions}
op mu_x(d:'a distr, x:'a) = mu d ((=) x).
op mu_weight(d:'a distr) = mu d cPtrue.
op in_supp(x:'a, d:'a distr) = 0%r < mu_x d x.
\end{easycrypt}

With these auxiliary operators, it is in fact fairly easy to check that the simple axiom from Listing~\ref{lst:dbool} does indeed define a distribution, by proving the following lemma, which is discharged automatically by the SMT solvers.

\begin{easycrypt}[]{}
lemma lossless : weight dbool = 1%r.
\end{easycrypt}

\section{Modules and Functors\label{sec:modules}}

\subsection{\pWHILE: Schemes, Oracles and Experiments}
So far, we have only considered features whose goal is to extend the language of
expressions and the semantic domain of values. Specifications of schemes,
oracles, assumptions and game-based security properties all use modules (and
module signatures) and functors, which we now discuss, using a simple modular
definition of a random oracle from bitstrings to bitstrings as an example.

\subsection{Module Signatures}
We first formally define the functionalities a random oracle is expected to
provide, as a \emph{module type}, or \emph{signature}
(Listing~\ref{lst:modulesig}). Any module implementation \rawec{M} that provides
\emph{at least} the functions from a module type \rawec{Mt} is said to be of
type \rawec{Mt} (denoted \rawec{M :> Mt}). Module types cannot specify state
directly. Instead, if a global variable of the module should be exposed to the
outside, getter and setter functions can be added to the module signature.

\begin{easycrypt}[label={lst:modulesig}]{[A signature for random oracles]A signature for random oracles from bitstrings to bitstrings}
module type RO = {
  fun init():unit
  fun h(x:bitstring):bitstring }.
\end{easycrypt}

Such a module signature can then be given various realizations. For example, Listing~\ref{lst:modules} shows two possible realizations of a random oracle, both of which assume a positive integer constant \rawec{qH}, used to bound the number of calls to the oracle, and two positive integer constants \rawec{inLen} and \rawec{outLen} representing the input and output lengths of the random oracles.

%% The following is probably the single most disgusting thing I've ever typeset in Latex... and I've done ugly things.
\begin{minipage}{\textwidth}
\hrule
\begin{multicols}{2}
\begin{easycrypt}[frame=none,xleftmargin=0pt,xrightmargin=0pt]{}
module RO_L: RO = {
  var cG: int
  var mG: (bitstring,bitstring) map

  fun init() = {
    mG = empty;
    cG = 0;
  }

  fun h(x:bitstring) = {
    var r:bitstring;
    var res:bitstring = empty;
    if (length x = inLen && cG < qG)
    {
      cG = cG + 1;
      r = $dbitstring(outLen);
      if (!mem(x,dom mG)) mG[x] = r;
      res = mG[x];
    }
    return res;
  }
}.
\end{easycrypt}
\columnbreak
\begin{easycrypt}[frame=none,xleftmargin=0pt,xrightmargin=0pt]{}
module RO_E: RO = {
  var tape: bitstring list
  var mG: (bitstring,bitstring) map

  fun init() = {
    var r:bitstring;
    tape = [];
    mG = empty;
    while (length tape < qG)
    {
      r = $dbitstring(outLen);
      tape = r :: tape;
    }
  }

  fun h(x:bitstring) = {
    var r:bitstring;
    var res:bitstring = empty;
    if (length x = inLen &&
       length tape <> 0)
    {
      r = hd tape;
      if (!mem(x,dom mG))
        mG[x] = r;
      res = mG[x];
      tape = tl tape;
    }
    return res;
  }
}.
\end{easycrypt}
\end{multicols}
\hrule
\begin{easycrypt}[frame=non,xleftmargin=0pt,xrightmargin=0pt,label={lst:modules}]{[Two random oracles]Two possible implementations of module type \rawec{RO}}
\end{easycrypt}
\end{minipage}

\subsection{Functors and Oracle Annotations}
Modules can in fact be specified as functors, parameterized by other modules
whose functions can be accessed as oracles. For example, the signature shown in
Listing~\ref{lst:functorsig} describes a class of modules that are given access
to a random oracle but whose unique function can in fact only call the \rawec{h}
function provided by the parameter.

\begin{easycrypt}[label={lst:functorsig}]{[A functor signature]A functor signature}
module type RO_adv(O:RO) = {
  fun a(): bool { O.h }
}.
\end{easycrypt}

\section{Lemmas and Judgements}

\warningbox{Note that we use different implication symbols. $\Rightarrow$ is implication in the ambient logic (corresponding to the \rawec{=>} predicate), whereas $\Longrightarrow$ is used to express contracts on functions.\footnote{From Francois: it may be worth considering the use of another arrow symbol (for example $\Rrightarrow$) for contracts.}}

\subsection{(Possibilistic) Hoare Judgements}

Interpretation:
\begin{displaymath}
\Hoare{c}{\pre}{\post}
\quad\doteq\quad
\forall m.~ \pre\,m \Rightarrow \range Q ([\![ c ]\!]\,m)
\end{displaymath}
%
where $\range \varphi \mu \doteq \forall f.~ (\forall x.~ \varphi\,x
\Rightarrow f\,x=0) \Rightarrow \mu\,f=0$




\subsection{Probabilistic Hoare Judgements}

Interpretation:
\begin{displaymath}
\HoareLe{c}{\pre}{\post}{\delta} 
\quad\doteq\quad
\forall m.~ \pre\,m \Rightarrow [\![ c ]\!]\,m\,\charfun_\post \leq
\delta\,m
\end{displaymath}

Property?:
\begin{displaymath}
\Hoare{c}{\pre}{\post}
\Leftrightarrow
\HoareEq{c}{\pre}{\neg\post}{0}
\end{displaymath}

Property?:
\begin{displaymath}
\Hoare{c}{\pre}{\post} \land \HoareEq{c}{\pre}{\true}{1}
\Leftrightarrow
\HoareEq{c}{\pre}{\post}{1}
\end{displaymath}

\subsection{Relational Hoare Judgements}

\section{Sections}

\section{Working with Theories\label{sec:cloning}}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "easycrypt"
%%% End: 

