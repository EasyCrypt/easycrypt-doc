% !TeX root = easycrypt.tex

\chapter{Theories (Fran\c{c}ois + Gilles)\label{chap:theories}}

Definitions and lemmas can be grouped in theories, that can be imported to
provide new language functionalities as required for a particular proof.
Currently, \EC supports user-defined types and operators
(Section~\ref{sec:types}) and user-defined distributions
(Section~\ref{sec:distributions}). In addition, theories can declare modules and
functors (Section~\ref{sec:modules}), used to represent schemes, oracles and
experiments, as well as abstract types for such modules, which can be used to
modularize proofs or represent abstract adversaries. Finally, theories can be
cloned and refined (Section~\ref{sec:cloning}), which allows the user to
consider small variants of a theory without having to create a new one from
scratch, or to consider concrete implementation details only when necessary for
the proof.

We illustrate each of the basic concepts with commented excerpts from the
standard library distributed with \EC. The standard library is documented
further in Chapter~\ref{chap:libraries}.

\section{Types and Operators\label{sec:types}}

At the core of any \EC specification is a set of types and functional operators
on those types. Types are \emph{non-empty} sets of values, and operators are
\emph{mathematical} functions between them.

\warningbox{Currently, the easiest way to define types and operators is to
declare them abstractly and specify them using axioms. It is \emph{very}
important for the consistency of the logical context to remember that types are
\emph{always} assumed to be non-empty, and that operators are functionals
(total, deterministic and side-effect free) when writing such definitions.}

\subsection{Basic Usage}
The following \EC code declares an abstract type of polymorphic arrays, equipped
with a length operator (whose result is never negative), an indexing operator
and extensional equality.

\begin{easycrypt}[label={lst:arrays}]{[Polymorphic arrays]A type for polymorphic arrays}
type 'a array.

op length: 'x array -> int.
axiom length_pos: forall (xs:'x array), 0 <= length xs.

op "_.[_]": 'x array -> int -> 'x.

pred (==)(xs0:'x array, xs1:'x array) =
  length xs0 = length xs1 /\
  forall i, 0 <= i => i < length xs0 => xs0.[i] = xs1.[i].

axiom extensionality: forall (xs0 xs1:'x array),
  xs0 == xs1 => xs0 = xs1.
\end{easycrypt}

The language of operators and predicates is functional in style, and
comma-separated lists of parameters are in fact currified, in this context, to
yield functional symbols that can be partially applied. (For example, the infix
extensional equality predicate \ec{(==)} defined in Listing~\ref{lst:arrays} has
type \ec{'x array -> 'x array -> bool}.)

Special syntax is used to introduce two hard-coded mixfix operators (generally
considered to correspond to set and get operations on various types). The
``\rawec[literate={\_}{{$\cdot$}}1]{_.[_]}'' operator (named \emph{get}
throughout this manual) is hard-coded as a binary operator. The
``\rawec[literate={_}{{$\cdot$}}1]{_.[_<-_]}'' operator (not yet encountered,
and named \emph{set} in the rest of this manual) is hard-coded as a ternary
operator. In addition, a constant operator ``\rawec{[]}'' can be defined, and
will often be referred to as the \emph{empty} constant, depending on its type
and the current scope.

Infix operators are declared between parentheses, and can be used either in
infix syntax using the symbol itself (for example, \rawec{x == y}), or in prefix
syntax using their parenthesized form (for example, \rawec{(==) x y}).

As illustrated in the definition of the extensional equality predicate, type
annotations are optional when types can be inferred.

\warningbox{One could expect the type annotations in the \rawec{extensionality}
axiom to be optional. However, they are currently required so that the type
variable can be instantiated.}

\subsection{Higher-Order Operators}
Operators can be higher-order. For example, the code sample shown in
Listing~\ref{lst:init_arrays} illustrates how one can axiomatically specify an
operator which creates a fresh array and initializes its elements with
index-dependent values. We illustrate its usage by defining an operator
\ec{init} that, given an integer $n$, produces the array containing integers $0$
through $n$, in ascending order.

\begin{easycrypt}[label={lst:init_arrays}]{[Index-dependent array initializer]An operator initializing an array with index-dependent values}
op init: (int -> 'x) -> int -> 'x array.

axiom init_length: forall (f:int -> 'x) l,
  0 <= l => length (init f l) = l.

axiom init_get: forall (f:int -> 'x) l i,
  0 <= l => 0 <= i => i < l =>
  (init f l).[i] = f i.

op first_ints n = init (lambda i, i) n.
\end{easycrypt}

The \rawec{lambda} notation works as expected. The argument types can be
specified where necessary. Equality on lambda terms is extensional.

\section{Describing Distributions\label{sec:distributions}}

\EC offers support for user-defined distributions. Distributions are defined by
formally defining their density function, represented by the built-in operator
\rawec{op mu: 'a distr -> ('a -> bool) -> real.} For example, the uniform
distribution on booleans is defined, in the standard library, as displayed in
Listing~\ref{lst:dbool}, where \rawec{caract P x} is \rawec{1\%r} if \rawec{P}
holds on \rawec{x} and \rawec{0\%r} otherwise.

\begin{easycrypt}[label={lst:dbool}]{[Uniform Boolean distribution]Defining the uniform distribution on booleans}
op dbool: bool distr.

axiom mu_def: forall (P:bool -> bool), 
  mu dbool P =
    (1%r/2%r) * caract P true +
    (1%r/2%r) * caract P false.
\end{easycrypt}

It may not always be this easy to define distributions. More examples of
user-provided definitions, and some distribution transformers that make it
possible to define new distributions from existing ones, can be found in the
standard library (Chapter~\ref{chap:libraries}).

\warningbox{Distributions are defined axiomatically, and no well-formedness checks are performed.}

\section{Modules and Functors\label{sec:modules}}

So far, we have only considered features whose goal is to extend the language of
expressions and the semantic domain of values. Specifications of schemes,
oracles, assumptions and game-based security properties all use modules (and
module signatures) and functors, which we now discuss, using a simple modular
definition of a random oracle from bitstrings to bitstrings as an example.

We first formally define the functionalities a random oracle is expected to
provide, as a \emph{module type}, or \emph{signature}
(Listing~\ref{lst:modulesig}). Any module implementation \rawec{M} that provides
\emph{at least} the functions from a module type \rawec{Mt} is said to be of
type \rawec{Mt} (denoted \rawec{M :> Mt}).

\begin{easycrypt}[label={lst:modulesig}]{[A signature for random oracles]A signature for random oracles from bitstrings to bitstrings}
module type RO = {
  fun init():unit;
  fun h(x:bitstring):bitstring; }.
\end{easycrypt}

Such a module signature can then be given various realizations. For example, Listing~\ref{lst:modules} shows two possible realizations of a random oracle, both of which assume a positive integer constant \rawec{qH}, used to bound the number of calls to the oracle, and two positive integer constants \rawec{inLen} and \rawec{outLen} representing the input and output lengths of the random oracles.

%% The following is probably the single most disgusting thing I've ever typeset in Latex... and I've done ugly things.
\begin{minipage}{\textwidth}
\hrule
\begin{multicols}{2}
\begin{easycrypt}[frame=none,xleftmargin=0pt,xrightmargin=0pt]{}
module RO_L: RO = {
  var cG: int
  var mG: (bitstring,bitstring) map

  fun init() = {
    mG = empty;
    cG = 0;
  }

  fun h(x:bitstring) = {
    var r:bitstring;
    var res:bitstring = empty;
    if (length x = inLen && cG < qG)
    {
      cG = cG + 1;
      r = $dbitstring(outLen);
      if (!mem(x,dom mG)) mG[x] = r;
      res = mG[x];
    }
    return res;
  }
}.
\end{easycrypt}
\columnbreak
\begin{easycrypt}[frame=none,xleftmargin=0pt,xrightmargin=0pt]{}
module RO_E: RO = {
  var tape: bitstring list
  var mG: (bitstring,bitstring) map

  fun init() = {
    var r:bitstring;
    tape = [];
    mG = empty;
    while (length tape < qG)
    {
      r = $dbitstring(outLen);
      tape = r :: tape;
    }
  }

  fun h(x:bitstring) = {
    var r:bitstring;
    var res:bitstring = empty;
    if (length x = inLen &&
       length tape <> 0)
    {
      r = hd tape;
      if (!mem(x,dom mG))
        mG[x] = r;
      res = mG[x];
      tape = tl tape;
    }
    return res;
  }
}.
\end{easycrypt}
\end{multicols}
\hrule
\begin{easycrypt}[frame=non,xleftmargin=0pt,xrightmargin=0pt,label={lst:modules}]{[Two random oracles]Two possible implementations of module type \rawec{RO}}
\end{easycrypt}
\end{minipage}

\section{Lemmas and Judgements}

\subsection{Ambient Lemmas}

\subsection{(Possibilistic) Hoare Judgements}

\subsection{Probabilistic Hoare Judgements}

\subsection{Relational Hoare Judgements}

\section{Requiring, Cloning and Realizing Theories\label{sec:cloning}}

%%% Local Variables: %%% mode: latex %%% TeX-master: "easycrypt" %%% End: