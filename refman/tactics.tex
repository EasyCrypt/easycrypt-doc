% --------------------------------------------------------------------
\section{Tactics}

\subsection{Ambient logic}

\input{tactics/idtac.tex}
\input{tactics/move.tex}
\input{tactics/clear.tex}
\input{tactics/done.tex}
\input{tactics/apply.tex}
\input{tactics/exact.tex}
\input{tactics/assumption.tex}
\input{tactics/pose.tex}
\input{tactics/cut.tex}

\input{tactics/rewrite.tex}
\input{tactics/rwnormal.tex}
\input{tactics/subst.tex}

\input{tactics/split.tex}
\input{tactics/left.tex}
\input{tactics/right.tex}

\input{tactics/case.tex}
\input{tactics/elim.tex}

\input{tactics/change.tex}
\input{tactics/simplify.tex}
\input{tactics/progress.tex}

\input{tactics/beta.tex}
\input{tactics/delta.tex}
\input{tactics/zeta.tex}
\input{tactics/iota.tex}
\input{tactics/logic.tex}

\input{tactics/reflexivity.tex}

\input{tactics/ringeq.tex}
\input{tactics/fieldeq.tex}
\input{tactics/algebra.tex}
\input{tactics/congr.tex}

\input{tactics/trivial.tex}
\input{tactics/smt.tex}

\input{tactics/admit.tex}

\subsection{Program Logics}

Judgments in the program logics may refer to procedures or
statements. Whenever the context allows both, we use $c$ (or \tct{c})
to denote programs, using $f$ (or \tct{f}) when only judgments on
procedures are allowed by the context, and $s$ (or \tct{s}) when only
judgments on statements are allowed.

\EasyCrypt includes three different program logics:
\begin{itemize}
\item \prhl, or probabilistic relational Hoare logic, with judgments of the form
%%
$$\pRHL{P}{c_1}{c_2}{Q}$$
%%
where $c_1$ and $c_2$ are programs, and $P$ and $Q$
are relations on memories.
\item \phl, or probabilistic Hoare logic, with judgments of the form
%%
$$\pHL{P}{c}{Q}{\diamond}{\delta}$$
%%
where $c$ is a program, $P$ and $Q$ are predicates on memories,
$\diamond\in\{\leq,\geq,=\}$ is a comparison relation and $\delta$ is
a real-valued expression, evaluated in the initial memory.
\item \hl, or (possibilistic) Hoare logic, with judgments of the form
%%
$$\HL{P}{c}{Q}$$
%%
where $c$ is a program, and $P$ and $Q$ are predicates on memories.
\end{itemize}

When $c$ is a procedure, preconditions ($P$ above) operate on memories
extended with a special $\Arg$ location that refers to the procedure's
arguments, and postcondition ($Q$ above) operate on memories extended
with a special $\Res$ location that refers to the procedure's return
value.

In the following, given a relation $R$, we denote with $\invrel{R}$
its inverse relation (that is,
%%
$\Rel{R}{m_1}{m_2} \Leftrightarrow \Rel{\invrel{R}}{m_2}{m_1}$).

We denote with $\diamond^{\uparrow}$ the function defined by
$$
\cdot^{\uparrow} =
\left\{\begin{array}{l @{\quad\mapsto\quad} r}
=    & \Leftrightarrow \\
\leq & \Leftarrow      \\
\geq & \Rightarrow
\end{array}\right.
$$

Given a predicate $P$, we denote with $\inmem{P}{1}$
(resp. $\inmem{P}{2}$) the relation defined by
%%
$\Rel{\inmem{P}{1}}{m_1}{m_2} \Leftrightarrow \Pred{P}{m_1}$
(resp. $\Rel{\inmem{P}{2}}{m_1}{m_2} \Leftrightarrow \Pred{P}{m_2}$).
We lift logical connectors to predicates and relations over memories
in the natural way.

TODO: define \tct{<spec>}, \tct{<lemma>}, \tct{<prhl>}, \tct{<phl>},
\tct{<hl>}.

\paragraph{Reasoning on Specifications}
\input{tactics/symmetry.tex}
\input{tactics/transitivity.tex}
\input{tactics/conseq.tex}
\input{tactics/phoare_split.tex}
\input{tactics/byequiv.tex}
\input{tactics/byphoare.tex}
\input{tactics/hoare.tex}
\input{tactics/bypr.tex}
\input{tactics/exfalso.tex}
%\input{tactics/pr_bounded.tex}

\paragraph{Reasoning on Programs}
Unless specified, the following program logic tactics operate on a
program's last instruction. Although we describe these tactics as if
they operated on single instructions, their practical implementation
automatically and implicitly applies tactic \rtactic{seq} to deal with
context when necessary.

For simple proofs, it is often enough to simply apply the program
tactic corresponding to the last instruction in the program and let
\tct{smt} deal with the verification condition once the program has
been exhausted.

Most of the program reasoning tactics discussed in this paragraph have
two modes when used on \prhl proof obligations. Their default mode is
to operate on both programs at once. When a side is specified (using
\tct{<tactic>\{1\}} or \tct{<tactic>\{2\}}), a one-sided variant is
used. Apart from the \rtactic{if} tactic, the one-sided variant is in
fact a combination of the \phl tactic and \rtactic{conseq}.

\medskip

\input{tactics/skip.tex}
\input{tactics/seq.tex}
\input{tactics/sp.tex}
\input{tactics/wp.tex}
\input{tactics/rnd.tex}
\input{tactics/if.tex}
\input{tactics/while.tex}
\input{tactics/call.tex}
\input{tactics/proc.tex}


\paragraph{Transforming Programs}
\input{tactics/swap.tex}
\input{tactics/inline.tex}

\input{tactics/rcondf.tex}
\input{tactics/rcondt.tex}

\input{tactics/splitwhile.tex}
\input{tactics/unroll.tex}
\input{tactics/fission.tex}
\input{tactics/fusion.tex}

\input{tactics/alias.tex}
\input{tactics/cfold.tex}
\input{tactics/kill.tex}
\input{tactics/modpath.tex}

\paragraph{Automated Tactics}
\input{tactics/auto.tex}
\input{tactics/sim.tex}

\paragraph{Advanced Tactics}
\input{tactics/eager.tex}
\input{tactics/fel.tex}
