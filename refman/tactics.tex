\chapter{Tactics}
\label{chap:tactics}

Proofs in \EasyCrypt are carried out using \emph{tactics}, logical
rules embodying general reasoning principles, which transform the
current lemma (or \emph{goal}) into zero or more
\emph{subgoals}---sufficient conditions for the lemma/goal to
hold. Simple ambient logic goals may be automatically proved using SMT
solvers.

In this chapter, we introduce \EasyCrypt's proof engine, before
describing the tactics for \EasyCrypt's four logics: ambient, \prhl,
\phl and \hl.

\section{Proof Engine}

\EasyCrypt's proof engine works with goal lists, where a \emph{goal}
has three parts:
\begin{itemize}
\item A set of type variables.

\item An \emph{ordered} set of \emph{assumptions}, consisting of
  identifiers with their types, memories, module names with their
  module types and restrictions, and named formulas. An identifier's
  type may involve the type variables, the formulas may involve the
  type variables, identifiers, memories and module names.

\item A \emph{conclusion}, consisting of a single formula, with
  the same constraints as the assumption formulas.
\end{itemize}
Informally, to prove a goal, one must show the conclusion to be true,
given the truth of the formula assumptions, for all valid instantiations
of the assumption identifiers, memories and module names.

For example,
\ecinput{examps/tactics-examp0-2.1.ec}{}{}{}{}
is a goal.
And, in the context of the declarations
\ecinput{examps/tactics-examp2.ec}{}{3-11}{}{}
this is a goal:
\ecinput{examps/tactics-examp2-2.0.ec}{}{}{}{}
The conclusion of this goal is just a nonlinear rendering of the formula
\begin{easycrypt}{}{}
phoare [G(X).g : G.x = n ==> G.x = n] = 1%r.
\end{easycrypt}
\EasyCrypt's pretty printer renders \prhl, \phl and \hl judgements
in such a nonlinear style when the judgements appear as
(as opposed to in) the conclusions of goals.

Internally, \EasyCrypt's proof engine also works with \prhl, \phl and
\hl judgments involving lists of statements rather than procedure
names, which we'll call \emph{statement judgements}, below. For
example, given this declaration
\ecinput{examps/tactics-examp1.ec}{}{3-9}{}{}
this is an \phl statement judgement:
\ecinput{examps/tactics-examp1-3.0.ec}{}{}{}{}
The pre- and post-conditions of a statement judgement may refer to the
parameters and local variables of the procedure that's the
\emph{context} of the conclusion---\ec{M.f} in the preceding
example. They may also refer to the memories \ec{&$1$} and \ec{&$2$}
in the case of \prhl statement judgements.
When a statement judgement appears anywhere other than as the conclusion of
a goal, the pretty printer renders it in abbreviated linear syntax.
E.g., the preceding goal is rendered as
\begin{easycrypt}{}{}
hoare[if (x %% 3 = 1) {...} : x %% 3 = n ==> x %% 3 = n %% 2 + 1]
\end{easycrypt}
Statement judgements can't be directly input by the user.

When the proof of a lemma is begun, the proof engine starts out with
a single goal, consisting of the lemma's statement. E.g.,
the lemma
\ecinput{examps/tactics-examp0.ec}{}{1-3}{}{}
gives rise to the goal
\ecinput{examps/tactics-examp0-1.0.ec}{}{}{}{}
For parameterized lemmas, the goal includes the lemma's parameters
as assumptions. E.g.,
\begin{easycrypt}{}{}
lemma PairEq (x x' : 'a) (y y' : 'b) :
  x = x' => y = y' => (x, y) = (x', y').
\end{easycrypt}
gives rise to
\ecinput{examps/tactics-examp0-2.0.ec}{}{}{}{}

\EasyCrypt's tactics, when applicable, reduce the first goal to zero
or more subgoals.  E.g., if the first goal is
\ecinput{examps/tactics-examp1-3.0.ec}{}{}{}{}
then applying the \ec{if} tactic (handle a conditional) reduces
(replaces) this goal with the two goals
\ecinput{examps/tactics-examp1-3.1.ec}{}{}{}{} and
\ecinput{examps/tactics-examp1-3.2.ec}{}{}{}{}
(leaving the remaining goals, if any, unchanged).
If the first goal is
\ecinput{examps/tactics-examp1-6.0.ec}{}{}{}{}
then applying the \ec{smt} tactic (try to solve the goal using
SMT provers) solves the goal, i.e., replaces it with no subgoals.
Applying a tactic may fail; in this case an error message is issued
and the list of goals is left unchanged.

A lemma's proof may be saved, using the step \ec{qed}, when the list
of goals becomes empty. And this must be done before anything else may
be done.

\section{Ambient logic}
\label{sec:ambientlogic}

In this section, we describe the tactics of \EasyCrypt's
ambient logic.

\subsection{Proof Terms}
\label{subsec:proofterms}

Formulas introduce identifier and formula assumptions using universal
quantifiers and implications. For example, the formula
\begin{easycrypt}{}{}
forall (x y : bool), x = y => forall (z : bool), y = z => x = z.
\end{easycrypt}
introduces the assumptions
\begin{easycrypt}{}{}
x  : bool
y  : bool
H1 : x = y
z  : bool
H2 : y = z
\end{easycrypt}
(where the names of the two formulas are arbitrary), and has
\ec{x = z} as its conclusion.

\EasyCrypt has \emph{proof terms}, which partially describe how
to prove a formula.  Their syntax is described in Figure~\ref{fig:proofterms},
where $X$ ranges over lemma (or formula assumption) names.
\begin{figure}
  \begin{center}
  \begin{tabular}{rcl>{\bf}l}
    $p$ & ::=
      & {\ec{_}} & proof hole \\
     && {\ec{($X$, $\;q_1$, $\;\ldots$, $\;q_n$)}} & lemma application \\
    $q$ & ::=
      & {$e$} & expression \\
      && {$p$} & proof term \\
  \end{tabular}
  \end{center}
  \caption{\label{fig:proofterms} \EasyCrypt's Proof Terms}
\end{figure}
A proof term for a lemma (or formula assumption) $X$ has components
corresponding to the assumptions introduced by $X$.  A component
corresponding to a variable consists of an expression of the
variable's type. The proof term is explaining how the instantiation of
the lemma's conclusion with these expressions may be proved from the
instantiation of the formula components.  A formula component consists
of a proof term explaining how the instantiation of the formula
component may be proved.  Proof holes will get turned into subgoals
when a proof term is applied, e.g., by the \ec{apply} tactic.

Consider, e.g., the following declarations and axioms
\begin{easycrypt}{}{}
pred P : int.
pred Q : int.
pred R : int.
axiom P (x : int) : P x.
axiom Q (x : int) : P x => Q x.
axiom R (x : int) : P(x + 1) => Q x => R x.
\end{easycrypt}
Then, given that \ec{x : int} is an assumption,
\begin{easycrypt}{}{}
(R x (P(x + 1)) (Q x (P x)))
\end{easycrypt}
is a proof term proving the conclusion \ec{R x}. And
\begin{easycrypt}{}{}
(R x _ (Q x _))
\end{easycrypt}
is a proof term that, when applied to a goal with conclusion \ec{R x},
will generated subgoals with conclusions \ec{P(x + 1)} and \ec{P x},
corresponding to the first and second occurrences of \ec{_}.  When
using a proof term at the top-level, e.g., via \ec{apply}, one may
abbreviate some or all of its expressions to \ec{_}, letting
\EasyCrypt infer the expressions from the conclusion of the goal at
hand. Going even further, one may abbreviate a single-level proof term
with lemma $X$ to just $X$, e.g., writing \ec{R} for \ec{(R _ _ _)}.
Applying \ec{R} to \ec{R x} will generate two subgoals: \ec{P(x + 1)}
and \ec{Q x}. Below, we'll consider such abbreviates to \emph{be} proof
terms.

\subsection{Occurrence Selectors}
\label{subsec:occsels}

Some ambient logic tactics use \emph{occurrence selectors} to restrict
their operation to certain occurrences of a term or formula in a
goal's conclusion or formula assumption. The syntax is \ec{\{$i_1$,
  $\;\ldots$, $\;i_n$\}}, specifying that only occurrences $i_1$
throught $i_n$ of the term/formula in a depth-first, left-to-right
traversal of the goal's conclusion or formula assumption should be
operated on. Specifying \ec{\{- $i_1$, $\;\ldots$, $\;i_n$\}}
restricts attention to all occurrences \emph{not} in the following
list.

\subsection{Intro-patterns and Generalization}
\label{subsec:intropatterns}

One moves the assumptions of a goal's conclusions into the goal's
ordered set of assumptions using the introduction tactical.
\textbf{Description of intro-patterns and matching tomorrow!}

\begin{tactic}[$t$ =>$\;\iota_1 \cdots \iota_n$]{introduction}
  \begin{tsyntax}[empty]{t=> ip1 ... ipn}
    Runs the tactic $t$, processing the resulting goals with the
    introduction patterns $\iota_1$, \ldots, $\iota_n$.

    For example, if the current goal is
    \ecinput{examps/tactics/introduction/1-1.0.ec}{}{}{}{}
    then running
    \ecinput{examps/tactics/introduction/1-1.ec}{}{}{}{}
    produces
    \ecinput{examps/tactics/introduction/1-1.1.ec}{}{}{}{}

    For example, if the current goal is
    \ecinput{examps/tactics/introduction/2-1.0.ec}{}{}{}{}
    then running
    \ecinput{examps/tactics/introduction/2-1.ec}{}{}{}{}
    produces
    \ecinput{examps/tactics/introduction/2-1.1.ec}{}{}{}{}

    For example, if the current goal is
    \ecinput{examps/tactics/introduction/3-1.0.ec}{}{}{}{}
    then running
    \ecinput{examps/tactics/introduction/3-1.ec}{}{}{}{}
    produces
    \ecinput{examps/tactics/introduction/3-1.1.ec}{}{}{}{}

    For example, if the current goal is
    \ecinput{examps/tactics/introduction/4-1.0.ec}{}{}{}{}
    then running
    \ecinput{examps/tactics/introduction/4-1.ec}{}{}{}{}
    produces
    \ecinput{examps/tactics/introduction/4-1.1.ec}{}{}{}{}

    For example, if the current goal is
    \ecinput{examps/tactics/introduction/5-1.0.ec}{}{}{}{}
    then running
    \ecinput{examps/tactics/introduction/5-1.ec}{}{}{}{}
    produces
    \ecinput{examps/tactics/introduction/5-1.1.ec}{}{}{}{}
    And then running
    \ecinput{examps/tactics/introduction/5-2.ec}{}{}{}{}
    on this goal produces
    \ecinput{examps/tactics/introduction/5-2.1.ec}{}{}{}{}

    For example, if the current goal is
    \ecinput{examps/tactics/introduction/6-1.0.ec}{}{}{}{}
    then running
    \ecinput{examps/tactics/introduction/6-1.ec}{}{}{}{}
    produces
    \ecinput{examps/tactics/introduction/6-1.1.ec}{}{}{}{}
    and
    \ecinput{examps/tactics/introduction/6-1.2.ec}{}{}{}{}

    For example, if the current goal is
    \ecinput{examps/tactics/introduction/7-1.0.ec}{}{}{}{}
    then running
    \ecinput{examps/tactics/introduction/7-1.ec}{}{}{}{}
    produces
    \ecinput{examps/tactics/introduction/7-1.1.ec}{}{}{}{}
    and
    \ecinput{examps/tactics/introduction/7-1.2.ec}{}{}{}{}
  \end{tsyntax}
\end{tactic}

Generalization moves assumptions back into a goal's conclusion:

\begin{tactic}[generalize $\;\pi_1 \cdots \pi_n$]{generalize}
  \begin{tsyntax}[empty]{generalize $\;\pi_1 \cdots \pi_n$}
    Generalize the patterns $\pi_1, \cdots, \pi_n$, starting from
    $\pi_n$ and going back.

    If a pattern $\pi$ is an assumption, it's moved back into the
    conclusion, using universal quantification or an implication,
    as appropriate. If one assumption depends on another, one can't
    generalize the later without also generalizing the former.

    For example, if the current goal is
    \ecinput{examps/tactics/generalize/2-1.0.ec}{}{}{}{}
    then running
    \ecinput{examps/tactics/generalize/2-1.ec}{}{}{}{}
    produces
    \ecinput{examps/tactics/generalize/2-1.1.ec}{}{}{}{}
    In this example, one can't generalize \ec{x} without also
    generalizing \ec{H1}.

    A pattern $\pi$ may also be a subformula or subterm of the goal,
    or \ec{_}, which standard for the whole goal, possibly prefixed by
    an occurrence selector. This replaces the formula or subterm
    with a universally quantified identifier of the approprate type.

    For example, if the current goal is
    \ecinput{examps/tactics/generalize/1-1.0.ec}{}{}{}{}
    then running
    \ecinput{examps/tactics/generalize/1-1.ec}{}{}{}{}
    produces
    \ecinput{examps/tactics/generalize/1-1.1.ec}{}{}{}{}
  \end{tsyntax}
\end{tactic}

\subsection{Ambient Logic Tactics}

\input{tactics/idtac.tex}
\input{tactics/move.tex}
\input{tactics/clear.tex}
\input{tactics/done.tex}
\input{tactics/apply.tex}
\input{tactics/exact.tex}
\input{tactics/assumption.tex}
\input{tactics/pose.tex}
\input{tactics/have.tex}
\input{tactics/cut.tex}

\input{tactics/rewrite.tex}
\input{tactics/subst.tex}

\input{tactics/split.tex}
\input{tactics/left.tex}
\input{tactics/right.tex}

\input{tactics/case.tex}
\input{tactics/elim.tex}

\input{tactics/simplify.tex}
\input{tactics/change.tex}
\input{tactics/progress.tex}

\input{tactics/reflexivity.tex}
\input{tactics/congr.tex}
\input{tactics/algebra.tex}

\input{tactics/trivial.tex}
\input{tactics/smt.tex}

\input{tactics/admit.tex}

\section{Tacticals}
\label{sec:tacticals}

Tactics can be combined together, composed and modified by
\emph{tacticals}. Tacticals do not correspond to any deduction rule
but make the proof process smoother, and sometimes permit the reuse of
proofs with similar patterns, but where the fine minutiae might
differ.

\begin{tactic}[t1; t2]{sequence}
  \begin{tsyntax}[empty]{t1; t2}
  Execute \ec{t1} and then \ec{t2} on all the subgoals generated by \ec{t1}.
  \end{tsyntax}
\end{tactic}

\begin{tactic}[try t]{failure recovery}\label{tactic-try}
  \begin{tsyntax}[empty]{try t}
  Execute the tactic \ec{t} if it succeeds; do nothing if it fails.

  \paragraph{Remark.}
  By default, \EasyCrypt proofs are run in \ec{strict} mode. In this
  mode, \ec{smt} failures cannot be caught using \ec{try}. This allows
  \EasyCrypt to always build the proof tree correctly, even in weak
  check mode, where \ec{smt} calls are assumed to succeed. Inside a
  strict proof, weak check mode can be turned on and off at will,
  allowing for the fast replay of proof sections during
  development. In any event, we recommend \emph{never} using \ec{try
    smt}: a little thought is much more cost-effective than failing
  \ec{smt} calls.
  \end{tsyntax}
\end{tactic}

\begin{tactic}[do! t]{tactic repetition}
  \begin{tsyntax}[empty]{do! t}
  Apply \ec{t} to the current goal, then repeatedly apply it to all subgoals,
  stopping only when it fails. An error is produced it \ec{t} does not apply to
  the current goal.
  \end{tsyntax}

  \paragraph{Variants.}\strut

  \begin{tabularx}{\textwidth}{@{}ll@{}}
  {\ec{do ?t}} & apply {\ec{t}} 0 or more times, until it fails\\
  {\ec{do n !t}} & apply {\ec{t}} with depth exactly {\ec{n}}\\
  {\ec{do n ?t}} & apply {\ec{t}} with depth at most {\ec{n}}
  \end{tabularx}
\end{tactic}

\begin{tactic}[t1; first t2]{goal selection}
  \begin{tsyntax}[empty]{t1; first t2}
  Apply the tactic \ec{t1}, then apply \ec{t2} on the first subgoal
  generated by \ec{t1}. An error is produced if no subgoals have been
  generated by \ec{t1}.

  \paragraph{Variants.}\strut

  \noindent\begin{tabularx}{\textwidth}{@{}ll@{}}
  {\ec{t1; first n t2}} & apply {\ec{t2}} on the first {\ec{n}} subgoals
    generated by {\ec{t1}}\\
  {\ec{t1; last t2}} & apply {\ec{t2}} on the last subgoal
    generated by {\ec{t1}}\\
  {\ec{t1; last n t2}} & apply {\ec{t2}} on the last {\ec{n}} subgoals
    generated by {\ec{t1}}\\
  {\ec{t; first n last}} & \parbox{200pt}{reorder the subgoals generated by {\ec{t}}, moving
    the first n to the end of the list}
  \end{tabularx}
  \end{tsyntax}
\end{tactic}

\begin{tactic}[by t]{closing goals}
  \begin{tsyntax}[empty]{by t}
  Apply the tactic \ec{t} and try to close all the generated subgoals using
  \rtactic{trivial}. Fail if not all subgoals can be closed.
  \end{tsyntax}
\end{tactic}

\section{Program Logics}
\label{sec:programlogics}

In this section, we describe the tactics of \EasyCrypt's three program
logics: \prhl, \phl and \hl.  There are five rough classes of program
logic tactics:
\begin{enumerate}
\item those that actually reason about the program in Hoare logic
  style;

\item those that correspond to semantics-preserving program
  transformations or compiler optimizations;

\item those that operate at the level of specifications,
  strenghtening, combining or splitting goals without modifying the
  program;

\item tactics that automate the application of other tactics;

\item advanced tactics for handling eager/lazy sampling and bounding
  the probability of failure.
\end{enumerate}
We discuss these five classes in turn.

\subsection{Tactics for Reasoning about Programs}
\label{subsec:reasoningprograms}

Unless specified, the following program logic tactics operate on a
program's last statement. Although we describe these tactics as if
they operated on single statements, their practical implementation
automatically and implicitly applies tactic \rtactic{seq} to deal with
context when necessary.

For simple proofs, it is often enough to simply apply the program
tactic corresponding to the last statement in the program and let
\ec{smt} deal with the residual program-free formula, once the program
has been consumed.

Most of the program reasoning tactics discussed in this subsection
have two modes when used on \prhl proof obligations. Their default
mode is to operate on both programs at once. When a side is specified
(using \ec{<tactic>\{1\}} or \ec{<tactic>\{2\}}), a one-sided variant
is used. Apart from the \rtactic{if} tactic, the one-sided variant is
in fact a combination of the \phl tactic and \rtactic{conseq}.

\medskip

\input{tactics/skip.tex}
\input{tactics/seq.tex}
\input{tactics/sp.tex}
\input{tactics/wp.tex}
\input{tactics/rnd.tex}
\input{tactics/if.tex}
\input{tactics/while.tex}
\input{tactics/call.tex}
\input{tactics/proc.tex}

\subsection{Tactics for Transforming Programs}
\label{subsec:transformingprograms}

\input{tactics/swap.tex}
\input{tactics/inline.tex}

\input{tactics/rcondf.tex}
\input{tactics/rcondt.tex}

\input{tactics/splitwhile.tex}
\input{tactics/unroll.tex}
\input{tactics/fission.tex}
\input{tactics/fusion.tex}

\input{tactics/alias.tex}
\input{tactics/cfold.tex}
\input{tactics/kill.tex}
\input{tactics/modpath.tex}

\subsection{Tactics for Reasoning about Specifications}

\input{tactics/symmetry.tex}
\input{tactics/transitivity.tex}
\input{tactics/conseq.tex}
\input{tactics/case_pl.tex}
\input{tactics/phoare_split.tex}
\input{tactics/byequiv.tex}
\input{tactics/byphoare.tex}
\input{tactics/hoare.tex}
\input{tactics/bypr.tex}
\input{tactics/exists_star.tex}
\input{tactics/elim_star.tex}
\input{tactics/exfalso.tex}

\subsection{Automated Tactics}
\label{subsec:automatedtactics}

\input{tactics/auto.tex}
\input{tactics/sim.tex}

\subsection{Advanced Tactics}
\label{subsec:advancedtactics}

\input{tactics/eager.tex}
\input{tactics/fel.tex}
