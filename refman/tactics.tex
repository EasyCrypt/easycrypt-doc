\chapter{Tactics}
\label{Tactics}

Proofs in \EasyCrypt are carried out using \emph{tactics}, logical
rules embodying general reasoning principles, which transform the
current lemma (or \emph{goal}) into zero or more
\emph{subgoals}---sufficient conditions for the lemma/goal to
hold. Simple ambient logic goals may be automatically proved using SMT
solvers.

In this chapter, we introduce \EasyCrypt's proof engine, before
describing the tactics for \EasyCrypt's four logics: ambient, \prhl,
\phl and \hl.

\section{Proof Engine}

\EasyCrypt's proof engine works with goal lists, where a \emph{goal}
has three parts:
\begin{itemize}
\item A set of type variables.

\item A set of \emph{assumptions}, consisting of identifiers with
  their types, memories, module names with their module types and
  restrictions, and named formulas. An identifier's type may involve
  the type variables, the formulas may involve the type variables,
  identifiers, memories and module names.

\item A \emph{conclusion}, consisting of a single formula, with
  the same constraints as the assumption formulas.
\end{itemize}
Informally, to prove a goal, one must show the conclusion to be true,
given the truth of the formula assumptions, for all valid instantiations
of the assumption identifiers, memories and module names.

For example,
\ecinput{examps/tactics-examp0-2.1.ec}{}{}{}{}
is a goal.
And, in the context of the declarations
\ecinput{examps/tactics-examp2.ec}{}{3-11}{}{}
this is a goal:
\ecinput{examps/tactics-examp2-2.0.ec}{}{}{}{}
The conclusion of this goal is just a nonlinear rendering of the formula
\begin{easycrypt}{}{}
phoare [G(X).g : G.x = n ==> G.x = n] = 1%r.
\end{easycrypt}
\EasyCrypt's pretty printer renders \prhl, \phl and \hl judgements
in such a nonlinear style when the judgements appear as
(as opposed to in) the conclusions of goals.

Internally, \EasyCrypt's proof engine also works with \prhl, \phl and
\hl judgments involving lists of statements rather than procedure
names, which we'll call \emph{statement judgements}, below. For
example, given this declaration
\ecinput{examps/tactics-examp1.ec}{}{3-9}{}{}
this is an \phl statement judgement:
\ecinput{examps/tactics-examp1-3.0.ec}{}{}{}{}
The pre- and post-conditions of a statement judgement may refer to the
parameters and local variables of the procedure that's the
\emph{context} of the conclusion---\ec{M.f} in the preceding
example. They may also refer to the memories \ec{&$1$} and \ec{&$2$}
in the case of \prhl statement judgements.
When a statement judgement appears anywhere other than as the conclusion of
a goal, the pretty printer renders it in abbreviated linear syntax.
E.g., the preceding goal is rendered as
\begin{easycrypt}{}{}
hoare[if (x %% 3 = 1) {...} : x %% 3 = n ==> x %% 3 = n %% 2 + 1]
\end{easycrypt}
Statement judgements can't be directly input by the user.

When the proof of a lemma is begun, the proof engine starts out with
a single goal, consisting of the lemma's statement. E.g.,
the lemma
\ecinput{examps/tactics-examp0.ec}{}{1-3}{}{}
gives rise to the goal
\ecinput{examps/tactics-examp0-1.0.ec}{}{}{}{}
For parameterized lemmas, the goal includes the lemma's parameters
as assumptions. E.g.,
\begin{easycrypt}{}{}
lemma PairEq (x x' : 'a) (y y' : 'b) :
  x = x' => y = y' => (x, y) = (x', y').
\end{easycrypt}
gives rise to
\ecinput{examps/tactics-examp0-2.0.ec}{}{}{}{}

\EasyCrypt's tactics, when applicable, reduce the first goal to zero
or more subgoals.  E.g., if the first goal is
\ecinput{examps/tactics-examp1-3.0.ec}{}{}{}{}
then applying the \ec{if} tactic (handle a conditional) reduces
(replaces) this goal with the two goals
\ecinput{examps/tactics-examp1-3.1.ec}{}{}{}{} and
\ecinput{examps/tactics-examp1-3.2.ec}{}{}{}{}
(leaving the remaining goals, if any, unchanged).
If the first goal is
\ecinput{examps/tactics-examp1-6.0.ec}{}{}{}{}
then applying the \ec{smt} tactic (try to solve the goal using
SMT provers) solves the goal, i.e., replaces it with no subgoals.
Applying a tactic may fail; in this case an error message is issued
and the list of goals is left unchanged.

A lemma's proof may be saved, using the step \ec{qed}, when the list
of goals becomes empty. And this must be done before anything else may
be done.

\section{Ambient logic}
\label{AmbientLogic}

In this section, we describe the tactics of \EasyCrypt's
ambient logic.

\subsection{Intro-patterns and Generalization}
\label{IntroPatterns}

\subsection{Ambient Logic Tactics}

\input{tactics/idtac.tex}
\input{tactics/move.tex}
\input{tactics/clear.tex}
\input{tactics/done.tex}
\input{tactics/apply.tex}
\input{tactics/exact.tex}
\input{tactics/assumption.tex}
\input{tactics/pose.tex}
\input{tactics/have.tex}
\input{tactics/cut.tex}

\input{tactics/rewrite.tex}
\input{tactics/subst.tex}

\input{tactics/split.tex}
\input{tactics/left.tex}
\input{tactics/right.tex}

\input{tactics/case.tex}
\input{tactics/elim.tex}

\input{tactics/simplify.tex}
\input{tactics/change.tex}
\input{tactics/progress.tex}

\input{tactics/reflexivity.tex}
\input{tactics/congr.tex}
\input{tactics/algebra.tex}

\input{tactics/trivial.tex}
\input{tactics/smt.tex}

\input{tactics/admit.tex}

\section{Tacticals}
\label{Tacticals}

Tactics can be combined together, composed and modified by
\emph{tacticals}. Tacticals do not correspond to any deduction rule
but make the proof process smoother, and sometimes permit the reuse of
proofs with similar patterns, but where the fine minutiae might
differ.

\begin{tactic}[t1; t2]{sequence}
  \begin{tsyntax}[empty]{t1; t2}
  Execute \ec{t1} and then \ec{t2} on all the subgoals generated by \ec{t1}.
  \end{tsyntax}
\end{tactic}

\begin{tactic}[try t]{failure recovery}\label{tactic-try}
  \begin{tsyntax}[empty]{try t}
  Execute the tactic \ec{t} if it succeeds; do nothing if it fails.

  \paragraph{Remark.}
  By default, \EasyCrypt proofs are run in \ec{strict} mode. In this
  mode, \ec{smt} failures cannot be caught using \ec{try}. This allows
  \EasyCrypt to always build the proof tree correctly, even in weak
  check mode, where \ec{smt} calls are assumed to succeed. Inside a
  strict proof, weak check mode can be turned on and off at will,
  allowing for the fast replay of proof sections during
  development. In any event, we recommend \emph{never} using \ec{try
    smt}: a little thought is much more cost-effective than failing
  \ec{smt} calls.
  \end{tsyntax}
\end{tactic}

\begin{tactic}[do! t]{tactic repetition}
  \begin{tsyntax}[empty]{do! t}
  Apply \ec{t} to the current goal, then repeatedly apply it to all subgoals,
  stopping only when it fails. An error is produced it \ec{t} does not apply to
  the current goal.
  \end{tsyntax}

  \paragraph{Variants.}\strut

  \begin{tabularx}{\textwidth}{@{}ll@{}}
  {\ec{do ?t}} & apply {\ec{t}} 0 or more times, until it fails\\
  {\ec{do n !t}} & apply {\ec{t}} with depth exactly {\ec{n}}\\
  {\ec{do n ?t}} & apply {\ec{t}} with depth at most {\ec{n}}
  \end{tabularx}
\end{tactic}

\begin{tactic}[t1; first t2]{goal selection}
  \begin{tsyntax}[empty]{t1; first t2}
  Apply the tactic \ec{t1}, then apply \ec{t2} on the first subgoal
  generated by \ec{t1}. An error is produced if no subgoals have been
  generated by \ec{t1}.

  \paragraph{Variants.}\strut

  \noindent\begin{tabularx}{\textwidth}{@{}ll@{}}
  {\ec{t1; first n t2}} & apply {\ec{t2}} on the first {\ec{n}} subgoals
    generated by {\ec{t1}}\\
  {\ec{t1; last t2}} & apply {\ec{t2}} on the last subgoal
    generated by {\ec{t1}}\\
  {\ec{t1; last n t2}} & apply {\ec{t2}} on the last {\ec{n}} subgoals
    generated by {\ec{t1}}\\
  {\ec{t; first n last}} & \parbox{200pt}{reorder the subgoals generated by {\ec{t}}, moving
    the first n to the end of the list}
  \end{tabularx}
  \end{tsyntax}
\end{tactic}

\begin{tactic}[by t]{closing goals}
  \begin{tsyntax}[empty]{by t}
  Apply the tactic \ec{t} and try to close all the generated subgoals using
  \rtactic{trivial}. Fail if not all subgoals can be closed.
  \end{tsyntax}
\end{tactic}

\section{Program Logics}
\label{ProgramLogics}

In this section, we describe the tactics of \EasyCrypt's three program
logics: \prhl, \phl and \hl.  There are five rough classes of program
logic tactics:
\begin{enumerate}
\item those that actually reason about the program in Hoare logic
  style;

\item those that correspond to semantics-preserving program
  transformations or compiler optimizations;

\item those that operate at the level of specifications,
  strenghtening, combining or splitting goals without modifying the
  program;

\item tactics that automate the application of other tactics;

\item advanced tactics for handling eager/lazy sampling and bounding
  the probability of failure.
\end{enumerate}
We discuss these five classes in turn.

\subsection{Tactics for Reasoning about Programs}
\label{ReasoningPrograms}

Unless specified, the following program logic tactics operate on a
program's last statement. Although we describe these tactics as if
they operated on single statements, their practical implementation
automatically and implicitly applies tactic \rtactic{seq} to deal with
context when necessary.

For simple proofs, it is often enough to simply apply the program
tactic corresponding to the last statement in the program and let
\ec{smt} deal with the residual program-free formula, once the program
has been consumed.

Most of the program reasoning tactics discussed in this subsection
have two modes when used on \prhl proof obligations. Their default
mode is to operate on both programs at once. When a side is specified
(using \ec{<tactic>\{1\}} or \ec{<tactic>\{2\}}), a one-sided variant
is used. Apart from the \rtactic{if} tactic, the one-sided variant is
in fact a combination of the \phl tactic and \rtactic{conseq}.

\medskip

\input{tactics/skip.tex}
\input{tactics/seq.tex}
\input{tactics/sp.tex}
\input{tactics/wp.tex}
\input{tactics/rnd.tex}
\input{tactics/if.tex}
\input{tactics/while.tex}
\input{tactics/call.tex}
\input{tactics/proc.tex}

\subsection{Tactics for Transforming Programs}
\label{TransformingPrograms}

\input{tactics/swap.tex}
\input{tactics/inline.tex}

\input{tactics/rcondf.tex}
\input{tactics/rcondt.tex}

\input{tactics/splitwhile.tex}
\input{tactics/unroll.tex}
\input{tactics/fission.tex}
\input{tactics/fusion.tex}

\input{tactics/alias.tex}
\input{tactics/cfold.tex}
\input{tactics/kill.tex}
\input{tactics/modpath.tex}

\subsection{Tactics for Reasoning about Specifications}

\input{tactics/symmetry.tex}
\input{tactics/transitivity.tex}
\input{tactics/conseq.tex}
\input{tactics/case_pl.tex}
\input{tactics/phoare_split.tex}
\input{tactics/byequiv.tex}
\input{tactics/byphoare.tex}
\input{tactics/hoare.tex}
\input{tactics/bypr.tex}
\input{tactics/exists_star.tex}
\input{tactics/elim_star.tex}
\input{tactics/exfalso.tex}

\subsection{Automated Tactics}
\label{AutomatedTactics}

\input{tactics/auto.tex}
\input{tactics/sim.tex}

\subsection{Advanced Tactics}
\label{AdvancedTactics}

\input{tactics/eager.tex}
\input{tactics/fel.tex}
