% --------------------------------------------------------------------
\begin{tactic}{fel}
  \begin{tsyntax}{fel $\;\mathit{init}$ $\;\mathit{ctr}$ $\;\mathit{stepub}$
                      $\;\mathit{bound}$ $\;\mathit{bad}$ $\;\mathit{conds}$}
    ``fel'' stands for ``failure event lemma''. To use this tactic,
    one must load the theory \ec{FelTactic}. To be applicable, the
    current goal's conclusion must have the form
    \begin{center}
      \ec{Pr[$M$.$p$($a_1$, $\;\ldots$, $\;a_r$) @ &$m$ : $\;\phi$] <= $\;\mathit{ub}$}.
    \end{center}
    Here:
    \begin{itemize}
    \item $\mathit{ub}$ (``upper bound'') is an expression of type \ec{real}.

    \item $\mathit{ctr}$ is the \emph{counter}, an expression of
      type \ec{int} involving program variables.

    \item $\mathit{bad}$ is an expression of type \ec{bool} involving
      program variables. It is the ``bad'' or ``failure'' event.

    \item $\mathit{init}$ is a natural number no bigger than the
      number of statements in $M$.$p$. It is length of the initial
      part of the procedure that ``initializes'' the failure event
      lemma---causing $\mathit{ctr}$ to become $0$ and $\mathit{bad}$
      to become \ec{false}. The non-initialization part of the
      procedure may not \emph{directly} use the program variables on
      which $\mathit{ctr}$ and $\mathit{bad}$ depend. These variables
      may only be modified by concrete procedures \ec{$M$.$p$} may
      directly or indirectly call---such procedures are called
      \emph{oracle procedures}.  If \ec{$M$.$p$} directly or
      indirectly calls an abstract procedure, there must be a module
      constraint saying that the abstract procedure may not modify the
      program variables determining the values of $\mathit{ctr}$ and
      $\mathit{bad}$ or that are used by the oracle procedures.

    \item $\mathit{bound}$ is an expression of type \ec{int} not
      involving program variables. It is an upper bound on the value
      of the counter. The oracle procedures must not increase the
      counter beyond this bound. It must be the case that $\phi$
      implies \ec{$\mathit{bad}$ /\\ $\;\mathit{ctr}$ <=
        $\;\mathit{bound}$}.

    \item $\mathit{conds}$ is a list of \emph{procedure preconditions}
      \begin{center}
        \ec{[$N_1$.$p_1$ : $\;\phi_1$; $\;\ldots$ $\;N_l$.$p_l$ : $\;\phi_l$]},
      \end{center}
      where the $N_i$.$p_i$ are procedures, and the $\phi_i$ are
      expressions of type \ec{bool} involving program variables and
      procedure parameters.  When a procedure's precondition is true,
      it must increase the counter's value (and may cause
      $\mathit{bad}$ to become true); when it isn't true, it must
      preserve the counter's value (as well as the value of
      $\mathit{bad}$).

    \item $\mathit{stepub}$ is a function of type \ec{int -> real},
      intuitively providing an upper bound as a function of the
      counter's current value. When a procedure's precondition holds,
      the probability that $\mathit{bad}$ becomes set during that
      single call must be upper-bounded by the application of
      $\mathit{stepub}$ to the counter's value. It must be the case
      that the summation of \ec{$\mathit{stepub}$ $\;i$}, as $i$
      ranges from $0$ to $\mathit{bound} - 1$, is upper-bounded by
      $\mathit{ub}$.

    \end{itemize}
    The subgoals generated by \ec{fel} enforce the above rules. The
    best way to understand the details is by an example.

    \medskip For example, consider the declarations
    \ecinput{examps/tactics/fel/1.ec}{}{30-76}{} Here, the oracle has
    a boolean variable \ec{won}, which is the bad event. It also has a
    list of integers \ec{gens}, all of which are within the range $1$
    to \ec{upp}, inclusive---the integers ``generated'' so far. The
    counter is the size of \ec{gens}. The procedure \ec{gen} randomly
    generates such an integer, setting \ec{won} to \ec{true} if the
    integer was previously generated. And the procedure \ec{add} adds
    a new integer to the list of generated integers, without possibily
    setting \ec{bad}. Both \ec{gen} and \ec{add} do nothing when the
    counter reaches the bound \ec{n}.  The adversary has access to both
    \ec{gen} and \ec{bad}.

    Suppose that our goal is to prove
    \ecinput{examps/tactics/fel/1.ec}{}{111-112}{}
    We can't prove this directly, using \ec{fel}. Instead, we
    must first prove
    \ecinput{examps/tactics/fel/1.ec}{}{78-80}{}
    and then use \rtactic{byequiv} to obtain \ec{G_UB}.

    If the current goal is
    \ecinput{examps/parts/tactics/fel/1-1.0.ec}{}{}{}{} then
    running \ecinput{examps/parts/tactics/fel/1-1.ec}{}{}{}{}
    produces the goals
    \ecinput{examps/parts/tactics/fel/1-1.1.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.2.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.3.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.4.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.5.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.6.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.7.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.8.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.9.ec}{}{}{}{}
  \end{tsyntax}

  \begin{tsyntax}{fel $\;\mathit{init}$ $\;\mathit{ctr}$ $\;\mathit{stepub}$
                      $\;\mathit{bound}$ $\;\mathit{bad}$ $\;\mathit{conds}$
                      $\;\mathit{inv}$}
    This variant of \ec{fel} is like the preceding one except for
    the addition of an invariant, $\mathit{inv}$, argument, which must be
    established by \ec{$M$.$p$} and which the oracle procedures must
    preserve.

    \medskip For example, consider the declarations
    \ecinput{examps/tactics/fel/2.ec}{}{30-80}{}
    These are similar to the ones used to illustrate the preceding
    variant of \ec{fel}, except that this time an explicit counter
    variable \ec{Or.ctr} is used, and \ec{fel}'s optional invariant
    is used to ensure the counter's value is continually equal
    to the size of \ec{Or.gens}.

    Suppose that our goal is to prove
    \ecinput{examps/tactics/fel/2.ec}{}{116-117}{} As with the
    preceduing variant, we can't prove this directly, using
    \ec{fel}. Instead, we must first prove
    \ecinput{examps/tactics/fel/2.ec}{}{82-84}{} and then use
    \rtactic{byequiv} to obtain \ec{G_UB}.

    If the current goal is
    \ecinput{examps/parts/tactics/fel/2-1.0.ec}{}{}{}{} then
    running \ecinput{examps/parts/tactics/fel/2-1.ec}{}{}{}{}
    produces the goals
    \ecinput{examps/parts/tactics/fel/2-1.1.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/2-1.2.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/2-1.3.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/2-1.4.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/2-1.5.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/2-1.6.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/2-1.7.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/2-1.8.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/2-1.9.ec}{}{}{}{}
  \end{tsyntax}
\end{tactic}
