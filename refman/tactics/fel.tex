% --------------------------------------------------------------------
\begin{tactic}{fel}
  \begin{tsyntax}{fel $\;\mathit{init}$ $\;\mathit{ctr}$ $\;\mathit{stepub}$
                      $\;\mathit{bound}$ $\;\mathit{bad}$ $\;\mathit{conds}$
                      $\;\mathit{inv}$}
    ``fel'' stands for ``failure event lemma''. To use this tactic,
    one must load the theory \ec{FelTactic}. To be applicable, the
    current goal's conclusion must have the form
    \begin{center}
      \ec{Pr[$M$.$p$($a_1$, $\;\ldots$, $\;a_r$) @ &$m$ : $\;\phi$] <= $\;\mathit{ub}$}.
    \end{center}
    Here:
    \begin{itemize}
    \item $\mathit{ub}$ (``upper bound'') is an expression of type \ec{real}.

    \item $\mathit{ctr}$ is the \emph{counter}, an expression of
      type \ec{int} involving program variables.

    \item $\mathit{bad}$ is an expression of type \ec{bool} involving
      program variables. It is the ``bad'' or ``failure'' event.

    \item $\mathit{inv}$ is an optional invariant on program
      variables; if it's omitted, \ec{true} is used.

    \item $\mathit{init}$ is a natural number no bigger than the
      number of statements in $M$.$p$. It is the length of the initial
      part of the procedure that ``initializes'' the failure event
      lemma---causing $\mathit{ctr}$ to become $0$ and $\mathit{bad}$
      to become \ec{false} and establishing $\mathit{inv}$.  The
      non-initialization part of the procedure may not \emph{directly}
      use the program variables on which $\mathit{ctr}$,
      $\mathit{bad}$ and $\mathit{inv}$ depend. These variables may
      only be modified by concrete procedures \ec{$M$.$p$} may
      directly or indirectly call---such procedures are called
      \emph{oracle procedures}.  If \ec{$M$.$p$} directly or
      indirectly calls an abstract procedure, there must be a module
      constraint saying that the abstract procedure may not modify the
      program variables determining the values of $\mathit{ctr}$,
      $\mathit{bad}$ and $\mathit{inv}$ or that are used by the oracle
      procedures.

    \item $\mathit{bound}$ is an expression of type \ec{int}. It must
      be the case that
      \begin{center}
        \ec{$\phi$ /\\ $\;\mathit{inv}$ => $\;\mathit{bad}$ /\\
            $\;\mathit{ctr}$ <= $\;\mathit{bound}$}.
      \end{center}

    \item $\mathit{conds}$ is a list of \emph{procedure preconditions}
      \begin{center}
        \ec{[$N_1$.$p_1$ : $\;\phi_1$; $\;\ldots$; $\;N_l$.$p_l$ : $\;\phi_l$]},
      \end{center}
      where the $N_i$.$p_i$ are procedures, and the $\phi_i$ are
      expressions of type \ec{bool} involving program variables and
      procedure parameters.  When a procedure's precondition is true,
      it must increase the counter's value; when it isn't true, it
      must not decrease the counter's value, and must preserve the
      value of $\mathit{bad}$. Whether a procedure's precondition
      holds or not, the invariant $\mathit{inv}$ must be preserved.

    \item $\mathit{stepub}$ is a function of type \ec{int -> real},
      providing an upper bound as a function of the
      counter's current value. When a procedure's precondition, the
      invariant $\mathit{inv}$, \ec{!$\mathit{bad}$} and \ec{0 <=
        $\;\mathit{ctr}$ < $\;\mathit{bound}$} hold, the probability
      that $\mathit{bad}$ becomes set during that call must be
      upper-bounded by the application of $\mathit{stepub}$ to the
      counter's value.  In addition, it must be the case that the
      summation of \ec{$\mathit{stepub}$ $\;i$}, as $i$ ranges from
      $0$ to $\mathit{bound} - 1$, is upper-bounded by $\mathit{ub}$.

    \end{itemize}
    The subgoals generated by \ec{fel} enforce the above rules. The
    best way to understand the details is via an example.

    \medskip For example, consider the declarations
    \ecinput{examps/tactics/fel/1.ec}{}{30-76}{} Here, the oracle has
    a boolean variable \ec{won}, which is the bad event. It also has a
    list of integers \ec{gens}, all of which are within the range $1$
    to \ec{upp}, inclusive---the integers ``generated'' so far. The
    counter is the size of \ec{gens}. The procedure \ec{gen} randomly
    generates such an integer, setting \ec{won} to \ec{true} if the
    integer was previously generated. And the procedure \ec{add} adds
    a new integer to the list of generated integers, without possibily
    setting \ec{bad}. Both \ec{gen} and \ec{add} do nothing when the
    counter reaches the bound \ec{n}.  The adversary has access to both
    \ec{gen} and \ec{bad}.

    If the current goal is
    \ecinput{examps/parts/tactics/fel/1-1.0.ec}{}{}{}{} then
    running \ecinput{examps/parts/tactics/fel/1-1.ec}{}{}{}{}
    produces the goals
    \ecinput{examps/parts/tactics/fel/1-1.1.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.2.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.3.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.4.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.5.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.6.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.7.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.8.ec}{}{}{}{}
    and
    \ecinput{examps/parts/tactics/fel/1-1.9.ec}{}{}{}{}
  \end{tsyntax}
\end{tactic}
