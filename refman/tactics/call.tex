% --------------------------------------------------------------------
\begin{tactic}{call}
  All variants of the \ec{call} tactic implicitly make use of a frame
  rule, based on a ``may modify'' analysis.

  \begin{tsyntax}{call (_: P ==> Q)}
  Compute the precondition of a procedure call using the given
  specification for the procedure. As a side-goal, prove that the
  procedure fulfills the given specification.

  As with other tactics, the specification \ec{(_: P ==> Q)} can be
  replaced with a lemma from which the specification is inferred.
  \end{tsyntax}

  \begin{tsyntax}{call (_: I)}
  Uses invariant \ec{I} to infer a specification for use with
  \ec{tactic}.

  In \prhl, and if \ec{A} is the abstract module, \ec{call (_: I)}
  is equivalent to

  \begin{center}
  \ec{call (_: =\{arg,glob A\} /\\ I ==> =\{res,glob A\} /\\ I); first proc I.}
  \end{center}

  In \phl and \hl, \ec{call (_: I)} is equivalent to:

  \begin{center}
  \ec{call (_: I ==> I); first proc I.}
  \end{center}
  \end{tsyntax}

  \begin{tsyntax}{call (_: B, I)}
  On \prhl abstract procedures only. If \ec{A} is the abstract module,
  \ec{call (_: B, I)} is equivalent to:

  \begin{center}
  \ec{call (_: !B /\\ =\{arg,glob A\} /\\ I ==> !B => =\{res, glob A\} /\\ I); first proc B I.}
  \end{center}
  \end{tsyntax}

  \begin{tsyntax}{call (_: B, I, I')}
  On \prhl abstract procedures only. If \ec{A} is the abstract module,
  \ec{call (_: B, I)} is equivalent to

  \begin{center}
  \ec{call (_: !B /\\ =\{arg,glob A\} /\\ I ==> $\ \phi$); first proc B I I'.}
  \end{center}
  
  \noindent where $\phi =\ $ \ec{if !B then =\{res,glob A\} /\\ I else I'}.
  \end{tsyntax}

  \textbf{Note:} When using the invariant-based variants of
  \ec{call}, error messages may be originating from the underlying
  application of \rtactic{proc}. In particular, when using them to
  deal with abstract procedure calls, the invariant \emph{should not}
  refer to memory locations the abstract procedure may modify.
\end{tactic}
