% --------------------------------------------------------------------
\begin{tactic}{conseq}
  \begin{tsyntax}{conseq <spec>}
  Rule of consequence. Proves a specification by weakening of a
  stronger result. Any one of the specification places can be filled
  with a wildcard \ec{_} to keep the value it contains in the current
  goal and trivially discharge the corresponding subgoal.

  \paragraph{Examples:}\strut
  
  \begin{cmathpar}
  \texample[\prhl{}]
    {\ec{conseq (_: P ==> Q)}}
    {P' \Rightarrow P \\ Q \Rightarrow Q' \\ \pRHL{P}{c}{c'}{Q}}
    {\pRHL{P'}{c}{c'}{Q'}}

  \texample[\phl{}]
    {\ec{conseq (_: P ==> Q: $\;\delta$)}}
    {P' \Rightarrow \delta \mathrel{\diamond} \delta' \\
     P' \Rightarrow P \\
     Q \mathrel{\diamond^\uparrow} Q' \\
     \pHL{P}{c}{Q}{\diamond}{\delta}}
    {\pHL{P'}{c}{Q'}{\diamond}{\delta'}}

  \texample[\hl{}]
    {\ec{conseq (_: P ==> Q)}}
    {P' \Rightarrow P \\ Q \Rightarrow Q' \\ \HL{P}{c}{Q}}
    {\HL{P'}{c}{Q'}}
  \end{cmathpar}

  \textbf{Note:} The \phl variant can also be used to strenghten the
  relation $\diamond$ into an equality by forcing the equality into
  the specification. For example, the following is a valid application
  of \ec{conseq}.

  \begin{cmathpar}
  \texample[\phl{}]
    {\ec{conseq (_: P ==> Q: =$\;\delta$)}}
    {P' \Rightarrow \delta \mathrel{=} \delta' \\
     P' \Rightarrow P \\
     Q \mathrel{\Leftrightarrow} Q' \
     \pHL{P}{c}{Q}{=}{\delta}}
    {\pHL{P'}{c}{Q'}{\leq}{\delta'}}
  \end{cmathpar}  
  \end{tsyntax}

  \begin{tsyntax}{conseq <lemma>}
  Only applies to judgments on procedures. Same as \ec{conseq
  <spec>}, but the specification to use is inferred from
  the lemma provided. Raises an error if the lemma does not refer to
  the expected procedure(s). All variants of \ec{conseq} may take
  lemmas in place of explicit specifications with the same effect, in
  which case they must be applied to judgments on procedures.
  \end{tsyntax}

  \begin{tsyntax}{conseq* <spec>}
  Same as \ec{conseq}, but the subgoal corresponding to the
  postcondition is refined by a ``may modify'' analysis. All variants
  of \ec{conseq} can be refined using the \ec{*}, with the same
  effect.
  \end{tsyntax}

  \begin{tsyntax}{conseq <prhl> <hl> <hl>}
  Combine relational and non-relational specifications to prove a
  relational specification. Either one of the Hoare logic
  specifications can be replaced with a wildcard.

  \paragraph{Examples:}\strut

  \begin{cmathpar}
  \texample[\prhl{}]
    {\ec{conseq (_: P ==> Q) (_: P$_1$ ==> Q$_1$) (_: P$_2$ ==> Q$_2$)}}
    {P' \Rightarrow P \wedge \inmem{P_1}{1} \wedge \inmem{P_2}{2} \\
     Q \wedge \inmem{Q_1}{1} \wedge \inmem{Q_2}{2} \Rightarrow Q' \\
     \HL{P_1}{c_1}{Q_1} \\
     \HL{P_2}{c_2}{Q_2} \\
     \pRHL{P}{c_1}{c_2}{Q}}
    {\pRHL{P'}{c_1}{c_2}{Q'}}
  \end{cmathpar}
  \end{tsyntax}

  \begin{tsyntax}{conseq <prhl> <phl> | conseq <prhl> _ <phl>}
  Strengthen a relational specification where one of the programs is
  empty into a non-relational specification about the non-empty
  program. Fails if the program expected to be empty is not. For
  uniformity and simplicity of use, this variant also allows the user
  to strengthen the \prhl judgment before abstracting its relational
  aspects. The general rule below can be understood more clearly when
  $P = P'$ and $Q = Q'$.

  \paragraph{Examples:}\strut

  \begin{cmathpar}
  \texample[\prhl{}]
    {\ec{conseq (_: P ==> Q) (_: P$_1$ ==> Q$_1$: =1\%r)}}
    {P' \Rightarrow P   \\ Q   \Rightarrow Q' \\
     P  \Rightarrow P_1 \\ Q_1 \Rightarrow Q  \\
     \pHL{P_1}{c}{Q_1}{=}{1}}
    {\pRHL{P'}{c}{\Skip}{Q'}}

  \texample[\prhl{}]
    {\ec{conseq (_: _ ==> _) _ (_: P$_2$ ==> Q$_2$: =1\%r)}}
    {P \Rightarrow P_2 \\ Q_2 \Rightarrow Q \\ \pHL{P_2}{c}{Q_2}{=}{1}}
    {\pRHL{P}{\Skip}{c}{Q}}
  \end{cmathpar}
  \end{tsyntax}

  \fix{Missing descriptions of any variants of conseq}?
\end{tactic}
