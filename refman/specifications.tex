\chapter{Specifications}
\label{Specifications}

In this chapter, we present \EasyCrypt's language for writing
cryptographic specifications.  We start by presenting its typed
expression language, go on to consider its module language for
expressing cryptographic games, and conclude by presenting its four
logics.

\EasyCrypt\ has a typed expression language based on the polymorphic
typed lambda calculus. Expressions are guaranteed to terminate,
although their values may be under-specified.  Its type system has:
\begin{itemize}
\item several pre-defined base types;

\item product (tuple) types;

\item user-defined abbreviations for types and parameterized types; and

\item user-defined concrete datatypes (like lists and trees).
\end{itemize}
In its expression language:
\begin{itemize}
\item operators for the pre-defined base types may be imported from
  the standard library;

\item user-defined operations may be defined, including by
  structural recursion on concrete datatypes.
\end{itemize}
For each type, there is a type of probability distributions over that
type.

\EasyCrypt's modules consist of typed global variables and procedures.
The body of a procedure consists of local variable declartions followed
by a sequence of statements:
\begin{itemize}
\item ordinary assignments;

\item random assignments, assigning values chosen
  from distributions to variables;

\item procedure calls, whose results are assigned to variables;

\item conditional (if-then-else) statements;

\item while loops; and

\item return statements (which may only appear at the end of
  procedures).
\end{itemize}
A procedure's modules may refer to the global variables of previously
declared modules. Modules may be parameterized by abstract modules,
which may be used to model adversaries; and modules types---or
interfaces---may be formalized, describing modules with at least
certain specified procedures with certain types.

\EasyCrypt\ has four logics: a probabilistic, relational Hoare logic
(\prhl), relating pairs of procedures; a probabilistic Hoare logic
(\phl) allowing one to carry out proofs about the probability of a
procedure's execution resulting in a postcondition holding; an
ordinary (possibilistic) Hoare logic (\hl); and an ambient higher
order logic for proving general mathematical facts, as well as for
connecting judgments from the other logics

Proofs are carried out using tactics, which is the focus of
Chapter~\ref{Tactics}.  \EasyCrypt\ also has ways (theories and
sections) of structuring specifications and proofs, which will be
described in Chapter~\ref{Structuring}. In Chapter~\ref{Library},
we'll survey the \EasyCrypt\ Library, which consists of numerous
theories, definining mathematical structures (like groups, rings
and fields), data structures (like finite sets and maps), and
cryptographic constructions (like random oracles and different
forms of encryption).

\section{Lexical Categories}
\label{Lexical}

\EasyCrypt's language has a number of lexical categories:
\begin{itemize}
\item \textbf{Keywords}. \EasyCrypt\ has the following
  \emph{keywords}: \ecn{admit}, \ecn{algebra},
  \ecn{alias}, \ecn{apply}, \ecn{as},
  \ecn{assert}, \ecn{assumption}, \ecn{auto},
  \ecn{axiom}, \ecn{axiomatized}, \ecn{beta},
  \ecn{by}, \ecn{byequiv}, \ecn{byphoare},
  \ecn{bypr}, \ecn{call}, \ecn{case},
  \ecn{cfold}, \ecn{change}, \ecn{class},
  \ecn{clear}, \ecn{clone}, \ecn{congr},
  \ecn{conseq}, \ecn{const}, \ecn{cut},
  \ecn{declare}, \ecn{delta}, \ecn{do},
  \ecn{done}, \ecn{eager}, \ecn{elif},
  \ecn{elim}, \ecn{else}, \ecn{end},
  \ecn{equiv}, \ecn{exact}, \ecn{exfalso},
  \ecn{exists}, \ecn{expect}, \ecn{export},
  \ecn{fel}, \ecn{fieldeq}, \ecn{first},
  \ecn{fission}, \ecn{forall}, \ecn{fun},
  \ecn{fusion}, \ecn{generalize}, \ecn{glob},
  \ecn{goal}, \ecn{have}, \ecn{hint},
  \ecn{hoare}, \ecn{hypothesis}, \ecn{idtac},
  \ecn{if}, \ecn{import}, \ecn{in},
  \ecn{inline}, \ecn{instance}, \ecn{intros},
  \ecn{iota}, \ecn{islossless}, \ecn{kill},
  \ecn{last}, \ecn{left}, \ecn{lemma},
  \ecn{let}, \ecn{local}, \ecn{logic},
  \ecn{modpath}, \ecn{module}, \ecn{move},
  \ecn{nolocals}, \ecn{nosmt}, \ecn{of},
  \ecn{op}, \ecn{phoare}, \ecn{pose},
  \ecn{Pr}, \ecn{pr_bounded}, \ecn{pred},
  \ecn{print}, \ecn{proc}, \ecn{progress},
  \ecn{proof}, \ecn{prover}, \ecn{qed},
  \ecn{rcondf}, \ecn{rcondt}, \ecn{realize},
  \ecn{reflexivity}, \ecn{require}, \ecn{res},
  \ecn{return}, \ecn{rewrite}, \ecn{right},
  \ecn{ringeq}, \ecn{rnd}, \ecn{rwnormal},
  \ecn{search}, \ecn{section}, \ecn{seq},
  \ecn{sim}, \ecn{simplify}, \ecn{skip},
  \ecn{smt}, \ecn{sp}, \ecn{split},
  \ecn{splitwhile}, \ecn{strict}, \ecn{subst},
  \ecn{swap}, \ecn{symmetry}, \ecn{then},
  \ecn{theory}, \ecn{timeout}, \ecn{Top},
  \ecn{transitivity}, \ecn{trivial}, \ecn{try},
  \ecn{type}, \ecn{unroll}, \ecn{var},
  \ecn{while}, \ecn{why3}, \ecn{with},
  \ecn{wp} and \ecn{zeta}.

\item \textbf{Identifiers}. An \emph{identifier} is a sequence of
  letters, digits, underscores (\ecn{_}) and apostrophes
  (\ecn{'}) that begins with a letter or underscore, and isn't
  equal to an underscore or a keyword other than \ecn{expect},
  \ecn{first}, \ecn{last}, \ecn{left},
  \ecn{right} or \ecn{strict}.

\item \textbf{Operator names}. An \emph{operator name} is an
  identifier, a binary operator name, a unary operator name, or
  a mix fix operator name.

\item \textbf{Binary operator names}. A \emph{binary operator name}
  is:
  \begin{itemize}
  \item a nonempty sequence of equal signs (\ec{=}), less
  than signs (\ec{<}), greater than signs (\ec{>}), forward slashes
  (\ec{/}), backward slashes (\ec{\\}), plus signs (\ec{+}), minus
  signs (\ec{-}), times signs (\ec{*}), vertical bars (\ec{|}), colons
  (\ec{:}), ampersands (\ec{&}), up arrows (\ec{^}) and percent signs
  (\ec{\%}); or

  \item a backtick mark (\ec{`}), followed by a nonempty sequence of one
    of these characters, followed by a backtick mark; or

  \item a backward slash followed by a nonempty sequence of letters,
    digits, underscores and apostrophes.
  \end{itemize}

  A binary operator name is an \emph{infix operator name} iff it is
  surrounded by backticks, or begins with a backslash, or:
  \begin{itemize}
  \item it is neither \ecn{<<} nor \ecn{>>}; and
  \item it doesn't contain a colon, unless it is a sequence of colons
    of length at least two; and
  \item it doesn't contain \ecn{=>}, except if it is \ecn{=>}; and
  \item it doesn't contain \ecn{|}, except if it is \ecn{||}; and
  \item it doesn't contain \ecn{/}, except if it is \ecn{/},
    \ecn{/\\}, or a sequence of slashes of length at least 3.
  \end{itemize}

  The precedence hierarchy for infix operators is (from lowest to highest):
  \begin{itemize}
  \item \ecn{=>} (right-associative);

  \item \ecn{<=>} (non-associative);

  \item \ecn{||} and \ecn{\\/} (right-associative);

  \item \ecn{&&} and \ecn{/\\} (right-associative);

  \item \ecn{=} and \ecn{<>} (non-associative);

  \item \ecn{<}, \ecn{>}, \ecn{<=} and \ecn{>=}
    (left-associative);

  \item \ecn{-} and \ecn{+} (left-associative);

  \item \ecn{*}, and any nonempty combination of \ecn{/} and
    \ecn{\%} (other than \ecn{//}, which is illegal)
    (left-associative);

  \item all other infix operators except sequences of colons
    (left-associative);

  \item sequences of colons of length at least two (right-associative).
  \end{itemize}

\item \textbf{Unary operator names}. A \emph{unary operator name} is a
  negation sign (\ec{!}), a nonempty sequence of plus signs (\ec{+}),
  a nonempty sequence of minus signs (\ec{-}), or a backward slash
  followed by a nonempty sequence of letters, digits, underscores and
  apostrophes.  A \emph{prefix operator name} is any unary operator
  name not consisting of either two more plus signs or two or more
  minus signs.

\item \textbf{Mixfix operator names}. A \emph{mixfix operator name} is
  of the following sequences of characters:
  \ec{\"`|_|\"}, \ec{\"[]\"}, \ec{\"_.[_]\"} or \ec{\"_.[_<-_]\"}.
  (We'll see below how they may be used in mixfix form.)

\item \textbf{Record projections}. A \emph{record projection} is an
  identifier.

\item \textbf{Constructor names}. A \emph{constructor name} is an identifier
  or a symbolic operator name.

\item \textbf{Type variables}. A \emph{type variable} consists of an
  apostrophe followed by a sequence of letters, digits, underscores
  and apostrophes that begins with a lowercase letter or underscore,
  and isn't equal to an underscore.

\item \textbf{Type or type operator names}. A \emph{type or type
  operator name} is an identifier.

\item \textbf{Variable names}. A \emph{variable} name is an identifier
  that doesn't begin with an uppercase letter.

\item \textbf{Procedure names}. A \emph{procedure} name is an identifier
  that doesn't begin with an uppercase letter.

\item \textbf{Module names}. A \emph{module name} is an identifier that
  begins with an uppercase letter.

\item \textbf{Module type names}. A \emph{module type name} is an
  identifier that begins with an uppercase letter.

\item \textbf{Memory identifiers}. A \emph{memory identifier} consists
of an ampersand followed by either a nonempty sequence of digits or
an identifer whose initial character isn't an upper case letter.

\end{itemize}

\section{Typed Expressions}

\subsection{Types}

\EasyCrypt's \emph{types} are formed from its built-in types and
type operator using function types, product (tuple) types, and
user-defined types and type constuctors, which include record types
and datatypes. \EasyCrypt's types are required to be inhabited---i.e.,
nonempty.

There are four built-in types:
\begin{itemize}
\item the type \ec{unit}, whose single element is \ec{tt} (which may
  also be written \ec{()});

\item the type \ec{bool} of booleans, \ec{true} and \ec{false};

\item the type \ec{int} of integers; and

\item the type \ec{real} of reals.
\end{itemize}

In addition, for every type $t$ there is a type \ec{$t\;$distr}, which
should be axiomatized so as to be a \emph{sub-distribution} of type
$t$, i.e., so that each element of $t$ is assigned a probability in
such a way that the sum of the probabilities of all of $t$'s element
is no more than $1$. When the sum is equal to $1$, we have a
\emph{distribution}. \ec{distr} is a \emph{type operator} taking a
single type argument:
\begin{easycrypt}{}{}
  type 'a distr
\end{easycrypt}
Here, \ec{'a} is a \emph{type variable}, marking the type parameter of
\ec{distr}; if we substitute an actual type for \ec{'a} in \ec{'a distr},
we get a type.

Given types $t_1$ and $t_2$, \ec{$t_1\;$->$\;t_2$} is a function type,
the type of total function transforming inputs of type $t_1$ to
outputs of type $t_2$. \ec{->} associates to the right, so that
\ec{int -> bool -> real} means \ec{int -> (bool -> real)}.

Given types $t_1$ and $t_2$, \ec{$t_1\;$*$\;t_2$} is a product (tuple)
type, whose elements are pairs $(x_1, x_2)$ where $x_1$ and $x_2$ are
elements of $t_1$ and $t_2$, respectively. Tuples may have more than
two components: e.g., \ec{int * int * real} is the type of triples
$(x_1, x_2, x_3)$ where $x_1$ and $x_2$ are integers and $x_3$ is a real.
Note that \ec{int * (int * real)}, \ec{(int * int) * real} and
\ec{int * int * real} are distinct types; the first two are pair types.
\ec{*} has higher precedence than \ec{->}, so that, e.g.,
\ec{int * int -> bool * real} means \ec{(int * int) -> (bool * real)}.

Record types may be declared like this:
\begin{easycrypt}{}{}
  type t = { x : int; y : bool; }.
  type u = { y : real; yy : int; yyy : real; }.
\end{easycrypt}
Here \ec{t} is the type of records with field projections \ec{x} of
type \ec{int}, and \ec{y} of type \ec{bool}. The order of projections is
irrelevant.  Different record types can't use overlapping projections,
and record projections must be disjoint from operators (see
below). Records any non-zero number of fields; \ec{u} is a record with
three fields. We may also define record type operators, as in:
\begin{easycrypt}{}{}
  type 'a t = { x : 'a; f : 'a -> 'a; }.
  type ('a, 'b) u = { f : 'a -> 'b; x : 'a; }.
\end{easycrypt}
Then, a value $v$ of type \ec{int t} would have fields \ec{x} and
\ec{f} of types \ec{int} and \ec{int -> int}, respectively; and
a value $v$ of type \ec{(int, bool) u} would have fields \ec{x} and
\ec{f} with types \ec{int} and \ec{int -> bool}, respectively.

Datatypes and datatype operators may be declared like this:
\begin{easycrypt}{}{}
  type enum = [ First | Second | Third ].
  type either_int_bool = [ First of int | Second of bool ].
  type ('a, 'b) either = [ First of 'a | Second of 'b ].
  type intlist = [
    | Nil
    | Cons of (int * intlist) ].
  type 'a list = [
    | Nil
    | Cons of 'a & 'a list ].
\end{easycrypt}
Here, \ec{First}, \ec{Second}, \ec{Third}, \ec{Nil} and \ec{Cons} are
constructors, and must be distinct from all operators, record
projections and other constructors.  \ec{enum} is an enumerated type
with the three elements \ec{First}, \ec{Second} and \ec{Third}. The
elements of \ec{either_int_bool} consist of \ec{First} applied to an
integer, or \ec{Second} applied to a boolean, and the datatype
operator \ec{either} is simply its generalization to arbitrary types
\ec{'a} and \ec{'b}.  \ec{intlist} is an inductive datatype: its
elements are \ec{Nil} and the results of applying \ec{Cons} to a pairs
of the form $(x, \mathit{ys})$, where $x$ is an integer and
$\mathit{ys}$ is a previously constructed \ec{intlist}.  Note that a
vertical bar (\ec{|}) is permitted before the first constructor of a
datatype. Finally, \ec{list} is the generalization of \ec{intlist} to
lists over an arbitrary type \ec{'a}, but with a twist. The use of
\ec{&} means that \ec{Cons} is ``curried'': instead of applying
\ec{Cons} to a pair $(x, \mathit{ys})$, one gives it \ec{$x$ : 'a} and
\ec{$\mathit{ys}$ : 'a list} one at a time, as in \ec{Cons$\,x\,$
  $\,\mathit{ys}$}.  Unsurprisingly, more than one occurrence of
\ec{&} is allowed in a constructor's definition. E.g., here is the
datatype for binary trees whose leaves and internal nodes are labeled
by integers:
\begin{easycrypt}{}{}
  type tree = [
    | Leaf of int
    | Cons of tree & int & tree
  ].
\end{easycrypt}
Here, \ec{Cons $\,\mathit{tr}_1\,$ $x\,$ $\mathit{tr}_2$} will be the tree
constructed from an integer $x$ and trees $\mathit{tr}_1$ and
$\mathit{tr}_2$.
\EasyCrypt\ must be able to convince itself that a datatype is
nonempty, most commonly because it has at least one constructor
taking no arguments.

Types and type operators that are simply abbreviations for pre-existing
types may be declared, as in:
\begin{easycrypt}{}{}
type t = int * bool.
type ('a, b) arr = 'a -> 'b.
\end{easycrypt}
Then, e.g., \ec{(int, bool) arr} is the same type as \ec{int -> bool}.

Finally, abstract types and type operators may be declared, as in:
\begin{easycrypt}{}{}
type t.
type ('a, b) u.
\end{easycrypt}
We'll see later how such types and type operators may be used.

\subsection{Expressions}

We'll now survey \EasyCrypt's typed expressions. Anonymous functions
are written \ec{fun ($x$ : $\,t_1$) => $\;e$}, where $x$ is an identifier,
$t_1$ is a type, and $e$ is an expression---probably involving $x$.
If $e$ has type $t_2$ under the assumption that $x$ has type $t_1$,
then the anonymous function will have type \ec{$t_1$ -> $\;\,t_2$}.
Function application is written using juxtapositioning, so that if
$e_1$ has type \ec{$t_1$ -> $\;\,t_2$}, and $e_2$ has type $t_1$, then
$e_1\,e_2$ has type $t_2$. Function application associates to the
left, and anonymous functions extend as far to the right as possible.
\EasyCrypt\ infers the types of the bound variables of anonymous function
when it can. Nested anonymous functions may be abbreviated by
collecting all their bound variables together. E.g., consider the
expression
\begin{easycrypt}{}{}
(fun (x : int) => fun (y : int) => fun (z : bool) => y) 0 1 false
\end{easycrypt}
which evalutes to \ec{1}. It may be appreviated to
\begin{easycrypt}{}{}
(fun (x y : int, z : bool) => y) 0 1 false
\end{easycrypt}
or
\begin{easycrypt}{}{}
(fun (x : int) (y : int) (z : bool) => y) 0 1 false
\end{easycrypt}
or (letting \EasyCrypt\ carry out type inference)
\begin{easycrypt}{}{}
(fun x y z => y) 0 1 false
\end{easycrypt}
In the type inference, only the type of \ec{y} is determined, but
that's acceptable.

An operator may be declared by specifying its type and giving the
expression to be evaluated. E.g.,
\begin{easycrypt}{}{}
op x : int = 3.
op f : int -> bool -> int = fun (x : int) (y : bool) => x.
op g : bool -> int = f 1.
op y : int = g true.
op z = f 1 true.
\end{easycrypt}
Here \ec{f} is a curried function---it takes its arguments one
at a time. Hence \ec{y} and \ec{z} have the same value: \ec{1}.
As illustrated by the declaration of \ec{z}, one may admit the
operator's type when it can be inferred from its expression.
The declaration of \ec{f} may be abbreviated to
\begin{easycrypt}{}{}
op f (x : int) (y : bool) = x.
\end{easycrypt}
or
\begin{easycrypt}{}{}
op f (x : int, y : bool) = x.
\end{easycrypt}

\emph{Polymorphic} operators may be declared, as in
\begin{easycrypt}{}{}
op g ['a, 'b] : 'a -> 'b -> 'a = fun (x : 'a, y : 'b) => x.
\end{easycrypt}
or
\begin{easycrypt}{}{}
op g ['a, 'b] (x : 'a, y : 'b) = x.
\end{easycrypt}
Here \ec{g} has all the types formed
by substituting types for the types variable \ec{'a} and \ec{'b}
in \ec{'a -> 'b -> 'a}. This allows us to use \ec{g} at different
types
\begin{easycrypt}{}{}
op a = g true 0.
op b = g 0 false.
\end{easycrypt}
making \ec{a} and \ec{b} evaluate to \ec{true} and \ec{0}, respectively.

\emph{Abstract} operators may be declared, i.e., ones whose values
are unspecified. E.g., we can declare
\begin{easycrypt}{}{}
op x : int.
op f : int -> int.
op g ['a, 'b] : 'a -> 'b -> 'a.
\end{easycrypt}
Equivalently, \ec{f} and \ec{g} may be declared like this:
\begin{easycrypt}{}{}
op f (x : int) : int.
op g ['a, 'b] (x : 'a, y : 'b) : 'a.
\end{easycrypt}
We'll see later how abstract operators may be used.

Binary operators may be declared and used with infix notation
(as long as they are infix operators). E.g., if we declare
\begin{easycrypt}{}{}
op (--) ['a, 'b] (x : 'a) (y : 'b) = x.
op x : int = 0 -- true.
op y : bool = true -- 0.
\end{easycrypt}
then \ec{x} and \ec{y} evaluate to \ec{0} and \ec{true}, respectively.
Unary operators may be declared and used with prefix notation
(as long as they are prefix operators). E.g., if we declare
\begin{easycrypt}{}{}
op [!] : int -> int.
op x : int.
op y = !x.
\end{easycrypt}
then \ec{y} evaluated to the result of applying the abstract operator
\ec{!} of type \ec{int -> int} to the abstract value \ec{x} of type
\ec{int}.  Function application has higher precedence than prefix
operators, which have higher precedence than infix operators, prefix
operators group to the right, and infix operators have the
associativities and relative precedences that were detailed in
Section~\ref{Lexical}.

An binary operator may be used as a standalone expression by
enclosing it in parentheses, and a unary operator may be so used
by enclosing it in square brackets:
\begin{easycrypt}{}{}
op (--) ['a, 'b] (x : 'a) (y : 'b) = x.
op x : int = (--) 0 true.
op [!] : int -> int.
op double ['a] (f : 'a -> 'a) = fun x => f(f x).
op u : int -> int = double [!].
\end{easycrypt}

Some operators are built-in to \EasyCrypt, automatically understood
by its ambient logic:
\begin{easycrypt}{}{}
op (=) ['a]: 'a -> 'a -> bool.

op [!] : bool -> bool.
op (||) : bool -> bool -> bool.
op (\\/) : bool -> bool -> bool.
op (&&) : bool -> bool -> bool.
op (/\\) : bool -> bool -> bool.
op (=>) : bool -> bool -> bool.
op (<=>) : bool -> bool -> bool.

op mu : 'a distr -> ('a -> bool) -> real.
\end{easycrypt}
The operator \ec{=} is equality. On the booleans, we have negation
\ec{!}, two forms of disjunction (\ec{\\/} and \ec{||}) and conjuction
(\ec{/\\} and \ec{&&}), implication (\ec{=>}) and if-and-only-if
(\ec{<=>}).  The two disjuctions (respectively, conjunctions) are
semantically equivalent, but are treated differently by \EasyCrypt
proof engine. The associativities and precedences of the infix
operators were given in Section~\ref{Lexical}, and (as a prefix
operator) \ec{!} has higher precedence than all of them. The
expression \ec{$e_1$ <> $\;e_2$} is treated as \ec{!($e_1$ =
  $\;e_2$)}; \ec{<>} is not an operator.
The intended meaning of \ec{mu $\,d$ $\,p$} is the probability that
randomly choosing a value of the given type from the sub-distribution
$d$ will satisfy the function $p$ (in the sense of causing it to return
\ec{true}).
In addition, if $e$ is an expression of type \ec{int}, then
\ec{$e$\%r} is the corresponding real.

For the built-in types \ec{bool}, \ec{int} and \ec{real}, and the type
operator \ec{distr}, the \EasyCrypt\ Library (see
Chapter~\ref{Library}) provides corresponding theories, \ec{Bool},
\ec{Int}, \ec{Real} and \ec{Distr}. These theories provide various
operations, axioms, etc.  To make use of a theory, one must
``require'' it.  E.g.,
\begin{easycrypt}{}{}
require Bool Int Real Distr.
\end{easycrypt}
will make the theories just mentioned available. This
would allow us to write, e.g.,
\begin{easycrypt}{}{}
op x = Int.(+) 3 4.
\end{easycrypt}
making \ec{x} evaluate to \ec{7}. But to be able to use \ec{+}
and the other operators provided by \ec{Int}
in infix form without qualification (specifying which theory to
find it in), we need to import \ec{Int}. If we do
\begin{easycrypt}{}{}
import Bool Int Real.
op x : int = 3 + 4 - 7 * 2.
op y : real = 5%r * 3%r / 2%r.
op z : bool = x%r >= y.
\end{easycrypt}
we'll end up with \ec{z} evaluating to \ec{false}.
One may combine requiring and importing in one step:
\begin{easycrypt}{}{}
require import Bool Int Real Instr.
\end{easycrypt}
We'll cover theories and their usage in detail in
Chapter~\ref{Structuring}.

\section{Modules}

\section{Logics}
