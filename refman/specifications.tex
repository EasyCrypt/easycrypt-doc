\chapter{Specifications}
\label{Specifications}

In this chapter, we present \EasyCrypt's language for writing
cryptographic specifications.  We start by presenting its typed
expression language, go on to consider its module language for
expressing cryptographic games, and conclude by presenting its four
logics.

\EasyCrypt\ has a typed expression language based on the polymorphic
typed lambda calculus. Expressions are guaranteed to terminate,
although their values may be under-specified.  Its type system has:
\begin{itemize}
\item several pre-defined base types;

\item product (tuple) types;

\item user-defined abbreviations for types and parameterized types; and

\item user-defined concrete datatypes (like lists and trees).
\end{itemize}
In its expression language:
\begin{itemize}
\item operators for the pre-defined base types may be imported from
  the standard library;

\item user-defined operations may be defined, including by
  structural recursion on concrete datatypes.
\end{itemize}
For each type, there is a type of probability distributions over that
type.

\EasyCrypt's modules consist of typed global variables and procedures.
The body of a procedure consists of local variable declartions followed
by a sequence of statements:
\begin{itemize}
\item ordinary assignments;

\item random assignments, assigning values chosen
  from distributions to variables;

\item procedure calls, whose results are assigned to variables;

\item conditional (if-then-else) statements;

\item while loops; and

\item return statements (which may only appear at the end of
  procedures).
\end{itemize}
A procedure's modules may refer to the global variables of previously
declared modules. Modules may be parameterized by abstract modules,
which may be used to model adversaries; and modules types---or
interfaces---may be formalized, describing modules with at least
certain specified procedures with certain types.

\EasyCrypt\ has four logics: a probabilistic, relational Hoare logic
(\prhl), relating pairs of procedures; a probabilistic Hoare logic
(\phl) allowing one to carry out proofs about the probability of a
procedure's execution resulting in a postcondition holding; an
ordinary (possibilistic) Hoare logic (\hl); and an ambient higher
order logic for proving general mathematical facts, as well as for
connecting judgments from the other logics

Proofs are carried out using tactics, which is the focus of
Chapter~\ref{Tactics}.  \EasyCrypt\ also has ways (theories and
sections) of structuring specifications and proofs, which will be
described in Chapter~\ref{Structuring}. In Chapter~\ref{Library},
we'll survey the \EasyCrypt\ Library, which consists of numerous
theories, definining mathematical structures (like groups, rings
and fields), data structures (like finite sets and maps), and
cryptographic constructions (like random oracles and different
forms of encryption).

\section{Lexical Categories}

\EasyCrypt's language has a number of lexical categories:
\begin{itemize}
\item \textbf{Keywords}. \EasyCrypt\ has the following
  \emph{keywords}: \ecnocolors{admit}, \ecnocolors{algebra},
  \ecnocolors{alias}, \ecnocolors{apply}, \ecnocolors{as},
  \ecnocolors{assert}, \ecnocolors{assumption}, \ecnocolors{auto},
  \ecnocolors{axiom}, \ecnocolors{axiomatized}, \ecnocolors{beta},
  \ecnocolors{by}, \ecnocolors{byequiv}, \ecnocolors{byphoare},
  \ecnocolors{bypr}, \ecnocolors{call}, \ecnocolors{case},
  \ecnocolors{cfold}, \ecnocolors{change}, \ecnocolors{class},
  \ecnocolors{clear}, \ecnocolors{clone}, \ecnocolors{congr},
  \ecnocolors{conseq}, \ecnocolors{const}, \ecnocolors{cut},
  \ecnocolors{declare}, \ecnocolors{delta}, \ecnocolors{do},
  \ecnocolors{done}, \ecnocolors{eager}, \ecnocolors{elif},
  \ecnocolors{elim}, \ecnocolors{else}, \ecnocolors{end},
  \ecnocolors{equiv}, \ecnocolors{exact}, \ecnocolors{exfalso},
  \ecnocolors{exists}, \ecnocolors{expect}, \ecnocolors{export},
  \ecnocolors{fel}, \ecnocolors{fieldeq}, \ecnocolors{first},
  \ecnocolors{fission}, \ecnocolors{forall}, \ecnocolors{fun},
  \ecnocolors{fusion}, \ecnocolors{generalize}, \ecnocolors{glob},
  \ecnocolors{goal}, \ecnocolors{have}, \ecnocolors{hint},
  \ecnocolors{hoare}, \ecnocolors{hypothesis}, \ecnocolors{idtac},
  \ecnocolors{if}, \ecnocolors{import}, \ecnocolors{in},
  \ecnocolors{inline}, \ecnocolors{instance}, \ecnocolors{intros},
  \ecnocolors{iota}, \ecnocolors{islossless}, \ecnocolors{kill},
  \ecnocolors{last}, \ecnocolors{left}, \ecnocolors{lemma},
  \ecnocolors{let}, \ecnocolors{local}, \ecnocolors{logic},
  \ecnocolors{modpath}, \ecnocolors{module}, \ecnocolors{move},
  \ecnocolors{nolocals}, \ecnocolors{nosmt}, \ecnocolors{of},
  \ecnocolors{op}, \ecnocolors{phoare}, \ecnocolors{pose},
  \ecnocolors{Pr}, \ecnocolors{pr_bounded}, \ecnocolors{pred},
  \ecnocolors{print}, \ecnocolors{proc}, \ecnocolors{progress},
  \ecnocolors{proof}, \ecnocolors{prover}, \ecnocolors{qed},
  \ecnocolors{rcondf}, \ecnocolors{rcondt}, \ecnocolors{realize},
  \ecnocolors{reflexivity}, \ecnocolors{require}, \ecnocolors{res},
  \ecnocolors{return}, \ecnocolors{rewrite}, \ecnocolors{right},
  \ecnocolors{ringeq}, \ecnocolors{rnd}, \ecnocolors{rwnormal},
  \ecnocolors{search}, \ecnocolors{section}, \ecnocolors{seq},
  \ecnocolors{sim}, \ecnocolors{simplify}, \ecnocolors{skip},
  \ecnocolors{smt}, \ecnocolors{sp}, \ecnocolors{split},
  \ecnocolors{splitwhile}, \ecnocolors{strict}, \ecnocolors{subst},
  \ecnocolors{swap}, \ecnocolors{symmetry}, \ecnocolors{then},
  \ecnocolors{theory}, \ecnocolors{timeout}, \ecnocolors{Top},
  \ecnocolors{transitivity}, \ecnocolors{trivial}, \ecnocolors{try},
  \ecnocolors{type}, \ecnocolors{unroll}, \ecnocolors{var},
  \ecnocolors{while}, \ecnocolors{why3}, \ecnocolors{with},
  \ecnocolors{wp} and \ecnocolors{zeta}.

\item \textbf{Identifiers}. An \emph{identifier} is a sequence of
  letters, digits, underscores (\ecnocolors{_}) and apostrophes
  (\ecnocolors{'}) that begins with a letter or underscore, and isn't
  equal to an underscore or a keyword other than \ecnocolors{expect},
  \ecnocolors{first}, \ecnocolors{last}, \ecnocolors{left},
  \ecnocolors{right} or \ecnocolors{strict}.

\item \textbf{Operator names}. An \emph{operator name} is an
  identifier, a binary operator name, a unary operator name.

\item \textbf{Binary operator names}. A \emph{binary operator name}
  is:
  \begin{itemize}
  \item a nonempty sequence of equal signs (\ec{=}), less
  than signs (\ec{<}), greater than signs (\ec{>}), forward slashes
  (\ec{/}), backward slashes (\ec{\\}), plus signs (\ec{+}), minus
  signs (\ec{-}), times signs (\ec{*}), vertical bars (\ec{|}), colons
  (\ec{:}), ampersands (\ec{&}), up arrows (\ec{^}) and percent signs
  (\ec{\%}); or

  \item a backtick mark (\ec{`}), followed by a nonempty sequence of one
    of these characters, followed by a backtick mark; or

  \item a backward slash followed by a nonempty sequence of letters,
    digits, underscores and apostrophes.
  \end{itemize}

  A binary operator name is an \emph{infix operator name} iff it is
  surrounded by backticks, or begins with a backslash, or:
  \begin{itemize}
  \item it is neither \ecnocolors{<<} nor \ecnocolors{>>}; and
  \item it doesn't contain a colon, unless it is a sequence of colons
    of length at least two; and
  \item it doesn't contain \ecnocolors{=>}, except if it is \ecnocolors{=>}; and
  \item it doesn't contain \ecnocolors{|}, except if it is \ecnocolors{||}; and
  \item it doesn't contain \ecnocolors{/}, except if it is \ecnocolors{/},
    \ecnocolors{/\\}, or a sequence of slashes of length at least 3.
  \end{itemize}

  The precedence hierarchy for infix operators is (from lowest to highest):
  \begin{itemize}
  \item \ecnocolors{=>} (right-associative);

  \item \ecnocolors{<=>} (non-associative);

  \item \ecnocolors{||} and \ecnocolors{\\/} (right-associative);

  \item \ecnocolors{&&} and \ecnocolors{/\\} (right-associative);

  \item \ecnocolors{=} and \ecnocolors{<>} (non-associative);

  \item \ecnocolors{<}, \ecnocolors{>}, \ecnocolors{<=} and \ecnocolors{>=}
    (left-associative);

  \item \ecnocolors{-} and \ecnocolors{+} (left-associative);

  \item \ecnocolors{*}, and any nonempty combination of \ecnocolors{/} and
    \ecnocolors{\%} (other than \ecnocolors{//}, which is illegal)
    (left-associative);

  \item all other infix operators except sequences of colons
    (left-associative);

  \item sequences of colons of length at least two (right-associative).
  \end{itemize}

\item \textbf{Unary operator names}. A \emph{unary operator name} is a
  negation sign (\ec{!}), a nonempty sequence of plus signs (\ec{+}),
  a nonempty sequence of minus signs (\ec{-}), or a backward slash
  followed by a nonempty sequence of letters, digits, underscores and
  apostrophes.  A \emph{prefix operator name} is any unary operator
  name except a sequence of two or more plus signs, or a sequence of
  two or more minus signs.

\item \textbf{Record projections}. A \emph{record projection} is an
  identifier.

\item \textbf{Constructor names}. A \emph{constructor name} is an identifier
  or a symbolic operator name.

\item \textbf{Type variables}. A \emph{type variable} consists of an
  apostrophe followed by a sequence of letters, digits, underscores
  and apostrophes that begins with a lowercase letter or underscore,
  and isn't equal to an underscore.

\item \textbf{Type or type operator names}. A \emph{type or type
  operator name} is an identifier.

\item \textbf{Variable names}. A \emph{variable} name is an identifier
  that doesn't begin with an uppercase letter.

\item \textbf{Procedure names}. A \emph{procedure} name is an identifier
  that doesn't begin with an uppercase letter.

\item \textbf{Module names}. A \emph{module name} is an identifier that
  begins with an uppercase letter.

\item \textbf{Module type names}. A \emph{module type name} is an
  identifier that begins with an uppercase letter.

\item \textbf{Memory identifiers}. A \emph{memory identifier} consists
of an ampersand followed by either a nonempty sequence of digits or
an identifer whose initial character isn't an upper case letter.

\end{itemize}

\section{Typed Expressions}

\EasyCrypt's \emph{types} are formed from its built-in types and
type operator using function types, product (tuple) types, and
user-defined types and type constuctors, which include record types
and datatypes. \EasyCrypt's types are required to be inhabited---i.e.,
nonempty.

There are four built-in types:
\begin{itemize}
\item the type \ec{unit}, whose single element is \ec{tt} (which may
  also be written \ec{()});

\item the type \ec{bool} of booleans, \ec{true} and \ec{false};

\item the type \ec{int} of integers; and

\item the type \ec{real} of reals.
\end{itemize}

In addition, for every type $t$ there is a type \ec{$t\;$distr}, which
should be axiomatized so as to be a \emph{sub-distribution} of type
$t$, i.e., so that each element of $t$ is assigned a probability in
such a way that the sum of the probabilities of all of $t$'s element
is no more than $1$. When the sum is equal to $1$, we have a
\emph{distribution}. \ec{distr} is a \emph{type operator} taking a
single type argument:
\begin{easycrypt}{}{}
  type 'a distr
\end{easycrypt}
Here, \ec{'a} is a \emph{type variable}, marking the type parameter of
\ec{distr}; if we substitute an actual type for \ec{'a} in \ec{'a distr},
we get a type.

Given types $t_1$ and $t_2$, \ec{$t_1\;$->$\;t_2$} is a function type,
the type of total function transforming inputs of type $t_1$ to
outputs of type $t_2$. \ec{->} associates to the right, so that
\ec{int -> bool -> real} means \ec{int -> (bool -> real)}.

Given types $t_1$ and $t_2$, \ec{$t_1\;$*$\;t_2$} is a product (tuple)
type, whose elements are pairs $(x_1, x_2)$ where $x_1$ and $x_2$ are
elements of $t_1$ and $t_2$, respectively. Tuples may have more than
two components: e.g., \ec{int * int * real} is the type of triples
$(x_1, x_2, x_3)$ where $x_1$ and $x_2$ are integers and $x_3$ is a real.
Note that \ec{int * (int * real)}, \ec{(int * int) * real} and
\ec{int * int * real} are distinct types; the first two are pair types.
\ec{*} has higher precedence than \ec{->}, so that, e.g.,
\ec{int * int -> bool * real} means \ec{(int * int) -> (bool * real)}.

Record types may be declared like this:
\begin{easycrypt}{}{}
  type t = { x : int; y : bool; }.
  type u = { y : real; yy : int; yyy : real; }.
\end{easycrypt}
Here \ec{t} is the type of records with field projections \ec{x} of
type \ec{int}, and \ec{y} of type \ec{bool}. The order of projections is
irrelevant.  Different record types can't use overlapping projections,
and record projections must be disjoint from operators (see
below). Records any non-zero number of fields; \ec{u} is a record with
three fields. We may also define record type operators, as in:
\begin{easycrypt}{}{}
  type 'a t = { x : 'a; f : 'a -> 'a; }.
  type ('a, 'b) u = { f : 'a -> 'b; x : 'a; }.
\end{easycrypt}
Then, a value $v$ of type \ec{int t} would have fields \ec{x} and
\ec{f} of types \ec{int} and \ec{int -> int}, respectively; and
a value $v$ of type \ec{(int, bool) u} would have fields \ec{x} and
\ec{f} with types \ec{int} and \ec{int -> bool}, respectively.

Datatypes and datatype operators may be declared like this:
\begin{easycrypt}{}{}
  type enum = [ First | Second | Third ].
  type either_int_bool = [ First of int | Second of bool ].
  type ('a, 'b) either = [ First of 'a | Second of 'b ].
  type intlist = [
    | Nil
    | Cons of (int * intlist) ].
  type 'a list = [
    | Nil
    | Cons of 'a & 'a list ].
\end{easycrypt}
Here, \ec{First}, \ec{Second}, \ec{Third}, \ec{Nil} and \ec{Cons} are
constructors, and must be distinct from all operators, record projections
and other constructors.  \ec{enum} is an enumerated type with the
three elements \ec{First}, \ec{Second} and \ec{Third}. The elements of
\ec{either_int_bool} consist of \ec{First} applied to an integer, or
\ec{Second} applied to a boolean, and the datatype operator
\ec{either} is simply its generalization to arbitrary types \ec{'a}
and \ec{'b}. \ec{intlist} is an inductive datatype: its elements are
\ec{Nil} and the results of applying \ec{Cons} to a pairs of the form
$(x, \mathit{ys})$, where $x$ is an integer and $\mathit{ys}$ is a
previously constructed \ec{intlist}.  Note that a vertical bar
(\ec{|}) is permitted before the first constructor of a
datatype. Finally, \ec{list} is the generalization of \ec{intlist} to
lists over an arbitrary type \ec{'a}, but with a twist. The use of
\ec{&} means that \ec{Cons} is ``curried'': instead of applying
\ec{Cons} to a pair $(x, \mathit{ys})$, one gives it \ec{$x$ : 'a} and
\ec{$\mathit{ys}$ : 'a list} one at a time, as in \ec{Cons$\,x\,$
 $\,\mathit{ys}$}.  Unsurprisingly, more than one occurrence of \ec{&}
is allowed in a constructor's definition. E.g., here is the datatype
for binary trees whose leaves and internal nodes are labeled by
integers:
\begin{easycrypt}{}{}
  type tree = [
    | Leaf of int
    | Cons of tree & int & tree
  ].
\end{easycrypt}
Here, \ec{Cons $\,\mathit{tr}_1\,$ $x\,$ $\mathit{tr}_2$} will be the tree
constructed from an integer $x$ and trees $\mathit{tr}_1$ and
$\mathit{tr}_2$.

Types and type operators that are simply abbreviations for pre-existing
types may be declared, as in:
\begin{easycrypt}{}{}
type t = int * bool.
type ('a, b) arr = 'a -> 'b.
\end{easycrypt}
Then, e.g., \ec{(int, bool) arr} is the same type as \ec{int -> bool}.

Finally, abstract types and type operators may be declared, as in:
\begin{easycrypt}{}{}
type t.
type ('a, b) u.
\end{easycrypt}
We'll see later how such types and type operators may be used.

We'll now survey \EasyCrypt's typed expressions.

\section{Modules}

\section{Logics}
