\chapter{Specifications}
\label{Specifications}

In this chapter, we present \EasyCrypt's language for writing
cryptographic specifications.  We start by presenting its typed
expression language, go on to consider its module language for
expressing cryptographic games, and conclude by presenting its four
logics.

\EasyCrypt\ has a typed expression language based on the polymorphic
typed lambda calculus. Expressions are guaranteed to terminate,
although their values may be under-specified.  Its type system has:
\begin{itemize}
\item several pre-defined base types;

\item product (tuple) types;

\item user-defined abbreviations for types and parameterized types; and

\item user-defined concrete datatypes (like lists and trees).
\end{itemize}
In its expression language:
\begin{itemize}
\item operators for the pre-defined base types may be imported from
  the standard library;

\item user-defined operations may be defined, including by
  structural recursion on concrete datatypes.
\end{itemize}
For each type, there is a type of probability distributions over that
type.

\EasyCrypt's modules consist of typed global variables and procedures.
The body of a procedure consists of local variable declartions followed
by a sequence of statements:
\begin{itemize}
\item ordinary assignments;

\item random assignments, assigning values chosen
  from distributions to variables;

\item procedure calls, whose results are assigned to variables;

\item conditional (if-then-else) statements;

\item while loops; and

\item return statements (which may only appear at the end of
  procedures).
\end{itemize}
A procedure's modules may refer to the global variables of previously
declared modules. Modules may be parameterized by abstract modules,
which may be used to model adversaries; and modules types---or
interfaces---may be formalized, describing modules with at least
certain specified procedures with certain types.

\EasyCrypt\ has four logics: a probabilistic, relational Hoare logic
(\prhl), relating pairs of procedures; a probabilistic Hoare logic
(\phl) allowing one to carry out proofs about the probability of a
procedure's execution resulting in a postcondition holding; an
ordinary (possibilistic) Hoare logic (\hl); and an ambient higher
order logic for proving general mathematical facts, as well as for
connecting judgments from the other logics

Proofs are carried out using tactics, which is the focus of
Chapter~\ref{Tactics}.  \EasyCrypt\ also has ways (theories and
sections) of structuring specifications and proofs, which will be
described in Chapter~\ref{Structuring}. In Chapter~\ref{Library},
we'll survey the \EasyCrypt\ Library, which consists of numerous
theories, definining mathematical structures (like groups, rings
and fields), data structures (like finite sets and maps), and
cryptographic constructions (like random oracles and different
forms of encryption).

\section{Lexical Categories}
\label{Lexical}

\EasyCrypt's language has a number of lexical categories:
\begin{itemize}
\item \textbf{Keywords}. \EasyCrypt\ has the following
  \emph{keywords}: \ecn{admit}, \ecn{algebra},
  \ecn{alias}, \ecn{apply}, \ecn{as},
  \ecn{assert}, \ecn{assumption}, \ecn{auto},
  \ecn{axiom}, \ecn{axiomatized}, \ecn{beta},
  \ecn{by}, \ecn{byequiv}, \ecn{byphoare},
  \ecn{bypr}, \ecn{call}, \ecn{case},
  \ecn{cfold}, \ecn{change}, \ecn{class},
  \ecn{clear}, \ecn{clone}, \ecn{congr},
  \ecn{conseq}, \ecn{const}, \ecn{cut},
  \ecn{declare}, \ecn{delta}, \ecn{do},
  \ecn{done}, \ecn{eager}, \ecn{elif},
  \ecn{elim}, \ecn{else}, \ecn{end},
  \ecn{equiv}, \ecn{exact}, \ecn{exfalso},
  \ecn{exists}, \ecn{expect}, \ecn{export},
  \ecn{fel}, \ecn{fieldeq}, \ecn{first},
  \ecn{fission}, \ecn{forall}, \ecn{fun},
  \ecn{fusion}, \ecn{generalize}, \ecn{glob},
  \ecn{goal}, \ecn{have}, \ecn{hint},
  \ecn{hoare}, \ecn{hypothesis}, \ecn{idtac},
  \ecn{if}, \ecn{import}, \ecn{in},
  \ecn{inline}, \ecn{instance}, \ecn{intros},
  \ecn{iota}, \ecn{islossless}, \ecn{kill},
  \ecn{last}, \ecn{left}, \ecn{lemma},
  \ecn{let}, \ecn{local}, \ecn{logic},
  \ecn{modpath}, \ecn{module}, \ecn{move},
  \ecn{nolocals}, \ecn{nosmt}, \ecn{of},
  \ecn{op}, \ecn{phoare}, \ecn{pose},
  \ecn{Pr}, \ecn{pr_bounded}, \ecn{pred},
  \ecn{print}, \ecn{proc}, \ecn{progress},
  \ecn{proof}, \ecn{prover}, \ecn{qed},
  \ecn{rcondf}, \ecn{rcondt}, \ecn{realize},
  \ecn{reflexivity}, \ecn{require}, \ecn{res},
  \ecn{return}, \ecn{rewrite}, \ecn{right},
  \ecn{ringeq}, \ecn{rnd}, \ecn{rwnormal},
  \ecn{search}, \ecn{section}, \ecn{seq},
  \ecn{sim}, \ecn{simplify}, \ecn{skip},
  \ecn{smt}, \ecn{sp}, \ecn{split},
  \ecn{splitwhile}, \ecn{strict}, \ecn{subst},
  \ecn{swap}, \ecn{symmetry}, \ecn{then},
  \ecn{theory}, \ecn{timeout}, \ecn{Top},
  \ecn{transitivity}, \ecn{trivial}, \ecn{try},
  \ecn{type}, \ecn{unroll}, \ecn{var},
  \ecn{while}, \ecn{why3}, \ecn{with},
  \ecn{wp} and \ecn{zeta}.

\item \textbf{Identifiers}. An \emph{identifier} is a sequence of
  letters, digits, underscores (\ecn{_}) and apostrophes
  (\ecn{'}) that begins with a letter or underscore, and isn't
  equal to an underscore or a keyword other than \ecn{expect},
  \ecn{first}, \ecn{last}, \ecn{left},
  \ecn{right} or \ecn{strict}.

\item \textbf{Operator names}. An \emph{operator name} is an
  identifier, a binary operator name, a unary operator name, or
  a mix fix operator name.

\item \textbf{Binary operator names}. A \emph{binary operator name}
  is:
  \begin{itemize}
  \item a nonempty sequence of equal signs (\ec{=}), less
  than signs (\ec{<}), greater than signs (\ec{>}), forward slashes
  (\ec{/}), backward slashes (\ec{\\}), plus signs (\ec{+}), minus
  signs (\ec{-}), times signs (\ec{*}), vertical bars (\ec{|}), colons
  (\ec{:}), ampersands (\ec{&}), up arrows (\ec{^}) and percent signs
  (\ec{\%}); or

  \item a backtick mark (\ec{`}), followed by a nonempty sequence of one
    of these characters, followed by a backtick mark; or

  \item a backward slash followed by a nonempty sequence of letters,
    digits, underscores and apostrophes.
  \end{itemize}

  A binary operator name is an \emph{infix operator name} iff it is
  surrounded by backticks, or begins with a backslash, or:
  \begin{itemize}
  \item it is neither \ecn{<<} nor \ecn{>>}; and
  \item it doesn't contain a colon, unless it is a sequence of colons
    of length at least two; and
  \item it doesn't contain \ecn{=>}, except if it is \ecn{=>}; and
  \item it doesn't contain \ecn{|}, except if it is \ecn{||}; and
  \item it doesn't contain \ecn{/}, except if it is \ecn{/},
    \ecn{/\\}, or a sequence of slashes of length at least 3.
  \end{itemize}

  The precedence hierarchy for infix operators is (from lowest to highest):
  \begin{itemize}
  \item \ecn{=>} (right-associative);

  \item \ecn{<=>} (non-associative);

  \item \ecn{||} and \ecn{\\/} (right-associative);

  \item \ecn{&&} and \ecn{/\\} (right-associative);

  \item \ecn{=} and \ecn{<>} (non-associative);

  \item \ecn{<}, \ecn{>}, \ecn{<=} and \ecn{>=}
    (left-associative);

  \item \ecn{-} and \ecn{+} (left-associative);

  \item \ecn{*}, and any nonempty combination of \ecn{/} and
    \ecn{\%} (other than \ecn{//}, which is illegal)
    (left-associative);

  \item all other infix operators except sequences of colons
    (left-associative);

  \item sequences of colons of length at least two (right-associative).
  \end{itemize}

\item \textbf{Unary operator names}. A \emph{unary operator name} is a
  negation sign (\ec{!}), a nonempty sequence of plus signs (\ec{+}),
  a nonempty sequence of minus signs (\ec{-}), or a backward slash
  followed by a nonempty sequence of letters, digits, underscores and
  apostrophes.  A \emph{prefix operator name} is any unary operator
  name not consisting of either two more plus signs or two or more
  minus signs.

\item \textbf{Mixfix operator names}. A \emph{mixfix operator name} is
  of the following sequences of characters: \ec{`|_|}, \ec{[]},
  \ec{_.[_]} or \ec{_.[_<-_]}.  (We'll see below how they may be used
  in mixfix form.)

\item \textbf{Record projections}. A \emph{record projection} is an
  identifier.

\item \textbf{Constructor names}. A \emph{constructor name} is an identifier
  or a symbolic operator name.

\item \textbf{Type variables}. A \emph{type variable} consists of an
  apostrophe followed by a sequence of letters, digits, underscores
  and apostrophes that begins with a lowercase letter or underscore,
  and isn't equal to an underscore.

\item \textbf{Type or type operator names}. A \emph{type or type
  operator name} is an identifier.

\item \textbf{Variable names}. A \emph{variable} name is an identifier
  that doesn't begin with an uppercase letter.

\item \textbf{Procedure names}. A \emph{procedure} name is an identifier
  that doesn't begin with an uppercase letter.

\item \textbf{Module names}. A \emph{module name} is an identifier that
  begins with an uppercase letter.

\item \textbf{Module type names}. A \emph{module type name} is an
  identifier that begins with an uppercase letter.

\item \textbf{Memory identifiers}. A \emph{memory identifier} consists
of an ampersand followed by either a nonempty sequence of digits or
an identifer whose initial character isn't an upper case letter.
\end{itemize}

\section{Script Structure and Printing}

An \EasyCrypt\ script consists of a sequence of \emph{steps},
terminated by dots (\ec{.}). Steps may:
\begin{itemize}
\item declare types and type operators;

\item declare operators and predicates;

\item declare modules or module types;

\item state axioms or lemmas;

\item apply tactics;

\item require (make available) theories;

\item print types, operators, predicates, axioms and lemmas.
\end{itemize}

To print an entity, one may say:
\begin{easycrypt}{}{}
print type t.
print op f.
print pred p.
print module Foo.
print module type FOO.
print axiom foo.
print lemma goo.
\end{easycrypt}
The entity kind may be omitted, in which case all entities with the
given name are printed. \ec{print op} and \ec{print pred} may be used
interchangeably, and may be applied to record field projections and
datatype constructors, as well as to operators and predicates---all of which
share the same name space.
\ec{print axiom} and \ec{print lemma} are also interchangeable---axioms
and lemmas share the same name space.

Declared/stated entities may refer to previously declared/stated entities,
but not to themselves or later ones (with the exception of recursively
declared operators on datatypes).

\section{Typed Expressions}

\subsection{Types}

\EasyCrypt's \emph{types} are formed from its built-in types and
type operator using function types, product (tuple) types, and
user-defined types and type constuctors, which include record types
and datatypes. \EasyCrypt's types are required to be inhabited---i.e.,
nonempty.

There are four built-in types:
\begin{itemize}
\item the type \ec{unit}, whose single element is \ec{tt} (which may
  also be written \ec{()});

\item the type \ec{bool} of booleans, \ec{true} and \ec{false};

\item the type \ec{int} of integers; and

\item the type \ec{real} of reals.
\end{itemize}

In addition, for every type $t$ there is a type \ec{$t\;$distr}, which
should be axiomatized so as to be a \emph{sub-distribution} of type
$t$, i.e., so that each element of $t$ is assigned a probability in
such a way that the sum of the probabilities of all of $t$'s element
is no more than $1$. When the sum is equal to $1$, we have a
\emph{distribution}. \ec{distr} is a \emph{type operator} taking a
single type argument:
\begin{easycrypt}{}{}
type 'a distr
\end{easycrypt}
Here, \ec{'a} is a \emph{type variable}, marking the type parameter of
\ec{distr}; if we substitute an actual type for \ec{'a} in \ec{'a distr},
we get a type.

Given types $t_1$ and $t_2$, \ec{$t_1\;$->$\;t_2$} is a function type,
the type of total function transforming inputs of type $t_1$ to
outputs of type $t_2$. \ec{->} associates to the right, so that
\ec{int -> bool -> real} means \ec{int -> (bool -> real)}.

Given types $t_1$ and $t_2$, \ec{$t_1\;$*$\;t_2$} is a product (tuple)
type, whose elements are pairs $(x_1, x_2)$ where $x_1$ and $x_2$ are
elements of $t_1$ and $t_2$, respectively. Tuples may have more than
two components: e.g., \ec{int * int * real} is the type of triples
$(x_1, x_2, x_3)$ where $x_1$ and $x_2$ are integers and $x_3$ is a real.
Note that \ec{int * (int * real)}, \ec{(int * int) * real} and
\ec{int * int * real} are distinct types; the first two are pair types.
\ec{*} has higher precedence than \ec{->}, so that, e.g.,
\ec{int * int -> bool * real} means \ec{(int * int) -> (bool * real)}.

Record types may be declared like this:
\begin{easycrypt}{}{}
type t = { x : int; y : bool; }.
type u = { y : real; yy : int; yyy : real; }.
\end{easycrypt}
Here \ec{t} is the type of records with field projections \ec{x} of
type \ec{int}, and \ec{y} of type \ec{bool}. The order of projections is
irrelevant.  Different record types can't use overlapping projections,
and record projections must be disjoint from operators (see
below). Records any non-zero number of fields; \ec{u} is a record with
three fields. We may also define record type operators, as in:
\begin{easycrypt}{}{}
type 'a t = { x : 'a; f : 'a -> 'a; }.
type ('a, 'b) u = { f : 'a -> 'b; x : 'a; }.
\end{easycrypt}
Then, a value $v$ of type \ec{int t} would have fields \ec{x} and
\ec{f} of types \ec{int} and \ec{int -> int}, respectively; and
a value $v$ of type \ec{(int, bool) u} would have fields \ec{x} and
\ec{f} with types \ec{int} and \ec{int -> bool}, respectively.

Datatypes and datatype operators may be declared like this:
\begin{easycrypt}{}{}
type enum = [ First | Second | Third ].
type either_int_bool = [ First of int | Second of bool ].
type ('a, 'b) either = [ First of 'a | Second of 'b ].
type intlist = [
  | Nil
  | Cons of (int * intlist) ].
type 'a list = [
  | Nil
  | Cons of 'a & 'a list ].
\end{easycrypt}
Here, \ec{First}, \ec{Second}, \ec{Third}, \ec{Nil} and \ec{Cons} are
constructors, and must be distinct from all operators, record
projections and other constructors.  \ec{enum} is an enumerated type
with the three elements \ec{First}, \ec{Second} and \ec{Third}. The
elements of \ec{either_int_bool} consist of \ec{First} applied to an
integer, or \ec{Second} applied to a boolean, and the datatype
operator \ec{either} is simply its generalization to arbitrary types
\ec{'a} and \ec{'b}.  \ec{intlist} is an inductive datatype: its
elements are \ec{Nil} and the results of applying \ec{Cons} to a pairs
of the form $(x, \mathit{ys})$, where $x$ is an integer and
$\mathit{ys}$ is a previously constructed \ec{intlist}.  Note that a
vertical bar (\ec{|}) is permitted before the first constructor of a
datatype. Finally, \ec{list} is the generalization of \ec{intlist} to
lists over an arbitrary type \ec{'a}, but with a twist. The use of
\ec{&} means that \ec{Cons} is ``curried'': instead of applying
\ec{Cons} to a pair $(x, \mathit{ys})$, one gives it \ec{$x$ : 'a} and
\ec{$\mathit{ys}$ : 'a list} one at a time, as in \ec{Cons$\,x\,$
  $\,\mathit{ys}$}.  Unsurprisingly, more than one occurrence of
\ec{&} is allowed in a constructor's definition. E.g., here is the
datatype for binary trees whose leaves and internal nodes are labeled
by integers:
\begin{easycrypt}{}{}
type tree = [
  | Leaf of int
  | Cons of tree & int & tree
].
\end{easycrypt}
Here, \ec{Cons $\,\mathit{tr}_1\,$ $x\,$ $\mathit{tr}_2$} will be the tree
constructed from an integer $x$ and trees $\mathit{tr}_1$ and
$\mathit{tr}_2$.
\EasyCrypt\ must be able to convince itself that a datatype is
nonempty, most commonly because it has at least one constructor
taking no arguments, or only arguments not involving the datatype.

Types and type operators that are simply abbreviations for pre-existing
types may be declared, as in:
\begin{easycrypt}{}{}
type t = int * bool.
type ('a, b) arr = 'a -> 'b.
\end{easycrypt}
Then, e.g., \ec{(int, bool) arr} is the same type as \ec{int -> bool}.

Finally, abstract types and type operators may be declared, as in:
\begin{easycrypt}{}{}
type t.
type ('a, b) u.
\end{easycrypt}
We'll see later how such types and type operators may be used.

\subsection{Expressions}

We'll now survey \EasyCrypt's typed expressions. Anonymous functions
are written \ec{fun ($x$ : $\,t_1$) => $\;e$}, where $x$ is an identifier,
$t_1$ is a type, and $e$ is an expression---probably involving $x$.
If $e$ has type $t_2$ under the assumption that $x$ has type $t_1$,
then the anonymous function will have type \ec{$t_1$ -> $\;\,t_2$}.
Function application is written using juxtapositioning, so that if
$e_1$ has type \ec{$t_1$ -> $\;\,t_2$}, and $e_2$ has type $t_1$, then
$e_1\,e_2$ has type $t_2$. Function application associates to the
left, and anonymous functions extend as far to the right as possible.
\EasyCrypt\ infers the types of the bound variables of anonymous function
when it can. Nested anonymous functions may be abbreviated by
collecting all their bound variables together. E.g., consider the
expression
\begin{easycrypt}{}{}
(fun (x : int) => fun (y : int) => fun (z : bool) => y) 0 1 false
\end{easycrypt}
which evalutes to \ec{1}. It may be appreviated to
\begin{easycrypt}{}{}
(fun (x y : int, z : bool) => y) 0 1 false
\end{easycrypt}
or
\begin{easycrypt}{}{}
(fun (x : int) (y : int) (z : bool) => y) 0 1 false
\end{easycrypt}
or (letting \EasyCrypt\ carry out type inference)
\begin{easycrypt}{}{}
(fun x y z => y) 0 1 false
\end{easycrypt}
In the type inference, only the type of \ec{y} is determined, but
that's acceptable.

An operator may be declared by specifying its type and giving the
expression to be evaluated. E.g.,
\begin{easycrypt}{}{}
op x : int = 3.
op f : int -> bool -> int = fun (x : int) (y : bool) => x.
op g : bool -> int = f 1.
op y : int = g true.
op z = f 1 true.
\end{easycrypt}
Here \ec{f} is a curried function---it takes its arguments one
at a time. Hence \ec{y} and \ec{z} have the same value: \ec{1}.
As illustrated by the declaration of \ec{z}, one may admit the
operator's type when it can be inferred from its expression.
The declaration of \ec{f} may be abbreviated to
\begin{easycrypt}{}{}
op f (x : int) (y : bool) = x.
\end{easycrypt}
or
\begin{easycrypt}{}{}
op f (x : int, y : bool) = x.
\end{easycrypt}

\emph{Polymorphic} operators may be declared, as in
\begin{easycrypt}{}{}
op g ['a, 'b] : 'a -> 'b -> 'a = fun (x : 'a, y : 'b) => x.
\end{easycrypt}
or
\begin{easycrypt}{}{}
op g ['a, 'b] (x : 'a, y : 'b) = x.
\end{easycrypt}
Here \ec{g} has all the types formed
by substituting types for the types variable \ec{'a} and \ec{'b}
in \ec{'a -> 'b -> 'a}. This allows us to use \ec{g} at different
types
\begin{easycrypt}{}{}
op a = g true 0.
op b = g 0 false.
\end{easycrypt}
making \ec{a} and \ec{b} evaluate to \ec{true} and \ec{0}, respectively.

\emph{Abstract} operators may be declared, i.e., ones whose values
are unspecified. E.g., we can declare
\begin{easycrypt}{}{}
op x : int.
op f : int -> int.
op g ['a, 'b] : 'a -> 'b -> 'a.
\end{easycrypt}
Equivalently, \ec{f} and \ec{g} may be declared like this:
\begin{easycrypt}{}{}
op f (x : int) : int.
op g ['a, 'b] (x : 'a, y : 'b) : 'a.
\end{easycrypt}
We'll see later how abstract operators may be used.

Binary operators may be declared and used with infix notation (as long
as they are infix operators). One parenthesizes a binary operator when
declaring it and using it in non-infix form (i.e., as a value).  If
$\mathit{io}$ is an infix operator and $e_1,e_2$ are expressions, then
$e_1\mathbin{\mathit{io}}e_2$ is translated to \ec{($\mathit{io}$)
  $\,e_1$ $\,e_2$}, whenever the latter expression is
well-typed. E.g., if we declare
\begin{easycrypt}{}{}
op (--) ['a, 'b] (x : 'a) (y : 'b) = x.
op x : int = (--) 0 true.
op x' : int = 0 -- true.
op y : bool = (--) true 0.
op y' : bool = true -- 0.
\end{easycrypt}
then \ec{x} and \ec{x'} evaluate to \ec{0}, and
\ec{y} and \ec{y'} evaluate to \ec{true}.

Unary operators may be declared and used with prefix notation
(as long as they are prefix operators).
One (square) brackets a unary operator when
declaring it and using it in non-prefix form (i.e., as a value).
If $\mathit{po}$ is
a prefix operator and $e$ is an expression, then
$\mathit{po}\,e$ is translated to
\ec{[$\mathit{po}$] $\,e$}, whenever the latter
expression is well-typed. E.g., if we declare
\begin{easycrypt}{}{}
op x : int.
op f : int -> int.
op [!] : int -> int.
op y : int = ! f x.
op y' : int = [!](f x).
\end{easycrypt}
then \ec{y} and \ec{y'} both evaluate to the result of applying the
abstract operator \ec{!} of type \ec{int -> int} to the result of
applying the abstract operator \ec{f} of type \ec{int -> int} to the
abstract value \ec{x} of type \ec{int}.  Function application has
higher precedence than prefix operators, which have higher precedence
than infix operators, prefix operators group to the right, and infix
operators have the associativities and relative precedences that were
detailed in Section~\ref{Lexical}.

The four mixfix operators may be declared and used as follows. They
are (double) quoted when being declared or used in non-mixfix form
(i.e., as values).
\begin{itemize}
\item (\ec{[]})\quad \ec{[]} is translated to \ec{\"[]\"}. E.g.,
  if we declare
\begin{easycrypt}{}{}
op "[]" : int = 3.
op x : int = [].
\end{easycrypt}
then \ec{x} will evaluate to \ec{3}.

\item (\ec{`|_|})\quad If $e$ is an expression, then \ec{`|$e$|} is
  translated to \ec{\"`|_|\" $\,e$}, as long as the latter expression
  is well-typed.  E.g., if we declare
\begin{easycrypt}{}{}
op "`|_|" : int -> bool.
op x : bool = "`|_|" 3.
op y : bool = `|3|.
\end{easycrypt}
then \ec{y} will evaluate to the same value as \ec{x}.

\item (\ec{_.[_]})\quad If $e_1,e_2$ are expressions, then
    \ec{$e_1$.[$e_2$]} is translated to \ec{\"_.[_]\" $\,e_1$
      $\,e_2$}, whenever the latter expression is well-typed. E.g., if
    we declare
\begin{easycrypt}{}{}
op "_.[_]" : int -> int -> bool.
op x : bool = "_.[_]" 3 4.
op y : bool = 3.[4].
\end{easycrypt}
then \ec{y} will evaluate to the same value as \ec{x}.

\item (\ec{_.[_<-_]})\quad If $e_1,e_2,e_3$ are expressions, then
    \ec{$e_1$.[$e_2$ <- $\,e_3$]} is translated to \ec{\"_.[_<-_]\"
      $\,e_1$ $\,e_2$ $\,e_3$}, whenever the latter expression is
    well-typed. E.g., if we declare
\begin{easycrypt}{}{}
op "_.[_<-_]" : int -> int -> int -> bool.
op x : bool = "_.[_<-_]" 3 4 5.
op y : bool = 3.[4 <- 5].
\end{easycrypt}
then \ec{y} will evaluate to the same value as \ec{x}.
\end{itemize}
In addition, if $e_1,\ldots,e_n$ are expressions then
\begin{center}
\ec{[$e_1$; $\;\ldots\,$; $\,e_n$]}  
\qquad is translated to \qquad
\ec{$e_1$ :: $\;\ldots$ :: $\;e_n$ :: []}
\end{center}
whenever the latter expression is well-typed.
The initial argument of \ec{\"_.[_]\"} and \ec{\"_.[_<-_]\"} have
higher precedence than even function application. E.g., one
can't omit the parentheses in
\begin{easycrypt}{}{}
op f : int -> int.
op y : bool = (f 3).[4].
op z : bool = (f 3).[4 <- 5].
\end{easycrypt}

Some operators are built-in to \EasyCrypt, automatically understood
by its ambient logic:
\begin{easycrypt}{}{}
op (=) ['a]: 'a -> 'a -> bool.

op [!] : bool -> bool.
op (||) : bool -> bool -> bool.
op (\\/) : bool -> bool -> bool.
op (&&) : bool -> bool -> bool.
op (/\\) : bool -> bool -> bool.
op (=>) : bool -> bool -> bool.
op (<=>) : bool -> bool -> bool.

op mu : 'a distr -> ('a -> bool) -> real.
\end{easycrypt}
The operator \ec{=} is equality. On the booleans, we have negation
\ec{!}, two forms of disjunction (\ec{\\/} and \ec{||}) and conjuction
(\ec{/\\} and \ec{&&}), implication (\ec{=>}) and if-and-only-if
(\ec{<=>}).  The two disjuctions (respectively, conjunctions) are
semantically equivalent, but are treated differently by \EasyCrypt
proof engine. The associativities and precedences of the infix
operators were given in Section~\ref{Lexical}, and (as a prefix
operator) \ec{!} has higher precedence than all of them. The
expression \ec{$e_1$ <> $\;e_2$} is treated as \ec{!($e_1$ =
  $\;e_2$)}. \ec{<>} is not an operator, but it the precedence and
non-associative status of Section~\ref{Lexical}.
The intended meaning of \ec{mu $\,d$ $\,p$} is the probability that
randomly choosing a value of the given type from the sub-distribution
$d$ will satisfy the function $p$ (in the sense of causing it to return
\ec{true}).
In addition, if $e$ is an expression of type \ec{int}, then
\ec{$e$\%r} is the corresponding real.

If $e_1$ is an expression of type \ec{bool} and $e_2,e3$ are expressions
of some type $t$, then the \emph{conditional expression}
\ec{$e_1$ ? $\,e_2$ : $\,e_3$} evaluates $e_2$, if $e_1$ evaluates to
\ec{true}, and evaluates $e_3$, if $e_1$ evaluates to \ec{false}.
E.g., if we write
\begin{easycrypt}{}{}
op x : int = (3 < 4) ? 4 + 7 : (9 - 1).
\end{easycrypt}
then \ec{x} evaluates to \ec{11}. The conditional expression's
precedence at its first argument is lower than function
application, but higher than the prefix operators; its second argument
needn't be parenthesized; and the precedence at its third argument is
lower than the prefix operators, but higher than the infix operators.

For the built-in types \ec{bool}, \ec{int} and \ec{real}, and the type
operator \ec{distr}, the \EasyCrypt\ Library (see
Chapter~\ref{Library}) provides corresponding theories, \ec{Bool},
\ec{Int}, \ec{Real} and \ec{Distr}. These theories provide various
operations, axioms, etc.  To make use of a theory, one must
``require'' it.  E.g.,
\begin{easycrypt}{}{}
require Bool Int Real Distr.
\end{easycrypt}
will make the theories just mentioned available. This
would allow us to write, e.g.,
\begin{easycrypt}{}{}
op x = Int.(+) 3 4.
\end{easycrypt}
making \ec{x} evaluate to \ec{7}. But to be able to use \ec{+}
and the other operators provided by \ec{Int}
in infix form without qualification (specifying which theory to
find it in), we need to import \ec{Int}. If we do
\begin{easycrypt}{}{}
import Bool Int Real.
op x : int = 3 + 4 - 7 * 2.
op y : real = 5%r * 3%r / 2%r.
op z : bool = x%r >= y.
\end{easycrypt}
we'll end up with \ec{z} evaluating to \ec{false}.
One may combine requiring and importing in one step:
\begin{easycrypt}{}{}
require import Bool Int Real Distr.
\end{easycrypt}
We'll cover theories and their usage in detail in
Chapter~\ref{Structuring}.

Requring the theory \ec{Bool} makes available the value \ec{\{0,1\}}
of type \ec{bool distr} that is the uniform distribution on
the booleans. (No whitespace is allowed in the name for this distribution,
and the \ec{0} must come before the \ec{1}.)
Requring the theory \ec{Distr} make available syntax for the uniform
distribution of integers from a finite range. If $e_1$ and $e_2$
are expressions of type \ec{int} denoting $n_1$ and $n_2$, respectively,
then \ec{[$e_1$..$e_2$]} is the value of type \ec{int distr}
that is the uniform distribution on the set of
all integers that are greater-than-or-equal to $n_1$ and less-than-or-equal-to
$n_2$---unless $n_1>n_2$, in which case it is the subdistribution assigning
probability $0$ to all integers.

Values of product (tuple) and record types are constructed and
destructed as follows:
\begin{easycrypt}{}{}
op x : int * int * bool = (3, 4, true).
op b : bool = x .` 3.
type t = { u : int; v : bool; }.
op y : t = {| v = false; u = 10; |}.
op a : bool = y .` v.
\end{easycrypt}
Then, \ec{b} evaluates to \ec{true}, and \ec{a} evaluates to \ec{false}.
Note the field order in the declaration of \ec{y} was allowed to be
a permutation of that of the record type \ec{t}.

When we declare a datatype, its constructors are available to
us as values. E.g, if we declare
\begin{easycrypt}{}{}
type ('a, 'b) either = [Fst of 'a | Snd of 'b].
op x : (int, bool) either = Fst 10.
op y : int -> (int, bool) either = Fst.
op z : (int, bool) either = y 10.
\end{easycrypt}
then \ec{z} evaluates to the same result as \ec{x}.

We can declare operators using pattern matching on the constructors
of datatypes. E.g., continuing the previous example, we can
declare and use an operator \ec{fst} by:
\begin{easycrypt}{}{}
op fst ['a, 'b] (def : 'a) (ei : ('a, 'b) either) : 'a =
  with ei = Fst a => a
  with ei = Snd b => def.
op l1 : (int, bool) either = Fst 10.
op l2 : (int, bool) either = Snd true.
op m1 : int = fst (-1) l1.
op m2 : int = fst (-1) l2.
\end{easycrypt}
Here, \ec{m1} will evaluate to \ec{10}, whereas \ec{m2} will
evaluate to \ec{-1}.
Such operator declarations may be recursive, as long as \EasyCrypt\
can determine that the recursion if well-founded. E.g., here is one
way of declaring an operator \ec{list} that computes the length
of a list:
\begin{easycrypt}{}{}
type 'a list = [Nil | Cons of 'a & 'a list].
op len ['a] (acc : int, xs : 'a list) : int =
  with xs = Nil => acc
  with xs = Cons y ys => len (acc + 1) ys.
op length ['a] (xs : 'a list) = len 0 xs.
op xs = Cons 0 (Cons 1 (Cons 2 Nil)).
op n : int = length xs.
\end{easycrypt}
Then \ec{n} will evaluate to \ec{3}.

\section{Module System}

\subsection{Modules}

\EasyCrypt's modules consist of typed global variables and procedures,
which have different name spaces.
Listing~\ref{SimpMod} contains the definition of a simple module,
\ec{M}, which exemplifies much of the module language.
\ecinput{examps/specifications-examp1.ec}{Simple
  Module}{}{SimpMod}
\ec{M} has one \emph{global variable}---\ec{x}---which is used by the
\emph{procedures} of \ec{M}---\ec{init}, \ec{incr}, \ec{get} and
\ec{main}. Global variables must be declared before the procedures
that use them.

The procedure \ec{init} (``initialize'') has a \emph{parameter} (or
\emph{argument}) \ec{bnd} (``bound'') of type \ec{int}. It declares a
\emph{local variable} \ec{y}---local in the sense that other
procedures can't access or affect it. \ec{init} uses a \emph{random
  assignment} to assign to \ec{y} an integer chosen uniformly from the
integers whose absolute values are at most \ec{bnd}. It then uses an
\emph{ordinary assignment} to assign to \ec{x} the result of adding
\ec{y} to the previous value of \ec{x}.  The return type of \ec{init}
is \ec{unit}, whose only element is \ec{tt}; this is implicly returned
by \ec{init} upon exit.

The procedure \ec{incr} (``increment''), increments the value of
\ec{x} by its parameter \ec{n}. The procedure \ec{get} takes no
parameters, but simply returns the value of \ec{x}, using
a \emph{return statement}---which is only allowed as the
final statement of a procedure.

And the \ec{main} procedures takes no parameters, and returns a boolean
that's computed as follows:
\begin{itemize}
\item It declares a local variable, \ec{n}, of type \ec{int}.

\item It uses a \emph{procedure call} to call the procedure \ec{init}
  with a bound of \ec{100}, causing \ec{x} to be initialized to an
  integer between \ec{-100} and \ec{100}.

\item It calls \ec{incr} twice, with \ec{10} and then \ec{-50}.

\item It uses a \emph{procedure call assignment} to call the procedure
  \ec{get} with no arguments, and assign \ec{get}'s return value to \ec{n}.

\item It evaluates the boolean expression \ec{n < 0}, and returns
  the value of this expression as its boolean result.
\end{itemize}

As we've seen, each declaration or statement of a procedure is
terminated with a semicolon.  \EasyCrypt tries to infer the types of
local variables. So, in the above example, one could write \ec{var y;}
and \ec{var n;} for the local declarations of \ec{y} and \ec{n}.
One may combine multiple local variable declarations, as in:
\begin{easycrypt}{}{}
var x, y, z : int;
var u, v;
var x, y, z : int = 10;
var x, y, z = 10;
\end{easycrypt}
The three kinds of assignment statements differ according to their
allowed right-hand sides (rhs):
\begin{itemize}
\item The rhs of a random assignment must be a single
  (sub-)distribution.

\item The rhs of an ordinary assignment may be an arbitrary expression
  (which doesn't include use of procedures or random assignments).

\item the rhs of a procedure call assignment must be a single procedure
  call.  
\end{itemize}
If the rhs of an assignment produces a tuple value, its left-hand side
may use pattern matching, as in
\begin{easycrypt}{}{}
(x, y, z) <- #\ldots#;
\end{easycrypt}
in the case where $\ldots$ produces a triple.

The two remaining kinds of statements are illustrated in
Listing~\ref{CondWhileExamp}: \emph{conditionals} and \emph{while
  loops}.
\ecinput{examps/specifications-examp2.ec}{Conditionals
  and While Loops} {}{CondWhileExamp}
\ec{N} has a single procedure,
\ec{loop}, which begins by initializing a local variable \ec{y} to
\ec{0}. It then enters a while loop, which continues executing until
(which may never happen) \ec{y} becomes \ec{10} or more. At each
iteration of the while loop, an integer between \ec{1} and \ec{10} is
randomly chosen and assigned to the local variable \ec{z}. The
conditional is used to behave differently depending upon whether the
value of \ec{z} is less-than-or-equal-to \ec{5} or not.
\begin{itemize}
\item When the answer is ``yes'', \ec{y} is decremented by the \ec{z}.

\item When the answer is ``no'', \ec{y} is incremented by \ec{z - 5}.
\end{itemize}
Once (if) the while loop is exited---which means \ec{y} is now \ec{10}
or more---the procedure returns \ec{y}'s value as its return value.

When the body of a while loop, or the then or else part of a conditional,
has a single statement, the curly braces may be omitted. E.g., the
conditional of the preceding example could be written:
\begin{easycrypt}{}{}
if (z <= 5) y <- y - z;
else y <- y + (z - 5);
\end{easycrypt}
And when the else part of a conditional is empty (consists of
\ec{\{\}}), it may be omitted, as in:
\begin{easycrypt}{}{}
if (z <= 5) y <- y - z;
\end{easycrypt}

As illustrated in Listing~\ref{UsingOtherModuleExamp}, modules may
access the global variables, and call the procedures, of previously
declared modules.
\ecinput{examps/specifications-examp3.ec}{One
  Module Using Another Module} {}{UsingOtherModuleExamp} Procedure
\ec{g} of \ec{N} both accesses the global varialble \ec{x} of module
\ec{N} (\ec{M.x}), and calls \ec{N}'s procedure, \ec{f} (\ec{N.f}).
The parameter list of \ec{g} could equivalently be written:
\begin{easycrypt}{}{}
n : int, m : int, b : bool  
\end{easycrypt}
A module may refer to its own global variables using its own module
name, allowing us to write
\begin{easycrypt}{}{}
proc f() : unit = {
  M.x <- M.x + 1;
}
\end{easycrypt}
for the definition of procedure \ec{M.f}.  The procedure \ec{h} of
\ec{N} is an alias for procedure \ec{M.f}: calling it is equivalent to
directly calling \ec{M.f}.
One declare a module name to be an alias for a module, as in
\begin{easycrypt}{}{}
module L = N.
\end{easycrypt}

A procedure call has a context---a \emph{memory} recording the global
variables of all involved modules.  Even if a global variable of a
module isn't explicitly initialized, it will still have a well-defined
value in such a memory.

\subsection{Module Types}

\EasyCrypt's \emph{module types} specify the types for some number of
procedures.  E.g., consider the module type \ec{OR} :
\ecinput{examps/specifications-examp4.ec}{} {3-7}{}
\ec{OR} describes minimum expectations
for a ``guessing oracle''---that it provide at least procedures with
the specified types.  The order of the procedures in a module type is
irrelevant.  The names of procedure parameters used in module types
are purely for documentation purposes; one may elide them instead
using underscores, writing, e.g.,
\begin{easycrypt}{}{}
proc init(_ : int, _ : int, _ : bool) : unit
\end{easycrypt}
instead of
\begin{easycrypt}{}{}
proc init(secret tries : int, x : bool) : unit
\end{easycrypt}
Note that module types say nothing about the global variables a module
should have.

Listing~\ref{GuessOrModule} contains an example guessing oracle
implementation.  \ecinput{examps/specifications-examp4.ec}{Guessing
  Oracle Module} {9-30}{GuessOrModule} Its \ec{init} procedure stores
the supplied secret in the global variable \ec{sec}, initializes the
allowed number of guesses in the global variable \ec{tris}, and
initializes the \ec{guessed} global variable to record that the secret
hasn't yet been guessed.  If more allowed tries remain, the \ec{guess}
procedure updates \ec{guessed} to take into account the supplied
guess, and decrements the allowed number of tries; otherwise, it does
nothing.  And its \ec{guessed} procedure returns the value of
\ec{guessed}, indicating whether the secret has been successfully
guessed, so far. \ec{Or} matches the specification of the module type
\ec{OR}, and we can ask \EasyCrypt\ to check this by supplying that
module type when declaring \ec{Or}, as in
Listing~\ref{GuessOrModuleCheck}
\ecinput{examps/specifications-examp5.ec}{Guessing Oracle Module with
  Module Type Check} {9-30}{GuessOrModuleCheck} Supplying a module
type \emph{doesn't} change the result of a module declaration. E.g.,
if we had omitted \ec{guessed} from the module type \ec{OR}, then the
module \ec{Or} would still have the procedure \ec{guessed}.

Suppose we want to declare a cryptographic game using our guessing
oracle, parameterized by an adversary with access to the \ec{guess}
procedure of the oracle, and which provides two procedures---one
for choosing the range in which the guessing game will operate, and
one for doing the guessing.  We'd like to write something like:
\begin{easycrypt}{}{}
module type GAME = {
  proc main() : bool
}.

module Game(Adv : ADV) : GAME = {
  module A = Adv(Or)
  proc main() : bool = { #\ldots# }
}.
\end{easycrypt}
Thus, the module type \ec{ADV} for adversaries must be parameterized
by an implementation of \ec{OR}. Given the adversary procedures we have
in mind, the syntax for this is
\begin{easycrypt}{}{}
module type ADV(O : OR) = {
  proc chooseRange() : int * int
  proc doGuessing() : unit
}.
\end{easycrypt}
But this declaration would give adversary access to all of \ec{O}'s
procedures, which isn't what we want. Instead, we can write
\begin{easycrypt}{}{}
module type ADV(O : OR) = {
  proc chooseRange() : int * int {}
  proc doGuessing() : unit {O.guess}
}.
\end{easycrypt}
meaning that \ec{chooseRange} has no access to the oracle, and
\ec{doGuessing} may only call its \ec{guess} procedure. Using
this notation, our original attempt would be written
\begin{easycrypt}{}{}
module type ADV(O : OR) = {
  proc chooseRange() : int * int {O.init O.guess O.guessed}
  proc doGuessing() : unit {O.init O.guess O.guessed}
}
\end{easycrypt}
Finally, we can specify that \ec{chooseRange} must initialize
all of the adversary's global variables (if any) by using a
star annotation:
\begin{easycrypt}{}{}
module type ADV(O : OR) = {
  proc * chooseRange() : int * int {}
  proc doGuessing() : unit {O.guess}
}.
\end{easycrypt}

The full Guessing Game example is contained in Listing~\ref{FullGuessing}.
\ecinput{examps/specifications-examp5.ec}{Full
  Guessing Game Example} {}{FullGuessing}
%\ecinput{examps/specifications-examp5.ec}{Full
%  Guessing Game Example (II)} {57-82}{FullGuessingII}
%\ec{SimpAdv} is a simple implementation of an adversary.
The inclusion of the constraint \ec{ADV(O)} in
\begin{easycrypt}{}{}
module SimpAdv(O : OR) : ADV(O) = #\ldots#
\end{easycrypt}
makes \EasyCrypt\ check that: its implementation of \ec{chooseRange}
doesn't use \ec{O} at all; its implementation of \ec{doGuessing}
doesn't use any of \ec{O}'s procedures other than \ec{guess}; and
that \ec{doGuessing} initializes \ec{SimpAdv}'s global variables.
Its \ec{chooseRange} procedure chooses the range of \ec{1} to \ec{100},
and initializes global variables recording this range and the
number of guesses it will make (see the code of \ec{Game} to see
why \ec{10} is a sensible choice). The \ec{doGuessing} procedure
make \ec{10} random guesses.

Despite \ec{SimpAdv} being a parameterized module, to refer to one
of its global variables from another module one ignores the parameter,
saying, e.g.,
\begin{easycrypt}{}{}
module X = {
  proc f() : int = {
    return SimpAdv.tries;
  }
}.
\end{easycrypt}
On the other hand, to call one of \ec{SimpAdv}'s procedures, one needs
to specify which oracle parameter it will use, as in:
\begin{easycrypt}{}{}
module X = {
  proc f() : unit = {
    SimpAdv(Or).doGuessing();
  }
}.
\end{easycrypt}

The module \ec{Game} gives its adversary parameter, \ec{Adv}, the
concerete guessing oracle \ec{Or}, calling the result \ec{A}. It's
main function then uses \ec{Or} and \ec{A} to run the game.
\begin{itemize}
\item It calls \ec{A}'s \ec{chooseRange} procedure to get the adversary's
  choice of guessing range. If the range doesn't have at least ten elements,
  it returns \ec{false} without doing anything else---the adversary
  has supplied a range that's too small.

\item Otherwise, it uses \ec{Or.init} to initialize the guessing
  oracle with a secret that's randomly chosen from the range, plus a
  number of allowed guesses that's one tenth of the range's size.

\item It then calls \ec{A.doGuessing}, allowing the adversay to
  attempt the guess the secret.

\item Finally, it calls \ec{Or.guessed} to learn whether the
  adversary has guessed the secret, returning this boolean
  value as its result.
\end{itemize}

Finally, the declaration
\begin{easycrypt}{}{}
module SimpGame = Game(SimpAdv).
\end{easycrypt}
declares \ec{SimpGame} to be the specialization of \ec{Game} to
our simple adversary, \ec{SimpAdv}.

The reader might be wondering what---if anything---prevents us writing
a version of \ec{SimpAdv} that directly accesses/calls the global
variables and procedures of \ec{Or} (or of \ec{Game}, were \ec{SimpAdv}
declared after it), violating our understanding of the adversary's
power. The answer is that \EasyCrypt's type checker isn't in a position
to do this. Instead, we'll see in the next section how such
constraints are modeled using \EasyCrypt's logic.

\section{Logics}
